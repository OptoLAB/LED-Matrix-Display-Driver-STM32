
LED_MATRIX_DISPLAY_STM32.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00007aec  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000544  08007c7c  08007c7c  00017c7c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080081c0  080081c0  0002008c  2**0
                  CONTENTS
  4 .ARM          00000008  080081c0  080081c0  000181c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080081c8  080081c8  0002008c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080081c8  080081c8  000181c8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080081cc  080081cc  000181cc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000008c  20000000  080081d0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00008f40  2000008c  0800825c  0002008c  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20008fcc  0800825c  00028fcc  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0002008c  2**0
                  CONTENTS, READONLY
 12 .debug_info   00028122  00000000  00000000  000200bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000042a0  00000000  00000000  000481de  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0001e08b  00000000  00000000  0004c47e  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000e68  00000000  00000000  0006a510  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00004470  00000000  00000000  0006b378  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  00023c5f  00000000  00000000  0006f7e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   00012461  00000000  00000000  00093447  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    000ca6c7  00000000  00000000  000a58a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  0016ff6f  2**0
                  CONTENTS, READONLY
 21 .debug_frame  000035a8  00000000  00000000  0016ffec  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	2000008c 	.word	0x2000008c
 80001ac:	00000000 	.word	0x00000000
 80001b0:	08007c64 	.word	0x08007c64

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000090 	.word	0x20000090
 80001cc:	08007c64 	.word	0x08007c64

080001d0 <memchr>:
 80001d0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001d4:	2a10      	cmp	r2, #16
 80001d6:	db2b      	blt.n	8000230 <memchr+0x60>
 80001d8:	f010 0f07 	tst.w	r0, #7
 80001dc:	d008      	beq.n	80001f0 <memchr+0x20>
 80001de:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001e2:	3a01      	subs	r2, #1
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d02d      	beq.n	8000244 <memchr+0x74>
 80001e8:	f010 0f07 	tst.w	r0, #7
 80001ec:	b342      	cbz	r2, 8000240 <memchr+0x70>
 80001ee:	d1f6      	bne.n	80001de <memchr+0xe>
 80001f0:	b4f0      	push	{r4, r5, r6, r7}
 80001f2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80001f6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80001fa:	f022 0407 	bic.w	r4, r2, #7
 80001fe:	f07f 0700 	mvns.w	r7, #0
 8000202:	2300      	movs	r3, #0
 8000204:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000208:	3c08      	subs	r4, #8
 800020a:	ea85 0501 	eor.w	r5, r5, r1
 800020e:	ea86 0601 	eor.w	r6, r6, r1
 8000212:	fa85 f547 	uadd8	r5, r5, r7
 8000216:	faa3 f587 	sel	r5, r3, r7
 800021a:	fa86 f647 	uadd8	r6, r6, r7
 800021e:	faa5 f687 	sel	r6, r5, r7
 8000222:	b98e      	cbnz	r6, 8000248 <memchr+0x78>
 8000224:	d1ee      	bne.n	8000204 <memchr+0x34>
 8000226:	bcf0      	pop	{r4, r5, r6, r7}
 8000228:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800022c:	f002 0207 	and.w	r2, r2, #7
 8000230:	b132      	cbz	r2, 8000240 <memchr+0x70>
 8000232:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000236:	3a01      	subs	r2, #1
 8000238:	ea83 0301 	eor.w	r3, r3, r1
 800023c:	b113      	cbz	r3, 8000244 <memchr+0x74>
 800023e:	d1f8      	bne.n	8000232 <memchr+0x62>
 8000240:	2000      	movs	r0, #0
 8000242:	4770      	bx	lr
 8000244:	3801      	subs	r0, #1
 8000246:	4770      	bx	lr
 8000248:	2d00      	cmp	r5, #0
 800024a:	bf06      	itte	eq
 800024c:	4635      	moveq	r5, r6
 800024e:	3803      	subeq	r0, #3
 8000250:	3807      	subne	r0, #7
 8000252:	f015 0f01 	tst.w	r5, #1
 8000256:	d107      	bne.n	8000268 <memchr+0x98>
 8000258:	3001      	adds	r0, #1
 800025a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800025e:	bf02      	ittt	eq
 8000260:	3001      	addeq	r0, #1
 8000262:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000266:	3001      	addeq	r0, #1
 8000268:	bcf0      	pop	{r4, r5, r6, r7}
 800026a:	3801      	subs	r0, #1
 800026c:	4770      	bx	lr
 800026e:	bf00      	nop

08000270 <__aeabi_uldivmod>:
 8000270:	b953      	cbnz	r3, 8000288 <__aeabi_uldivmod+0x18>
 8000272:	b94a      	cbnz	r2, 8000288 <__aeabi_uldivmod+0x18>
 8000274:	2900      	cmp	r1, #0
 8000276:	bf08      	it	eq
 8000278:	2800      	cmpeq	r0, #0
 800027a:	bf1c      	itt	ne
 800027c:	f04f 31ff 	movne.w	r1, #4294967295
 8000280:	f04f 30ff 	movne.w	r0, #4294967295
 8000284:	f000 b972 	b.w	800056c <__aeabi_idiv0>
 8000288:	f1ad 0c08 	sub.w	ip, sp, #8
 800028c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000290:	f000 f806 	bl	80002a0 <__udivmoddi4>
 8000294:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000298:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800029c:	b004      	add	sp, #16
 800029e:	4770      	bx	lr

080002a0 <__udivmoddi4>:
 80002a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002a4:	9e08      	ldr	r6, [sp, #32]
 80002a6:	4604      	mov	r4, r0
 80002a8:	4688      	mov	r8, r1
 80002aa:	2b00      	cmp	r3, #0
 80002ac:	d14b      	bne.n	8000346 <__udivmoddi4+0xa6>
 80002ae:	428a      	cmp	r2, r1
 80002b0:	4615      	mov	r5, r2
 80002b2:	d967      	bls.n	8000384 <__udivmoddi4+0xe4>
 80002b4:	fab2 f282 	clz	r2, r2
 80002b8:	b14a      	cbz	r2, 80002ce <__udivmoddi4+0x2e>
 80002ba:	f1c2 0720 	rsb	r7, r2, #32
 80002be:	fa01 f302 	lsl.w	r3, r1, r2
 80002c2:	fa20 f707 	lsr.w	r7, r0, r7
 80002c6:	4095      	lsls	r5, r2
 80002c8:	ea47 0803 	orr.w	r8, r7, r3
 80002cc:	4094      	lsls	r4, r2
 80002ce:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80002d2:	0c23      	lsrs	r3, r4, #16
 80002d4:	fbb8 f7fe 	udiv	r7, r8, lr
 80002d8:	fa1f fc85 	uxth.w	ip, r5
 80002dc:	fb0e 8817 	mls	r8, lr, r7, r8
 80002e0:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80002e4:	fb07 f10c 	mul.w	r1, r7, ip
 80002e8:	4299      	cmp	r1, r3
 80002ea:	d909      	bls.n	8000300 <__udivmoddi4+0x60>
 80002ec:	18eb      	adds	r3, r5, r3
 80002ee:	f107 30ff 	add.w	r0, r7, #4294967295
 80002f2:	f080 811b 	bcs.w	800052c <__udivmoddi4+0x28c>
 80002f6:	4299      	cmp	r1, r3
 80002f8:	f240 8118 	bls.w	800052c <__udivmoddi4+0x28c>
 80002fc:	3f02      	subs	r7, #2
 80002fe:	442b      	add	r3, r5
 8000300:	1a5b      	subs	r3, r3, r1
 8000302:	b2a4      	uxth	r4, r4
 8000304:	fbb3 f0fe 	udiv	r0, r3, lr
 8000308:	fb0e 3310 	mls	r3, lr, r0, r3
 800030c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000310:	fb00 fc0c 	mul.w	ip, r0, ip
 8000314:	45a4      	cmp	ip, r4
 8000316:	d909      	bls.n	800032c <__udivmoddi4+0x8c>
 8000318:	192c      	adds	r4, r5, r4
 800031a:	f100 33ff 	add.w	r3, r0, #4294967295
 800031e:	f080 8107 	bcs.w	8000530 <__udivmoddi4+0x290>
 8000322:	45a4      	cmp	ip, r4
 8000324:	f240 8104 	bls.w	8000530 <__udivmoddi4+0x290>
 8000328:	3802      	subs	r0, #2
 800032a:	442c      	add	r4, r5
 800032c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8000330:	eba4 040c 	sub.w	r4, r4, ip
 8000334:	2700      	movs	r7, #0
 8000336:	b11e      	cbz	r6, 8000340 <__udivmoddi4+0xa0>
 8000338:	40d4      	lsrs	r4, r2
 800033a:	2300      	movs	r3, #0
 800033c:	e9c6 4300 	strd	r4, r3, [r6]
 8000340:	4639      	mov	r1, r7
 8000342:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000346:	428b      	cmp	r3, r1
 8000348:	d909      	bls.n	800035e <__udivmoddi4+0xbe>
 800034a:	2e00      	cmp	r6, #0
 800034c:	f000 80eb 	beq.w	8000526 <__udivmoddi4+0x286>
 8000350:	2700      	movs	r7, #0
 8000352:	e9c6 0100 	strd	r0, r1, [r6]
 8000356:	4638      	mov	r0, r7
 8000358:	4639      	mov	r1, r7
 800035a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800035e:	fab3 f783 	clz	r7, r3
 8000362:	2f00      	cmp	r7, #0
 8000364:	d147      	bne.n	80003f6 <__udivmoddi4+0x156>
 8000366:	428b      	cmp	r3, r1
 8000368:	d302      	bcc.n	8000370 <__udivmoddi4+0xd0>
 800036a:	4282      	cmp	r2, r0
 800036c:	f200 80fa 	bhi.w	8000564 <__udivmoddi4+0x2c4>
 8000370:	1a84      	subs	r4, r0, r2
 8000372:	eb61 0303 	sbc.w	r3, r1, r3
 8000376:	2001      	movs	r0, #1
 8000378:	4698      	mov	r8, r3
 800037a:	2e00      	cmp	r6, #0
 800037c:	d0e0      	beq.n	8000340 <__udivmoddi4+0xa0>
 800037e:	e9c6 4800 	strd	r4, r8, [r6]
 8000382:	e7dd      	b.n	8000340 <__udivmoddi4+0xa0>
 8000384:	b902      	cbnz	r2, 8000388 <__udivmoddi4+0xe8>
 8000386:	deff      	udf	#255	; 0xff
 8000388:	fab2 f282 	clz	r2, r2
 800038c:	2a00      	cmp	r2, #0
 800038e:	f040 808f 	bne.w	80004b0 <__udivmoddi4+0x210>
 8000392:	1b49      	subs	r1, r1, r5
 8000394:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000398:	fa1f f885 	uxth.w	r8, r5
 800039c:	2701      	movs	r7, #1
 800039e:	fbb1 fcfe 	udiv	ip, r1, lr
 80003a2:	0c23      	lsrs	r3, r4, #16
 80003a4:	fb0e 111c 	mls	r1, lr, ip, r1
 80003a8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80003ac:	fb08 f10c 	mul.w	r1, r8, ip
 80003b0:	4299      	cmp	r1, r3
 80003b2:	d907      	bls.n	80003c4 <__udivmoddi4+0x124>
 80003b4:	18eb      	adds	r3, r5, r3
 80003b6:	f10c 30ff 	add.w	r0, ip, #4294967295
 80003ba:	d202      	bcs.n	80003c2 <__udivmoddi4+0x122>
 80003bc:	4299      	cmp	r1, r3
 80003be:	f200 80cd 	bhi.w	800055c <__udivmoddi4+0x2bc>
 80003c2:	4684      	mov	ip, r0
 80003c4:	1a59      	subs	r1, r3, r1
 80003c6:	b2a3      	uxth	r3, r4
 80003c8:	fbb1 f0fe 	udiv	r0, r1, lr
 80003cc:	fb0e 1410 	mls	r4, lr, r0, r1
 80003d0:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80003d4:	fb08 f800 	mul.w	r8, r8, r0
 80003d8:	45a0      	cmp	r8, r4
 80003da:	d907      	bls.n	80003ec <__udivmoddi4+0x14c>
 80003dc:	192c      	adds	r4, r5, r4
 80003de:	f100 33ff 	add.w	r3, r0, #4294967295
 80003e2:	d202      	bcs.n	80003ea <__udivmoddi4+0x14a>
 80003e4:	45a0      	cmp	r8, r4
 80003e6:	f200 80b6 	bhi.w	8000556 <__udivmoddi4+0x2b6>
 80003ea:	4618      	mov	r0, r3
 80003ec:	eba4 0408 	sub.w	r4, r4, r8
 80003f0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80003f4:	e79f      	b.n	8000336 <__udivmoddi4+0x96>
 80003f6:	f1c7 0c20 	rsb	ip, r7, #32
 80003fa:	40bb      	lsls	r3, r7
 80003fc:	fa22 fe0c 	lsr.w	lr, r2, ip
 8000400:	ea4e 0e03 	orr.w	lr, lr, r3
 8000404:	fa01 f407 	lsl.w	r4, r1, r7
 8000408:	fa20 f50c 	lsr.w	r5, r0, ip
 800040c:	fa21 f30c 	lsr.w	r3, r1, ip
 8000410:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8000414:	4325      	orrs	r5, r4
 8000416:	fbb3 f9f8 	udiv	r9, r3, r8
 800041a:	0c2c      	lsrs	r4, r5, #16
 800041c:	fb08 3319 	mls	r3, r8, r9, r3
 8000420:	fa1f fa8e 	uxth.w	sl, lr
 8000424:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8000428:	fb09 f40a 	mul.w	r4, r9, sl
 800042c:	429c      	cmp	r4, r3
 800042e:	fa02 f207 	lsl.w	r2, r2, r7
 8000432:	fa00 f107 	lsl.w	r1, r0, r7
 8000436:	d90b      	bls.n	8000450 <__udivmoddi4+0x1b0>
 8000438:	eb1e 0303 	adds.w	r3, lr, r3
 800043c:	f109 30ff 	add.w	r0, r9, #4294967295
 8000440:	f080 8087 	bcs.w	8000552 <__udivmoddi4+0x2b2>
 8000444:	429c      	cmp	r4, r3
 8000446:	f240 8084 	bls.w	8000552 <__udivmoddi4+0x2b2>
 800044a:	f1a9 0902 	sub.w	r9, r9, #2
 800044e:	4473      	add	r3, lr
 8000450:	1b1b      	subs	r3, r3, r4
 8000452:	b2ad      	uxth	r5, r5
 8000454:	fbb3 f0f8 	udiv	r0, r3, r8
 8000458:	fb08 3310 	mls	r3, r8, r0, r3
 800045c:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8000460:	fb00 fa0a 	mul.w	sl, r0, sl
 8000464:	45a2      	cmp	sl, r4
 8000466:	d908      	bls.n	800047a <__udivmoddi4+0x1da>
 8000468:	eb1e 0404 	adds.w	r4, lr, r4
 800046c:	f100 33ff 	add.w	r3, r0, #4294967295
 8000470:	d26b      	bcs.n	800054a <__udivmoddi4+0x2aa>
 8000472:	45a2      	cmp	sl, r4
 8000474:	d969      	bls.n	800054a <__udivmoddi4+0x2aa>
 8000476:	3802      	subs	r0, #2
 8000478:	4474      	add	r4, lr
 800047a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800047e:	fba0 8902 	umull	r8, r9, r0, r2
 8000482:	eba4 040a 	sub.w	r4, r4, sl
 8000486:	454c      	cmp	r4, r9
 8000488:	46c2      	mov	sl, r8
 800048a:	464b      	mov	r3, r9
 800048c:	d354      	bcc.n	8000538 <__udivmoddi4+0x298>
 800048e:	d051      	beq.n	8000534 <__udivmoddi4+0x294>
 8000490:	2e00      	cmp	r6, #0
 8000492:	d069      	beq.n	8000568 <__udivmoddi4+0x2c8>
 8000494:	ebb1 050a 	subs.w	r5, r1, sl
 8000498:	eb64 0403 	sbc.w	r4, r4, r3
 800049c:	fa04 fc0c 	lsl.w	ip, r4, ip
 80004a0:	40fd      	lsrs	r5, r7
 80004a2:	40fc      	lsrs	r4, r7
 80004a4:	ea4c 0505 	orr.w	r5, ip, r5
 80004a8:	e9c6 5400 	strd	r5, r4, [r6]
 80004ac:	2700      	movs	r7, #0
 80004ae:	e747      	b.n	8000340 <__udivmoddi4+0xa0>
 80004b0:	f1c2 0320 	rsb	r3, r2, #32
 80004b4:	fa20 f703 	lsr.w	r7, r0, r3
 80004b8:	4095      	lsls	r5, r2
 80004ba:	fa01 f002 	lsl.w	r0, r1, r2
 80004be:	fa21 f303 	lsr.w	r3, r1, r3
 80004c2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80004c6:	4338      	orrs	r0, r7
 80004c8:	0c01      	lsrs	r1, r0, #16
 80004ca:	fbb3 f7fe 	udiv	r7, r3, lr
 80004ce:	fa1f f885 	uxth.w	r8, r5
 80004d2:	fb0e 3317 	mls	r3, lr, r7, r3
 80004d6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80004da:	fb07 f308 	mul.w	r3, r7, r8
 80004de:	428b      	cmp	r3, r1
 80004e0:	fa04 f402 	lsl.w	r4, r4, r2
 80004e4:	d907      	bls.n	80004f6 <__udivmoddi4+0x256>
 80004e6:	1869      	adds	r1, r5, r1
 80004e8:	f107 3cff 	add.w	ip, r7, #4294967295
 80004ec:	d22f      	bcs.n	800054e <__udivmoddi4+0x2ae>
 80004ee:	428b      	cmp	r3, r1
 80004f0:	d92d      	bls.n	800054e <__udivmoddi4+0x2ae>
 80004f2:	3f02      	subs	r7, #2
 80004f4:	4429      	add	r1, r5
 80004f6:	1acb      	subs	r3, r1, r3
 80004f8:	b281      	uxth	r1, r0
 80004fa:	fbb3 f0fe 	udiv	r0, r3, lr
 80004fe:	fb0e 3310 	mls	r3, lr, r0, r3
 8000502:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000506:	fb00 f308 	mul.w	r3, r0, r8
 800050a:	428b      	cmp	r3, r1
 800050c:	d907      	bls.n	800051e <__udivmoddi4+0x27e>
 800050e:	1869      	adds	r1, r5, r1
 8000510:	f100 3cff 	add.w	ip, r0, #4294967295
 8000514:	d217      	bcs.n	8000546 <__udivmoddi4+0x2a6>
 8000516:	428b      	cmp	r3, r1
 8000518:	d915      	bls.n	8000546 <__udivmoddi4+0x2a6>
 800051a:	3802      	subs	r0, #2
 800051c:	4429      	add	r1, r5
 800051e:	1ac9      	subs	r1, r1, r3
 8000520:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8000524:	e73b      	b.n	800039e <__udivmoddi4+0xfe>
 8000526:	4637      	mov	r7, r6
 8000528:	4630      	mov	r0, r6
 800052a:	e709      	b.n	8000340 <__udivmoddi4+0xa0>
 800052c:	4607      	mov	r7, r0
 800052e:	e6e7      	b.n	8000300 <__udivmoddi4+0x60>
 8000530:	4618      	mov	r0, r3
 8000532:	e6fb      	b.n	800032c <__udivmoddi4+0x8c>
 8000534:	4541      	cmp	r1, r8
 8000536:	d2ab      	bcs.n	8000490 <__udivmoddi4+0x1f0>
 8000538:	ebb8 0a02 	subs.w	sl, r8, r2
 800053c:	eb69 020e 	sbc.w	r2, r9, lr
 8000540:	3801      	subs	r0, #1
 8000542:	4613      	mov	r3, r2
 8000544:	e7a4      	b.n	8000490 <__udivmoddi4+0x1f0>
 8000546:	4660      	mov	r0, ip
 8000548:	e7e9      	b.n	800051e <__udivmoddi4+0x27e>
 800054a:	4618      	mov	r0, r3
 800054c:	e795      	b.n	800047a <__udivmoddi4+0x1da>
 800054e:	4667      	mov	r7, ip
 8000550:	e7d1      	b.n	80004f6 <__udivmoddi4+0x256>
 8000552:	4681      	mov	r9, r0
 8000554:	e77c      	b.n	8000450 <__udivmoddi4+0x1b0>
 8000556:	3802      	subs	r0, #2
 8000558:	442c      	add	r4, r5
 800055a:	e747      	b.n	80003ec <__udivmoddi4+0x14c>
 800055c:	f1ac 0c02 	sub.w	ip, ip, #2
 8000560:	442b      	add	r3, r5
 8000562:	e72f      	b.n	80003c4 <__udivmoddi4+0x124>
 8000564:	4638      	mov	r0, r7
 8000566:	e708      	b.n	800037a <__udivmoddi4+0xda>
 8000568:	4637      	mov	r7, r6
 800056a:	e6e9      	b.n	8000340 <__udivmoddi4+0xa0>

0800056c <__aeabi_idiv0>:
 800056c:	4770      	bx	lr
 800056e:	bf00      	nop

08000570 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000570:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8000572:	4b0b      	ldr	r3, [pc, #44]	; (80005a0 <HAL_Init+0x30>)
 8000574:	681a      	ldr	r2, [r3, #0]
 8000576:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800057a:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 800057c:	681a      	ldr	r2, [r3, #0]
 800057e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000582:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000584:	681a      	ldr	r2, [r3, #0]
 8000586:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800058a:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800058c:	2003      	movs	r0, #3
 800058e:	f000 f81b 	bl	80005c8 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000592:	2000      	movs	r0, #0
 8000594:	f005 f964 	bl	8005860 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000598:	f005 f924 	bl	80057e4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 800059c:	2000      	movs	r0, #0
 800059e:	bd08      	pop	{r3, pc}
 80005a0:	40023c00 	.word	0x40023c00

080005a4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80005a4:	4a03      	ldr	r2, [pc, #12]	; (80005b4 <HAL_IncTick+0x10>)
 80005a6:	4b04      	ldr	r3, [pc, #16]	; (80005b8 <HAL_IncTick+0x14>)
 80005a8:	6811      	ldr	r1, [r2, #0]
 80005aa:	781b      	ldrb	r3, [r3, #0]
 80005ac:	440b      	add	r3, r1
 80005ae:	6013      	str	r3, [r2, #0]
}
 80005b0:	4770      	bx	lr
 80005b2:	bf00      	nop
 80005b4:	20008ad0 	.word	0x20008ad0
 80005b8:	20000000 	.word	0x20000000

080005bc <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80005bc:	4b01      	ldr	r3, [pc, #4]	; (80005c4 <HAL_GetTick+0x8>)
 80005be:	6818      	ldr	r0, [r3, #0]
}
 80005c0:	4770      	bx	lr
 80005c2:	bf00      	nop
 80005c4:	20008ad0 	.word	0x20008ad0

080005c8 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80005c8:	4a07      	ldr	r2, [pc, #28]	; (80005e8 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80005ca:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80005cc:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 80005d0:	400b      	ands	r3, r1
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80005d2:	0200      	lsls	r0, r0, #8
 80005d4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80005d8:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 80005dc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 80005e0:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 80005e2:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80005e4:	4770      	bx	lr
 80005e6:	bf00      	nop
 80005e8:	e000ed00 	.word	0xe000ed00

080005ec <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80005ec:	4b18      	ldr	r3, [pc, #96]	; (8000650 <HAL_NVIC_SetPriority+0x64>)
 80005ee:	68db      	ldr	r3, [r3, #12]
 80005f0:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80005f4:	b430      	push	{r4, r5}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80005f6:	f1c3 0507 	rsb	r5, r3, #7
 80005fa:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80005fc:	f103 0404 	add.w	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000600:	bf28      	it	cs
 8000602:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000604:	2c06      	cmp	r4, #6
 8000606:	d919      	bls.n	800063c <HAL_NVIC_SetPriority+0x50>
 8000608:	3b03      	subs	r3, #3
 800060a:	f04f 34ff 	mov.w	r4, #4294967295
 800060e:	409c      	lsls	r4, r3
 8000610:	ea22 0404 	bic.w	r4, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000614:	f04f 32ff 	mov.w	r2, #4294967295
 8000618:	40aa      	lsls	r2, r5
 800061a:	ea21 0102 	bic.w	r1, r1, r2
 800061e:	fa01 f203 	lsl.w	r2, r1, r3
 8000622:	4322      	orrs	r2, r4
 8000624:	0112      	lsls	r2, r2, #4
  if ((int32_t)(IRQn) >= 0)
 8000626:	2800      	cmp	r0, #0
 8000628:	b2d2      	uxtb	r2, r2
 800062a:	db0a      	blt.n	8000642 <HAL_NVIC_SetPriority+0x56>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800062c:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000630:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000634:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000638:	bc30      	pop	{r4, r5}
 800063a:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800063c:	2400      	movs	r4, #0
 800063e:	4623      	mov	r3, r4
 8000640:	e7e8      	b.n	8000614 <HAL_NVIC_SetPriority+0x28>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000642:	4b04      	ldr	r3, [pc, #16]	; (8000654 <HAL_NVIC_SetPriority+0x68>)
 8000644:	f000 000f 	and.w	r0, r0, #15
 8000648:	4403      	add	r3, r0
 800064a:	761a      	strb	r2, [r3, #24]
 800064c:	bc30      	pop	{r4, r5}
 800064e:	4770      	bx	lr
 8000650:	e000ed00 	.word	0xe000ed00
 8000654:	e000ecfc 	.word	0xe000ecfc

08000658 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000658:	2800      	cmp	r0, #0
 800065a:	db07      	blt.n	800066c <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800065c:	f000 011f 	and.w	r1, r0, #31
 8000660:	2301      	movs	r3, #1
 8000662:	0940      	lsrs	r0, r0, #5
 8000664:	4a02      	ldr	r2, [pc, #8]	; (8000670 <HAL_NVIC_EnableIRQ+0x18>)
 8000666:	408b      	lsls	r3, r1
 8000668:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800066c:	4770      	bx	lr
 800066e:	bf00      	nop
 8000670:	e000e100 	.word	0xe000e100

08000674 <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8000674:	2800      	cmp	r0, #0
 8000676:	f000 8132 	beq.w	80008de <HAL_RCC_OscConfig+0x26a>
{
 800067a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800067e:	6803      	ldr	r3, [r0, #0]
 8000680:	07dd      	lsls	r5, r3, #31
{
 8000682:	b082      	sub	sp, #8
 8000684:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000686:	d52f      	bpl.n	80006e8 <HAL_RCC_OscConfig+0x74>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8000688:	49ac      	ldr	r1, [pc, #688]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 800068a:	688a      	ldr	r2, [r1, #8]
 800068c:	f002 020c 	and.w	r2, r2, #12
 8000690:	2a04      	cmp	r2, #4
 8000692:	f000 80ea 	beq.w	800086a <HAL_RCC_OscConfig+0x1f6>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8000696:	688a      	ldr	r2, [r1, #8]
 8000698:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 800069c:	2a08      	cmp	r2, #8
 800069e:	f000 80e0 	beq.w	8000862 <HAL_RCC_OscConfig+0x1ee>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80006a2:	6863      	ldr	r3, [r4, #4]
 80006a4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80006a8:	f000 80e9 	beq.w	800087e <HAL_RCC_OscConfig+0x20a>
 80006ac:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80006b0:	f000 8154 	beq.w	800095c <HAL_RCC_OscConfig+0x2e8>
 80006b4:	4da1      	ldr	r5, [pc, #644]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 80006b6:	682a      	ldr	r2, [r5, #0]
 80006b8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80006bc:	602a      	str	r2, [r5, #0]
 80006be:	682a      	ldr	r2, [r5, #0]
 80006c0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80006c4:	602a      	str	r2, [r5, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 80006c6:	2b00      	cmp	r3, #0
 80006c8:	f040 80de 	bne.w	8000888 <HAL_RCC_OscConfig+0x214>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80006cc:	f7ff ff76 	bl	80005bc <HAL_GetTick>
 80006d0:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80006d2:	e005      	b.n	80006e0 <HAL_RCC_OscConfig+0x6c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80006d4:	f7ff ff72 	bl	80005bc <HAL_GetTick>
 80006d8:	1b80      	subs	r0, r0, r6
 80006da:	2864      	cmp	r0, #100	; 0x64
 80006dc:	f200 80f2 	bhi.w	80008c4 <HAL_RCC_OscConfig+0x250>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80006e0:	682b      	ldr	r3, [r5, #0]
 80006e2:	039b      	lsls	r3, r3, #14
 80006e4:	d4f6      	bmi.n	80006d4 <HAL_RCC_OscConfig+0x60>
 80006e6:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80006e8:	079f      	lsls	r7, r3, #30
 80006ea:	d475      	bmi.n	80007d8 <HAL_RCC_OscConfig+0x164>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80006ec:	071a      	lsls	r2, r3, #28
 80006ee:	d515      	bpl.n	800071c <HAL_RCC_OscConfig+0xa8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80006f0:	6963      	ldr	r3, [r4, #20]
 80006f2:	2b00      	cmp	r3, #0
 80006f4:	f000 80a5 	beq.w	8000842 <HAL_RCC_OscConfig+0x1ce>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80006f8:	4b91      	ldr	r3, [pc, #580]	; (8000940 <HAL_RCC_OscConfig+0x2cc>)

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80006fa:	4d90      	ldr	r5, [pc, #576]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
      __HAL_RCC_LSI_ENABLE();
 80006fc:	2201      	movs	r2, #1
 80006fe:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8000700:	f7ff ff5c 	bl	80005bc <HAL_GetTick>
 8000704:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000706:	e005      	b.n	8000714 <HAL_RCC_OscConfig+0xa0>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000708:	f7ff ff58 	bl	80005bc <HAL_GetTick>
 800070c:	1b80      	subs	r0, r0, r6
 800070e:	2802      	cmp	r0, #2
 8000710:	f200 80d8 	bhi.w	80008c4 <HAL_RCC_OscConfig+0x250>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000714:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8000716:	079b      	lsls	r3, r3, #30
 8000718:	d5f6      	bpl.n	8000708 <HAL_RCC_OscConfig+0x94>
 800071a:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800071c:	0758      	lsls	r0, r3, #29
 800071e:	d53b      	bpl.n	8000798 <HAL_RCC_OscConfig+0x124>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000720:	4a86      	ldr	r2, [pc, #536]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 8000722:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8000724:	f013 5380 	ands.w	r3, r3, #268435456	; 0x10000000
 8000728:	f040 80db 	bne.w	80008e2 <HAL_RCC_OscConfig+0x26e>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800072c:	9301      	str	r3, [sp, #4]
 800072e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8000730:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000734:	6413      	str	r3, [r2, #64]	; 0x40
 8000736:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8000738:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800073c:	9301      	str	r3, [sp, #4]
 800073e:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8000740:	2601      	movs	r6, #1
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000742:	4d80      	ldr	r5, [pc, #512]	; (8000944 <HAL_RCC_OscConfig+0x2d0>)
 8000744:	682a      	ldr	r2, [r5, #0]
 8000746:	05d1      	lsls	r1, r2, #23
 8000748:	f140 80ac 	bpl.w	80008a4 <HAL_RCC_OscConfig+0x230>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800074c:	68a3      	ldr	r3, [r4, #8]
 800074e:	2b01      	cmp	r3, #1
 8000750:	f000 80c9 	beq.w	80008e6 <HAL_RCC_OscConfig+0x272>
 8000754:	2b05      	cmp	r3, #5
 8000756:	f000 810b 	beq.w	8000970 <HAL_RCC_OscConfig+0x2fc>
 800075a:	4d78      	ldr	r5, [pc, #480]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 800075c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 800075e:	f022 0201 	bic.w	r2, r2, #1
 8000762:	672a      	str	r2, [r5, #112]	; 0x70
 8000764:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8000766:	f022 0204 	bic.w	r2, r2, #4
 800076a:	672a      	str	r2, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800076c:	2b00      	cmp	r3, #0
 800076e:	f040 80bf 	bne.w	80008f0 <HAL_RCC_OscConfig+0x27c>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000772:	f7ff ff23 	bl	80005bc <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000776:	f241 3788 	movw	r7, #5000	; 0x1388
      tickstart = HAL_GetTick();
 800077a:	4680      	mov	r8, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800077c:	e006      	b.n	800078c <HAL_RCC_OscConfig+0x118>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800077e:	f7ff ff1d 	bl	80005bc <HAL_GetTick>
 8000782:	eba0 0008 	sub.w	r0, r0, r8
 8000786:	42b8      	cmp	r0, r7
 8000788:	f200 809c 	bhi.w	80008c4 <HAL_RCC_OscConfig+0x250>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800078c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800078e:	0798      	lsls	r0, r3, #30
 8000790:	d4f5      	bmi.n	800077e <HAL_RCC_OscConfig+0x10a>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8000792:	2e00      	cmp	r6, #0
 8000794:	f040 80dc 	bne.w	8000950 <HAL_RCC_OscConfig+0x2dc>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000798:	69a2      	ldr	r2, [r4, #24]
 800079a:	b1ca      	cbz	r2, 80007d0 <HAL_RCC_OscConfig+0x15c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800079c:	4d67      	ldr	r5, [pc, #412]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 800079e:	68a9      	ldr	r1, [r5, #8]
 80007a0:	f001 010c 	and.w	r1, r1, #12
 80007a4:	2908      	cmp	r1, #8
 80007a6:	d048      	beq.n	800083a <HAL_RCC_OscConfig+0x1c6>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80007a8:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80007aa:	4a67      	ldr	r2, [pc, #412]	; (8000948 <HAL_RCC_OscConfig+0x2d4>)
 80007ac:	f04f 0100 	mov.w	r1, #0
 80007b0:	6011      	str	r1, [r2, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80007b2:	f000 80e7 	beq.w	8000984 <HAL_RCC_OscConfig+0x310>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80007b6:	f7ff ff01 	bl	80005bc <HAL_GetTick>

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80007ba:	462c      	mov	r4, r5
        tickstart = HAL_GetTick();
 80007bc:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80007be:	e004      	b.n	80007ca <HAL_RCC_OscConfig+0x156>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80007c0:	f7ff fefc 	bl	80005bc <HAL_GetTick>
 80007c4:	1b40      	subs	r0, r0, r5
 80007c6:	2802      	cmp	r0, #2
 80007c8:	d87c      	bhi.n	80008c4 <HAL_RCC_OscConfig+0x250>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80007ca:	6823      	ldr	r3, [r4, #0]
 80007cc:	019b      	lsls	r3, r3, #6
 80007ce:	d4f7      	bmi.n	80007c0 <HAL_RCC_OscConfig+0x14c>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80007d0:	2000      	movs	r0, #0
}
 80007d2:	b002      	add	sp, #8
 80007d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80007d8:	4a58      	ldr	r2, [pc, #352]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 80007da:	6891      	ldr	r1, [r2, #8]
 80007dc:	f011 0f0c 	tst.w	r1, #12
 80007e0:	d024      	beq.n	800082c <HAL_RCC_OscConfig+0x1b8>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80007e2:	6891      	ldr	r1, [r2, #8]
 80007e4:	f001 010c 	and.w	r1, r1, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80007e8:	2908      	cmp	r1, #8
 80007ea:	d01c      	beq.n	8000826 <HAL_RCC_OscConfig+0x1b2>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80007ec:	68e3      	ldr	r3, [r4, #12]
 80007ee:	2b00      	cmp	r3, #0
 80007f0:	f000 8092 	beq.w	8000918 <HAL_RCC_OscConfig+0x2a4>
        __HAL_RCC_HSI_ENABLE();
 80007f4:	4b55      	ldr	r3, [pc, #340]	; (800094c <HAL_RCC_OscConfig+0x2d8>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80007f6:	4d51      	ldr	r5, [pc, #324]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
        __HAL_RCC_HSI_ENABLE();
 80007f8:	2201      	movs	r2, #1
 80007fa:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80007fc:	f7ff fede 	bl	80005bc <HAL_GetTick>
 8000800:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000802:	e004      	b.n	800080e <HAL_RCC_OscConfig+0x19a>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000804:	f7ff feda 	bl	80005bc <HAL_GetTick>
 8000808:	1b80      	subs	r0, r0, r6
 800080a:	2802      	cmp	r0, #2
 800080c:	d85a      	bhi.n	80008c4 <HAL_RCC_OscConfig+0x250>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800080e:	682b      	ldr	r3, [r5, #0]
 8000810:	0798      	lsls	r0, r3, #30
 8000812:	d5f7      	bpl.n	8000804 <HAL_RCC_OscConfig+0x190>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000814:	682b      	ldr	r3, [r5, #0]
 8000816:	6922      	ldr	r2, [r4, #16]
 8000818:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800081c:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8000820:	602b      	str	r3, [r5, #0]
 8000822:	6823      	ldr	r3, [r4, #0]
 8000824:	e762      	b.n	80006ec <HAL_RCC_OscConfig+0x78>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8000826:	6852      	ldr	r2, [r2, #4]
 8000828:	0256      	lsls	r6, r2, #9
 800082a:	d4df      	bmi.n	80007ec <HAL_RCC_OscConfig+0x178>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800082c:	4a43      	ldr	r2, [pc, #268]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 800082e:	6812      	ldr	r2, [r2, #0]
 8000830:	0795      	lsls	r5, r2, #30
 8000832:	d54b      	bpl.n	80008cc <HAL_RCC_OscConfig+0x258>
 8000834:	68e2      	ldr	r2, [r4, #12]
 8000836:	2a01      	cmp	r2, #1
 8000838:	d048      	beq.n	80008cc <HAL_RCC_OscConfig+0x258>
    return HAL_ERROR;
 800083a:	2001      	movs	r0, #1
}
 800083c:	b002      	add	sp, #8
 800083e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 8000842:	4a3f      	ldr	r2, [pc, #252]	; (8000940 <HAL_RCC_OscConfig+0x2cc>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000844:	4d3d      	ldr	r5, [pc, #244]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
      __HAL_RCC_LSI_DISABLE();
 8000846:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8000848:	f7ff feb8 	bl	80005bc <HAL_GetTick>
 800084c:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800084e:	e004      	b.n	800085a <HAL_RCC_OscConfig+0x1e6>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000850:	f7ff feb4 	bl	80005bc <HAL_GetTick>
 8000854:	1b80      	subs	r0, r0, r6
 8000856:	2802      	cmp	r0, #2
 8000858:	d834      	bhi.n	80008c4 <HAL_RCC_OscConfig+0x250>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800085a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800085c:	079f      	lsls	r7, r3, #30
 800085e:	d4f7      	bmi.n	8000850 <HAL_RCC_OscConfig+0x1dc>
 8000860:	e75b      	b.n	800071a <HAL_RCC_OscConfig+0xa6>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8000862:	684a      	ldr	r2, [r1, #4]
 8000864:	0250      	lsls	r0, r2, #9
 8000866:	f57f af1c 	bpl.w	80006a2 <HAL_RCC_OscConfig+0x2e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800086a:	4a34      	ldr	r2, [pc, #208]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 800086c:	6812      	ldr	r2, [r2, #0]
 800086e:	0391      	lsls	r1, r2, #14
 8000870:	f57f af3a 	bpl.w	80006e8 <HAL_RCC_OscConfig+0x74>
 8000874:	6862      	ldr	r2, [r4, #4]
 8000876:	2a00      	cmp	r2, #0
 8000878:	f47f af36 	bne.w	80006e8 <HAL_RCC_OscConfig+0x74>
 800087c:	e7dd      	b.n	800083a <HAL_RCC_OscConfig+0x1c6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800087e:	4a2f      	ldr	r2, [pc, #188]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 8000880:	6813      	ldr	r3, [r2, #0]
 8000882:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000886:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8000888:	f7ff fe98 	bl	80005bc <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800088c:	4d2b      	ldr	r5, [pc, #172]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
        tickstart = HAL_GetTick();
 800088e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000890:	e004      	b.n	800089c <HAL_RCC_OscConfig+0x228>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000892:	f7ff fe93 	bl	80005bc <HAL_GetTick>
 8000896:	1b80      	subs	r0, r0, r6
 8000898:	2864      	cmp	r0, #100	; 0x64
 800089a:	d813      	bhi.n	80008c4 <HAL_RCC_OscConfig+0x250>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800089c:	682b      	ldr	r3, [r5, #0]
 800089e:	039a      	lsls	r2, r3, #14
 80008a0:	d5f7      	bpl.n	8000892 <HAL_RCC_OscConfig+0x21e>
 80008a2:	e720      	b.n	80006e6 <HAL_RCC_OscConfig+0x72>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80008a4:	682a      	ldr	r2, [r5, #0]
 80008a6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80008aa:	602a      	str	r2, [r5, #0]
      tickstart = HAL_GetTick();
 80008ac:	f7ff fe86 	bl	80005bc <HAL_GetTick>
 80008b0:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80008b2:	682b      	ldr	r3, [r5, #0]
 80008b4:	05da      	lsls	r2, r3, #23
 80008b6:	f53f af49 	bmi.w	800074c <HAL_RCC_OscConfig+0xd8>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80008ba:	f7ff fe7f 	bl	80005bc <HAL_GetTick>
 80008be:	1bc0      	subs	r0, r0, r7
 80008c0:	2802      	cmp	r0, #2
 80008c2:	d9f6      	bls.n	80008b2 <HAL_RCC_OscConfig+0x23e>
            return HAL_TIMEOUT;
 80008c4:	2003      	movs	r0, #3
}
 80008c6:	b002      	add	sp, #8
 80008c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80008cc:	491b      	ldr	r1, [pc, #108]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 80008ce:	6920      	ldr	r0, [r4, #16]
 80008d0:	680a      	ldr	r2, [r1, #0]
 80008d2:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80008d6:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 80008da:	600a      	str	r2, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80008dc:	e706      	b.n	80006ec <HAL_RCC_OscConfig+0x78>
    return HAL_ERROR;
 80008de:	2001      	movs	r0, #1
}
 80008e0:	4770      	bx	lr
    FlagStatus       pwrclkchanged = RESET;
 80008e2:	2600      	movs	r6, #0
 80008e4:	e72d      	b.n	8000742 <HAL_RCC_OscConfig+0xce>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80008e6:	4a15      	ldr	r2, [pc, #84]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
 80008e8:	6f13      	ldr	r3, [r2, #112]	; 0x70
 80008ea:	f043 0301 	orr.w	r3, r3, #1
 80008ee:	6713      	str	r3, [r2, #112]	; 0x70
      tickstart = HAL_GetTick();
 80008f0:	f7ff fe64 	bl	80005bc <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80008f4:	4d11      	ldr	r5, [pc, #68]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
      tickstart = HAL_GetTick();
 80008f6:	4680      	mov	r8, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80008f8:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80008fc:	e005      	b.n	800090a <HAL_RCC_OscConfig+0x296>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80008fe:	f7ff fe5d 	bl	80005bc <HAL_GetTick>
 8000902:	eba0 0008 	sub.w	r0, r0, r8
 8000906:	42b8      	cmp	r0, r7
 8000908:	d8dc      	bhi.n	80008c4 <HAL_RCC_OscConfig+0x250>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800090a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800090c:	079b      	lsls	r3, r3, #30
 800090e:	d5f6      	bpl.n	80008fe <HAL_RCC_OscConfig+0x28a>
    if(pwrclkchanged == SET)
 8000910:	2e00      	cmp	r6, #0
 8000912:	f43f af41 	beq.w	8000798 <HAL_RCC_OscConfig+0x124>
 8000916:	e01b      	b.n	8000950 <HAL_RCC_OscConfig+0x2dc>
        __HAL_RCC_HSI_DISABLE();
 8000918:	4a0c      	ldr	r2, [pc, #48]	; (800094c <HAL_RCC_OscConfig+0x2d8>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800091a:	4d08      	ldr	r5, [pc, #32]	; (800093c <HAL_RCC_OscConfig+0x2c8>)
        __HAL_RCC_HSI_DISABLE();
 800091c:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800091e:	f7ff fe4d 	bl	80005bc <HAL_GetTick>
 8000922:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000924:	e004      	b.n	8000930 <HAL_RCC_OscConfig+0x2bc>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000926:	f7ff fe49 	bl	80005bc <HAL_GetTick>
 800092a:	1b80      	subs	r0, r0, r6
 800092c:	2802      	cmp	r0, #2
 800092e:	d8c9      	bhi.n	80008c4 <HAL_RCC_OscConfig+0x250>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000930:	682b      	ldr	r3, [r5, #0]
 8000932:	0799      	lsls	r1, r3, #30
 8000934:	d4f7      	bmi.n	8000926 <HAL_RCC_OscConfig+0x2b2>
 8000936:	6823      	ldr	r3, [r4, #0]
 8000938:	e6d8      	b.n	80006ec <HAL_RCC_OscConfig+0x78>
 800093a:	bf00      	nop
 800093c:	40023800 	.word	0x40023800
 8000940:	42470e80 	.word	0x42470e80
 8000944:	40007000 	.word	0x40007000
 8000948:	42470060 	.word	0x42470060
 800094c:	42470000 	.word	0x42470000
      __HAL_RCC_PWR_CLK_DISABLE();
 8000950:	4a23      	ldr	r2, [pc, #140]	; (80009e0 <HAL_RCC_OscConfig+0x36c>)
 8000952:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8000954:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000958:	6413      	str	r3, [r2, #64]	; 0x40
 800095a:	e71d      	b.n	8000798 <HAL_RCC_OscConfig+0x124>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800095c:	4b20      	ldr	r3, [pc, #128]	; (80009e0 <HAL_RCC_OscConfig+0x36c>)
 800095e:	681a      	ldr	r2, [r3, #0]
 8000960:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8000964:	601a      	str	r2, [r3, #0]
 8000966:	681a      	ldr	r2, [r3, #0]
 8000968:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800096c:	601a      	str	r2, [r3, #0]
 800096e:	e78b      	b.n	8000888 <HAL_RCC_OscConfig+0x214>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000970:	4b1b      	ldr	r3, [pc, #108]	; (80009e0 <HAL_RCC_OscConfig+0x36c>)
 8000972:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8000974:	f042 0204 	orr.w	r2, r2, #4
 8000978:	671a      	str	r2, [r3, #112]	; 0x70
 800097a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800097c:	f042 0201 	orr.w	r2, r2, #1
 8000980:	671a      	str	r2, [r3, #112]	; 0x70
 8000982:	e7b5      	b.n	80008f0 <HAL_RCC_OscConfig+0x27c>
        tickstart = HAL_GetTick();
 8000984:	f7ff fe1a 	bl	80005bc <HAL_GetTick>
 8000988:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800098a:	e004      	b.n	8000996 <HAL_RCC_OscConfig+0x322>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800098c:	f7ff fe16 	bl	80005bc <HAL_GetTick>
 8000990:	1b80      	subs	r0, r0, r6
 8000992:	2802      	cmp	r0, #2
 8000994:	d896      	bhi.n	80008c4 <HAL_RCC_OscConfig+0x250>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8000996:	682b      	ldr	r3, [r5, #0]
 8000998:	0199      	lsls	r1, r3, #6
 800099a:	d4f7      	bmi.n	800098c <HAL_RCC_OscConfig+0x318>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800099c:	e9d4 3607 	ldrd	r3, r6, [r4, #28]
 80009a0:	e9d4 0209 	ldrd	r0, r2, [r4, #36]	; 0x24
 80009a4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80009a6:	4c0e      	ldr	r4, [pc, #56]	; (80009e0 <HAL_RCC_OscConfig+0x36c>)
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80009a8:	4333      	orrs	r3, r6
 80009aa:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 80009ae:	0852      	lsrs	r2, r2, #1
 80009b0:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 80009b4:	3a01      	subs	r2, #1
        __HAL_RCC_PLL_ENABLE();
 80009b6:	490b      	ldr	r1, [pc, #44]	; (80009e4 <HAL_RCC_OscConfig+0x370>)
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80009b8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
        __HAL_RCC_PLL_ENABLE();
 80009bc:	2201      	movs	r2, #1
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80009be:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 80009c0:	600a      	str	r2, [r1, #0]
        tickstart = HAL_GetTick();
 80009c2:	f7ff fdfb 	bl	80005bc <HAL_GetTick>
 80009c6:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80009c8:	e005      	b.n	80009d6 <HAL_RCC_OscConfig+0x362>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80009ca:	f7ff fdf7 	bl	80005bc <HAL_GetTick>
 80009ce:	1b40      	subs	r0, r0, r5
 80009d0:	2802      	cmp	r0, #2
 80009d2:	f63f af77 	bhi.w	80008c4 <HAL_RCC_OscConfig+0x250>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80009d6:	6823      	ldr	r3, [r4, #0]
 80009d8:	019a      	lsls	r2, r3, #6
 80009da:	d5f6      	bpl.n	80009ca <HAL_RCC_OscConfig+0x356>
 80009dc:	e6f8      	b.n	80007d0 <HAL_RCC_OscConfig+0x15c>
 80009de:	bf00      	nop
 80009e0:	40023800 	.word	0x40023800
 80009e4:	42470060 	.word	0x42470060

080009e8 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80009e8:	4915      	ldr	r1, [pc, #84]	; (8000a40 <HAL_RCC_GetSysClockFreq+0x58>)
{
 80009ea:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80009ec:	688b      	ldr	r3, [r1, #8]
 80009ee:	f003 030c 	and.w	r3, r3, #12
 80009f2:	2b08      	cmp	r3, #8
 80009f4:	d001      	beq.n	80009fa <HAL_RCC_GetSysClockFreq+0x12>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80009f6:	4813      	ldr	r0, [pc, #76]	; (8000a44 <HAL_RCC_GetSysClockFreq+0x5c>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80009f8:	bd08      	pop	{r3, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80009fa:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80009fc:	684b      	ldr	r3, [r1, #4]
 80009fe:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000a02:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8000a06:	d110      	bne.n	8000a2a <HAL_RCC_GetSysClockFreq+0x42>
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8000a08:	6849      	ldr	r1, [r1, #4]
 8000a0a:	480e      	ldr	r0, [pc, #56]	; (8000a44 <HAL_RCC_GetSysClockFreq+0x5c>)
 8000a0c:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8000a10:	fba1 0100 	umull	r0, r1, r1, r0
 8000a14:	f7ff fc2c 	bl	8000270 <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 8000a18:	4b09      	ldr	r3, [pc, #36]	; (8000a40 <HAL_RCC_GetSysClockFreq+0x58>)
 8000a1a:	685b      	ldr	r3, [r3, #4]
 8000a1c:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8000a20:	3301      	adds	r3, #1
 8000a22:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8000a24:	fbb0 f0f3 	udiv	r0, r0, r3
}
 8000a28:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8000a2a:	684b      	ldr	r3, [r1, #4]
 8000a2c:	4805      	ldr	r0, [pc, #20]	; (8000a44 <HAL_RCC_GetSysClockFreq+0x5c>)
 8000a2e:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8000a32:	fba3 0100 	umull	r0, r1, r3, r0
 8000a36:	2300      	movs	r3, #0
 8000a38:	f7ff fc1a 	bl	8000270 <__aeabi_uldivmod>
 8000a3c:	e7ec      	b.n	8000a18 <HAL_RCC_GetSysClockFreq+0x30>
 8000a3e:	bf00      	nop
 8000a40:	40023800 	.word	0x40023800
 8000a44:	00f42400 	.word	0x00f42400

08000a48 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8000a48:	b160      	cbz	r0, 8000a64 <HAL_RCC_ClockConfig+0x1c>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8000a4a:	4a48      	ldr	r2, [pc, #288]	; (8000b6c <HAL_RCC_ClockConfig+0x124>)
 8000a4c:	6813      	ldr	r3, [r2, #0]
 8000a4e:	f003 030f 	and.w	r3, r3, #15
 8000a52:	428b      	cmp	r3, r1
 8000a54:	d208      	bcs.n	8000a68 <HAL_RCC_ClockConfig+0x20>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000a56:	b2cb      	uxtb	r3, r1
 8000a58:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8000a5a:	6813      	ldr	r3, [r2, #0]
 8000a5c:	f003 030f 	and.w	r3, r3, #15
 8000a60:	428b      	cmp	r3, r1
 8000a62:	d001      	beq.n	8000a68 <HAL_RCC_ClockConfig+0x20>
    return HAL_ERROR;
 8000a64:	2001      	movs	r0, #1
}
 8000a66:	4770      	bx	lr
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000a68:	6803      	ldr	r3, [r0, #0]
{
 8000a6a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000a6e:	079d      	lsls	r5, r3, #30
 8000a70:	d514      	bpl.n	8000a9c <HAL_RCC_ClockConfig+0x54>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000a72:	075c      	lsls	r4, r3, #29
 8000a74:	d504      	bpl.n	8000a80 <HAL_RCC_ClockConfig+0x38>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8000a76:	4c3e      	ldr	r4, [pc, #248]	; (8000b70 <HAL_RCC_ClockConfig+0x128>)
 8000a78:	68a2      	ldr	r2, [r4, #8]
 8000a7a:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
 8000a7e:	60a2      	str	r2, [r4, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8000a80:	071a      	lsls	r2, r3, #28
 8000a82:	d504      	bpl.n	8000a8e <HAL_RCC_ClockConfig+0x46>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8000a84:	4c3a      	ldr	r4, [pc, #232]	; (8000b70 <HAL_RCC_ClockConfig+0x128>)
 8000a86:	68a2      	ldr	r2, [r4, #8]
 8000a88:	f442 4260 	orr.w	r2, r2, #57344	; 0xe000
 8000a8c:	60a2      	str	r2, [r4, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000a8e:	4c38      	ldr	r4, [pc, #224]	; (8000b70 <HAL_RCC_ClockConfig+0x128>)
 8000a90:	6885      	ldr	r5, [r0, #8]
 8000a92:	68a2      	ldr	r2, [r4, #8]
 8000a94:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000a98:	432a      	orrs	r2, r5
 8000a9a:	60a2      	str	r2, [r4, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000a9c:	07df      	lsls	r7, r3, #31
 8000a9e:	4604      	mov	r4, r0
 8000aa0:	460d      	mov	r5, r1
 8000aa2:	d522      	bpl.n	8000aea <HAL_RCC_ClockConfig+0xa2>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000aa4:	6842      	ldr	r2, [r0, #4]
 8000aa6:	2a01      	cmp	r2, #1
 8000aa8:	d056      	beq.n	8000b58 <HAL_RCC_ClockConfig+0x110>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8000aaa:	1e93      	subs	r3, r2, #2
 8000aac:	2b01      	cmp	r3, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000aae:	4b30      	ldr	r3, [pc, #192]	; (8000b70 <HAL_RCC_ClockConfig+0x128>)
 8000ab0:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8000ab2:	d958      	bls.n	8000b66 <HAL_RCC_ClockConfig+0x11e>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000ab4:	0799      	lsls	r1, r3, #30
 8000ab6:	d525      	bpl.n	8000b04 <HAL_RCC_ClockConfig+0xbc>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000ab8:	4e2d      	ldr	r6, [pc, #180]	; (8000b70 <HAL_RCC_ClockConfig+0x128>)
 8000aba:	68b3      	ldr	r3, [r6, #8]
 8000abc:	f023 0303 	bic.w	r3, r3, #3
 8000ac0:	4313      	orrs	r3, r2
 8000ac2:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8000ac4:	f7ff fd7a 	bl	80005bc <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000ac8:	f241 3788 	movw	r7, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8000acc:	4680      	mov	r8, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8000ace:	e005      	b.n	8000adc <HAL_RCC_ClockConfig+0x94>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000ad0:	f7ff fd74 	bl	80005bc <HAL_GetTick>
 8000ad4:	eba0 0008 	sub.w	r0, r0, r8
 8000ad8:	42b8      	cmp	r0, r7
 8000ada:	d842      	bhi.n	8000b62 <HAL_RCC_ClockConfig+0x11a>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8000adc:	68b3      	ldr	r3, [r6, #8]
 8000ade:	6862      	ldr	r2, [r4, #4]
 8000ae0:	f003 030c 	and.w	r3, r3, #12
 8000ae4:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8000ae8:	d1f2      	bne.n	8000ad0 <HAL_RCC_ClockConfig+0x88>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8000aea:	4a20      	ldr	r2, [pc, #128]	; (8000b6c <HAL_RCC_ClockConfig+0x124>)
 8000aec:	6813      	ldr	r3, [r2, #0]
 8000aee:	f003 030f 	and.w	r3, r3, #15
 8000af2:	42ab      	cmp	r3, r5
 8000af4:	d909      	bls.n	8000b0a <HAL_RCC_ClockConfig+0xc2>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000af6:	b2eb      	uxtb	r3, r5
 8000af8:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8000afa:	6813      	ldr	r3, [r2, #0]
 8000afc:	f003 030f 	and.w	r3, r3, #15
 8000b00:	42ab      	cmp	r3, r5
 8000b02:	d002      	beq.n	8000b0a <HAL_RCC_ClockConfig+0xc2>
    return HAL_ERROR;
 8000b04:	2001      	movs	r0, #1
}
 8000b06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000b0a:	6823      	ldr	r3, [r4, #0]
 8000b0c:	075a      	lsls	r2, r3, #29
 8000b0e:	d506      	bpl.n	8000b1e <HAL_RCC_ClockConfig+0xd6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8000b10:	4917      	ldr	r1, [pc, #92]	; (8000b70 <HAL_RCC_ClockConfig+0x128>)
 8000b12:	68e0      	ldr	r0, [r4, #12]
 8000b14:	688a      	ldr	r2, [r1, #8]
 8000b16:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 8000b1a:	4302      	orrs	r2, r0
 8000b1c:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8000b1e:	071b      	lsls	r3, r3, #28
 8000b20:	d411      	bmi.n	8000b46 <HAL_RCC_ClockConfig+0xfe>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8000b22:	f7ff ff61 	bl	80009e8 <HAL_RCC_GetSysClockFreq>
 8000b26:	4b12      	ldr	r3, [pc, #72]	; (8000b70 <HAL_RCC_ClockConfig+0x128>)
 8000b28:	4912      	ldr	r1, [pc, #72]	; (8000b74 <HAL_RCC_ClockConfig+0x12c>)
 8000b2a:	689b      	ldr	r3, [r3, #8]
 8000b2c:	4a12      	ldr	r2, [pc, #72]	; (8000b78 <HAL_RCC_ClockConfig+0x130>)
 8000b2e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8000b32:	5ccb      	ldrb	r3, [r1, r3]
 8000b34:	fa20 f303 	lsr.w	r3, r0, r3
  HAL_InitTick (TICK_INT_PRIORITY);
 8000b38:	2000      	movs	r0, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8000b3a:	6013      	str	r3, [r2, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8000b3c:	f004 fe90 	bl	8005860 <HAL_InitTick>
  return HAL_OK;
 8000b40:	2000      	movs	r0, #0
}
 8000b42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8000b46:	4a0a      	ldr	r2, [pc, #40]	; (8000b70 <HAL_RCC_ClockConfig+0x128>)
 8000b48:	6921      	ldr	r1, [r4, #16]
 8000b4a:	6893      	ldr	r3, [r2, #8]
 8000b4c:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8000b50:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8000b54:	6093      	str	r3, [r2, #8]
 8000b56:	e7e4      	b.n	8000b22 <HAL_RCC_ClockConfig+0xda>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000b58:	4b05      	ldr	r3, [pc, #20]	; (8000b70 <HAL_RCC_ClockConfig+0x128>)
 8000b5a:	681b      	ldr	r3, [r3, #0]
 8000b5c:	039e      	lsls	r6, r3, #14
 8000b5e:	d4ab      	bmi.n	8000ab8 <HAL_RCC_ClockConfig+0x70>
 8000b60:	e7d0      	b.n	8000b04 <HAL_RCC_ClockConfig+0xbc>
        return HAL_TIMEOUT;
 8000b62:	2003      	movs	r0, #3
 8000b64:	e7ed      	b.n	8000b42 <HAL_RCC_ClockConfig+0xfa>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000b66:	0198      	lsls	r0, r3, #6
 8000b68:	d4a6      	bmi.n	8000ab8 <HAL_RCC_ClockConfig+0x70>
 8000b6a:	e7cb      	b.n	8000b04 <HAL_RCC_ClockConfig+0xbc>
 8000b6c:	40023c00 	.word	0x40023c00
 8000b70:	40023800 	.word	0x40023800
 8000b74:	08007e48 	.word	0x08007e48
 8000b78:	20000008 	.word	0x20000008

08000b7c <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8000b7c:	4b04      	ldr	r3, [pc, #16]	; (8000b90 <HAL_RCC_GetPCLK2Freq+0x14>)
 8000b7e:	4a05      	ldr	r2, [pc, #20]	; (8000b94 <HAL_RCC_GetPCLK2Freq+0x18>)
 8000b80:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8000b82:	4905      	ldr	r1, [pc, #20]	; (8000b98 <HAL_RCC_GetPCLK2Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8000b84:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8000b88:	6808      	ldr	r0, [r1, #0]
 8000b8a:	5cd3      	ldrb	r3, [r2, r3]
}
 8000b8c:	40d8      	lsrs	r0, r3
 8000b8e:	4770      	bx	lr
 8000b90:	40023800 	.word	0x40023800
 8000b94:	08007e58 	.word	0x08007e58
 8000b98:	20000008 	.word	0x20000008

08000b9c <HAL_RCC_GetClockConfig>:
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000b9c:	4b0e      	ldr	r3, [pc, #56]	; (8000bd8 <HAL_RCC_GetClockConfig+0x3c>)
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8000b9e:	220f      	movs	r2, #15
 8000ba0:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000ba2:	689a      	ldr	r2, [r3, #8]
 8000ba4:	f002 0203 	and.w	r2, r2, #3
 8000ba8:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8000baa:	689a      	ldr	r2, [r3, #8]
 8000bac:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8000bb0:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 8000bb2:	689a      	ldr	r2, [r3, #8]
 8000bb4:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 8000bb8:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
 8000bba:	689b      	ldr	r3, [r3, #8]
 8000bbc:	08db      	lsrs	r3, r3, #3
{
 8000bbe:	b410      	push	{r4}
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
 8000bc0:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8000bc4:	4c05      	ldr	r4, [pc, #20]	; (8000bdc <HAL_RCC_GetClockConfig+0x40>)
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
 8000bc6:	6103      	str	r3, [r0, #16]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8000bc8:	6823      	ldr	r3, [r4, #0]
}
 8000bca:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8000bce:	f003 030f 	and.w	r3, r3, #15
 8000bd2:	600b      	str	r3, [r1, #0]
}
 8000bd4:	4770      	bx	lr
 8000bd6:	bf00      	nop
 8000bd8:	40023800 	.word	0x40023800
 8000bdc:	40023c00 	.word	0x40023c00

08000be0 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8000be0:	2800      	cmp	r0, #0
 8000be2:	d05c      	beq.n	8000c9e <HAL_TIM_Base_Init+0xbe>
{
 8000be4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8000be6:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8000bea:	4604      	mov	r4, r0
 8000bec:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8000bf0:	b3bb      	cbz	r3, 8000c62 <HAL_TIM_Base_Init+0x82>

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8000bf2:	6822      	ldr	r2, [r4, #0]
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8000bf4:	4e3a      	ldr	r6, [pc, #232]	; (8000ce0 <HAL_TIM_Base_Init+0x100>)
 8000bf6:	69a5      	ldr	r5, [r4, #24]
 8000bf8:	68e0      	ldr	r0, [r4, #12]
 8000bfa:	6861      	ldr	r1, [r4, #4]
  htim->State = HAL_TIM_STATE_BUSY;
 8000bfc:	2302      	movs	r3, #2
 8000bfe:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8000c02:	42b2      	cmp	r2, r6
  tmpcr1 = TIMx->CR1;
 8000c04:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8000c06:	d04c      	beq.n	8000ca2 <HAL_TIM_Base_Init+0xc2>
 8000c08:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8000c0c:	d058      	beq.n	8000cc0 <HAL_TIM_Base_Init+0xe0>
 8000c0e:	f5a6 467c 	sub.w	r6, r6, #64512	; 0xfc00
 8000c12:	42b2      	cmp	r2, r6
 8000c14:	d02a      	beq.n	8000c6c <HAL_TIM_Base_Init+0x8c>
 8000c16:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8000c1a:	42b2      	cmp	r2, r6
 8000c1c:	d026      	beq.n	8000c6c <HAL_TIM_Base_Init+0x8c>
 8000c1e:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8000c22:	42b2      	cmp	r2, r6
 8000c24:	d022      	beq.n	8000c6c <HAL_TIM_Base_Init+0x8c>
 8000c26:	f506 4678 	add.w	r6, r6, #63488	; 0xf800
 8000c2a:	42b2      	cmp	r2, r6
 8000c2c:	d01e      	beq.n	8000c6c <HAL_TIM_Base_Init+0x8c>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8000c2e:	f506 5670 	add.w	r6, r6, #15360	; 0x3c00
 8000c32:	42b2      	cmp	r2, r6
 8000c34:	d013      	beq.n	8000c5e <HAL_TIM_Base_Init+0x7e>
 8000c36:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8000c3a:	42b2      	cmp	r2, r6
 8000c3c:	d00f      	beq.n	8000c5e <HAL_TIM_Base_Init+0x7e>
 8000c3e:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8000c42:	42b2      	cmp	r2, r6
 8000c44:	d00b      	beq.n	8000c5e <HAL_TIM_Base_Init+0x7e>
 8000c46:	f5a6 3698 	sub.w	r6, r6, #77824	; 0x13000
 8000c4a:	42b2      	cmp	r2, r6
 8000c4c:	d007      	beq.n	8000c5e <HAL_TIM_Base_Init+0x7e>
 8000c4e:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8000c52:	42b2      	cmp	r2, r6
 8000c54:	d003      	beq.n	8000c5e <HAL_TIM_Base_Init+0x7e>
 8000c56:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8000c5a:	42b2      	cmp	r2, r6
 8000c5c:	d138      	bne.n	8000cd0 <HAL_TIM_Base_Init+0xf0>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000c5e:	6926      	ldr	r6, [r4, #16]
 8000c60:	e033      	b.n	8000cca <HAL_TIM_Base_Init+0xea>
    htim->Lock = HAL_UNLOCKED;
 8000c62:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8000c66:	f004 fddd 	bl	8005824 <HAL_TIM_Base_MspInit>
 8000c6a:	e7c2      	b.n	8000bf2 <HAL_TIM_Base_Init+0x12>
    tmpcr1 |= Structure->CounterMode;
 8000c6c:	68a6      	ldr	r6, [r4, #8]
  TIMx->ARR = (uint32_t)Structure->Period ;

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8000c6e:	4f1d      	ldr	r7, [pc, #116]	; (8000ce4 <HAL_TIM_Base_Init+0x104>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8000c70:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8000c74:	4333      	orrs	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000c76:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 8000c78:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000c7c:	4333      	orrs	r3, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8000c7e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000c82:	432b      	orrs	r3, r5
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8000c84:	42ba      	cmp	r2, r7
  TIMx->CR1 = tmpcr1;
 8000c86:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000c88:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8000c8a:	6291      	str	r1, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8000c8c:	d101      	bne.n	8000c92 <HAL_TIM_Base_Init+0xb2>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8000c8e:	6963      	ldr	r3, [r4, #20]
 8000c90:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8000c92:	2301      	movs	r3, #1
 8000c94:	6153      	str	r3, [r2, #20]
  return HAL_OK;
 8000c96:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8000c98:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 8000c9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8000c9e:	2001      	movs	r0, #1
}
 8000ca0:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 8000ca2:	68a7      	ldr	r7, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000ca4:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8000ca6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8000caa:	433b      	orrs	r3, r7
    tmpcr1 &= ~TIM_CR1_CKD;
 8000cac:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000cb0:	4333      	orrs	r3, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8000cb2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000cb6:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8000cb8:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000cba:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8000cbc:	6291      	str	r1, [r2, #40]	; 0x28
 8000cbe:	e7e6      	b.n	8000c8e <HAL_TIM_Base_Init+0xae>
    tmpcr1 |= Structure->CounterMode;
 8000cc0:	68a7      	ldr	r7, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000cc2:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8000cc4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8000cc8:	433b      	orrs	r3, r7
    tmpcr1 &= ~TIM_CR1_CKD;
 8000cca:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000cce:	4333      	orrs	r3, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8000cd0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000cd4:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8000cd6:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000cd8:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8000cda:	6291      	str	r1, [r2, #40]	; 0x28
 8000cdc:	e7d9      	b.n	8000c92 <HAL_TIM_Base_Init+0xb2>
 8000cde:	bf00      	nop
 8000ce0:	40010000 	.word	0x40010000
 8000ce4:	40010400 	.word	0x40010400

08000ce8 <HAL_TIM_Base_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8000ce8:	6803      	ldr	r3, [r0, #0]
 8000cea:	68da      	ldr	r2, [r3, #12]
 8000cec:	f042 0201 	orr.w	r2, r2, #1
 8000cf0:	60da      	str	r2, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8000cf2:	689a      	ldr	r2, [r3, #8]
 8000cf4:	f002 0207 	and.w	r2, r2, #7
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8000cf8:	2a06      	cmp	r2, #6
 8000cfa:	d003      	beq.n	8000d04 <HAL_TIM_Base_Start_IT+0x1c>
    __HAL_TIM_ENABLE(htim);
 8000cfc:	681a      	ldr	r2, [r3, #0]
 8000cfe:	f042 0201 	orr.w	r2, r2, #1
 8000d02:	601a      	str	r2, [r3, #0]
}
 8000d04:	2000      	movs	r0, #0
 8000d06:	4770      	bx	lr

08000d08 <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 8000d08:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8000d0c:	2b01      	cmp	r3, #1
 8000d0e:	d05a      	beq.n	8000dc6 <HAL_TIM_ConfigClockSource+0xbe>
  htim->State = HAL_TIM_STATE_BUSY;
 8000d10:	2202      	movs	r2, #2
  tmpsmcr = htim->Instance->SMCR;
 8000d12:	6803      	ldr	r3, [r0, #0]
{
 8000d14:	b4f0      	push	{r4, r5, r6, r7}
  htim->State = HAL_TIM_STATE_BUSY;
 8000d16:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  tmpsmcr = htim->Instance->SMCR;
 8000d1a:	689a      	ldr	r2, [r3, #8]
  switch (sClockSourceConfig->ClockSource)
 8000d1c:	680c      	ldr	r4, [r1, #0]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8000d1e:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8000d22:	f022 0277 	bic.w	r2, r2, #119	; 0x77
  __HAL_LOCK(htim);
 8000d26:	2501      	movs	r5, #1
  switch (sClockSourceConfig->ClockSource)
 8000d28:	2c40      	cmp	r4, #64	; 0x40
  __HAL_LOCK(htim);
 8000d2a:	f880 503c 	strb.w	r5, [r0, #60]	; 0x3c
  htim->Instance->SMCR = tmpsmcr;
 8000d2e:	609a      	str	r2, [r3, #8]
  switch (sClockSourceConfig->ClockSource)
 8000d30:	d074      	beq.n	8000e1c <HAL_TIM_ConfigClockSource+0x114>
 8000d32:	d94a      	bls.n	8000dca <HAL_TIM_ConfigClockSource+0xc2>
 8000d34:	2c60      	cmp	r4, #96	; 0x60
 8000d36:	d02d      	beq.n	8000d94 <HAL_TIM_ConfigClockSource+0x8c>
 8000d38:	d956      	bls.n	8000de8 <HAL_TIM_ConfigClockSource+0xe0>
 8000d3a:	2c70      	cmp	r4, #112	; 0x70
 8000d3c:	d01a      	beq.n	8000d74 <HAL_TIM_ConfigClockSource+0x6c>
 8000d3e:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
 8000d42:	d10e      	bne.n	8000d62 <HAL_TIM_ConfigClockSource+0x5a>

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8000d44:	e9d1 5201 	ldrd	r5, r2, [r1, #4]
 8000d48:	68cc      	ldr	r4, [r1, #12]
  tmpsmcr = TIMx->SMCR;
 8000d4a:	6899      	ldr	r1, [r3, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8000d4c:	432a      	orrs	r2, r5
 8000d4e:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8000d52:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8000d56:	430a      	orrs	r2, r1

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8000d58:	609a      	str	r2, [r3, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8000d5a:	689a      	ldr	r2, [r3, #8]
 8000d5c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000d60:	609a      	str	r2, [r3, #8]
  __HAL_UNLOCK(htim);
 8000d62:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8000d64:	2201      	movs	r2, #1
 8000d66:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8000d6a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
}
 8000d6e:	bcf0      	pop	{r4, r5, r6, r7}
  return HAL_OK;
 8000d70:	4618      	mov	r0, r3
}
 8000d72:	4770      	bx	lr
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8000d74:	e9d1 5201 	ldrd	r5, r2, [r1, #4]
 8000d78:	68cc      	ldr	r4, [r1, #12]
  tmpsmcr = TIMx->SMCR;
 8000d7a:	6899      	ldr	r1, [r3, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8000d7c:	432a      	orrs	r2, r5
 8000d7e:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8000d82:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8000d86:	430a      	orrs	r2, r1
  TIMx->SMCR = tmpsmcr;
 8000d88:	609a      	str	r2, [r3, #8]
      tmpsmcr = htim->Instance->SMCR;
 8000d8a:	689a      	ldr	r2, [r3, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8000d8c:	f042 0277 	orr.w	r2, r2, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
 8000d90:	609a      	str	r2, [r3, #8]
      break;
 8000d92:	e7e6      	b.n	8000d62 <HAL_TIM_ConfigClockSource+0x5a>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8000d94:	6a1c      	ldr	r4, [r3, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8000d96:	684d      	ldr	r5, [r1, #4]
 8000d98:	68ce      	ldr	r6, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8000d9a:	f024 0410 	bic.w	r4, r4, #16
 8000d9e:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8000da0:	6999      	ldr	r1, [r3, #24]
  tmpccer = TIMx->CCER;
 8000da2:	6a1a      	ldr	r2, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8000da4:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8000da8:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4U);
 8000dac:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8000db0:	ea41 3106 	orr.w	r1, r1, r6, lsl #12
  TIMx->CCMR1 = tmpccmr1 ;
 8000db4:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 8000db6:	621a      	str	r2, [r3, #32]
  tmpsmcr = TIMx->SMCR;
 8000db8:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8000dba:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8000dbe:	f042 0267 	orr.w	r2, r2, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
 8000dc2:	609a      	str	r2, [r3, #8]
 8000dc4:	e7cd      	b.n	8000d62 <HAL_TIM_ConfigClockSource+0x5a>
  __HAL_LOCK(htim);
 8000dc6:	2002      	movs	r0, #2
}
 8000dc8:	4770      	bx	lr
  switch (sClockSourceConfig->ClockSource)
 8000dca:	2c10      	cmp	r4, #16
 8000dcc:	d004      	beq.n	8000dd8 <HAL_TIM_ConfigClockSource+0xd0>
 8000dce:	d93d      	bls.n	8000e4c <HAL_TIM_ConfigClockSource+0x144>
 8000dd0:	2c20      	cmp	r4, #32
 8000dd2:	d001      	beq.n	8000dd8 <HAL_TIM_ConfigClockSource+0xd0>
 8000dd4:	2c30      	cmp	r4, #48	; 0x30
 8000dd6:	d1c4      	bne.n	8000d62 <HAL_TIM_ConfigClockSource+0x5a>
  tmpsmcr = TIMx->SMCR;
 8000dd8:	689a      	ldr	r2, [r3, #8]
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8000dda:	f044 0407 	orr.w	r4, r4, #7
  tmpsmcr &= ~TIM_SMCR_TS;
 8000dde:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8000de2:	4314      	orrs	r4, r2
  TIMx->SMCR = tmpsmcr;
 8000de4:	609c      	str	r4, [r3, #8]
 8000de6:	e7bc      	b.n	8000d62 <HAL_TIM_ConfigClockSource+0x5a>
  switch (sClockSourceConfig->ClockSource)
 8000de8:	2c50      	cmp	r4, #80	; 0x50
 8000dea:	d1ba      	bne.n	8000d62 <HAL_TIM_ConfigClockSource+0x5a>
  tmpccer = TIMx->CCER;
 8000dec:	6a1d      	ldr	r5, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8000dee:	6a1e      	ldr	r6, [r3, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8000df0:	684c      	ldr	r4, [r1, #4]
 8000df2:	68cf      	ldr	r7, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8000df4:	f026 0601 	bic.w	r6, r6, #1
 8000df8:	621e      	str	r6, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8000dfa:	699a      	ldr	r2, [r3, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8000dfc:	f025 010a 	bic.w	r1, r5, #10
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8000e00:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8000e04:	ea42 1207 	orr.w	r2, r2, r7, lsl #4
  tmpccer |= TIM_ICPolarity;
 8000e08:	4321      	orrs	r1, r4
  TIMx->CCMR1 = tmpccmr1;
 8000e0a:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8000e0c:	6219      	str	r1, [r3, #32]
  tmpsmcr = TIMx->SMCR;
 8000e0e:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8000e10:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8000e14:	f042 0257 	orr.w	r2, r2, #87	; 0x57
  TIMx->SMCR = tmpsmcr;
 8000e18:	609a      	str	r2, [r3, #8]
 8000e1a:	e7a2      	b.n	8000d62 <HAL_TIM_ConfigClockSource+0x5a>
  tmpccer = TIMx->CCER;
 8000e1c:	6a1d      	ldr	r5, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8000e1e:	6a1e      	ldr	r6, [r3, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8000e20:	684c      	ldr	r4, [r1, #4]
 8000e22:	68cf      	ldr	r7, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8000e24:	f026 0601 	bic.w	r6, r6, #1
 8000e28:	621e      	str	r6, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8000e2a:	699a      	ldr	r2, [r3, #24]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8000e2c:	f025 010a 	bic.w	r1, r5, #10
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8000e30:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8000e34:	ea42 1207 	orr.w	r2, r2, r7, lsl #4
  tmpccer |= TIM_ICPolarity;
 8000e38:	4321      	orrs	r1, r4
  TIMx->CCMR1 = tmpccmr1;
 8000e3a:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8000e3c:	6219      	str	r1, [r3, #32]
  tmpsmcr = TIMx->SMCR;
 8000e3e:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8000e40:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8000e44:	f042 0247 	orr.w	r2, r2, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
 8000e48:	609a      	str	r2, [r3, #8]
 8000e4a:	e78a      	b.n	8000d62 <HAL_TIM_ConfigClockSource+0x5a>
  switch (sClockSourceConfig->ClockSource)
 8000e4c:	2c00      	cmp	r4, #0
 8000e4e:	d0c3      	beq.n	8000dd8 <HAL_TIM_ConfigClockSource+0xd0>
 8000e50:	e787      	b.n	8000d62 <HAL_TIM_ConfigClockSource+0x5a>
 8000e52:	bf00      	nop

08000e54 <HAL_TIM_OC_DelayElapsedCallback>:
 8000e54:	4770      	bx	lr
 8000e56:	bf00      	nop

08000e58 <HAL_TIM_IC_CaptureCallback>:
 8000e58:	4770      	bx	lr
 8000e5a:	bf00      	nop

08000e5c <HAL_TIM_PWM_PulseFinishedCallback>:
 8000e5c:	4770      	bx	lr
 8000e5e:	bf00      	nop

08000e60 <HAL_TIM_TriggerCallback>:
 8000e60:	4770      	bx	lr
 8000e62:	bf00      	nop

08000e64 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8000e64:	6803      	ldr	r3, [r0, #0]
 8000e66:	691a      	ldr	r2, [r3, #16]
 8000e68:	0791      	lsls	r1, r2, #30
{
 8000e6a:	b510      	push	{r4, lr}
 8000e6c:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8000e6e:	d502      	bpl.n	8000e76 <HAL_TIM_IRQHandler+0x12>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8000e70:	68da      	ldr	r2, [r3, #12]
 8000e72:	0792      	lsls	r2, r2, #30
 8000e74:	d45f      	bmi.n	8000f36 <HAL_TIM_IRQHandler+0xd2>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8000e76:	691a      	ldr	r2, [r3, #16]
 8000e78:	0750      	lsls	r0, r2, #29
 8000e7a:	d502      	bpl.n	8000e82 <HAL_TIM_IRQHandler+0x1e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8000e7c:	68da      	ldr	r2, [r3, #12]
 8000e7e:	0751      	lsls	r1, r2, #29
 8000e80:	d446      	bmi.n	8000f10 <HAL_TIM_IRQHandler+0xac>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8000e82:	691a      	ldr	r2, [r3, #16]
 8000e84:	0712      	lsls	r2, r2, #28
 8000e86:	d502      	bpl.n	8000e8e <HAL_TIM_IRQHandler+0x2a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8000e88:	68da      	ldr	r2, [r3, #12]
 8000e8a:	0710      	lsls	r0, r2, #28
 8000e8c:	d42e      	bmi.n	8000eec <HAL_TIM_IRQHandler+0x88>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8000e8e:	691a      	ldr	r2, [r3, #16]
 8000e90:	06d2      	lsls	r2, r2, #27
 8000e92:	d502      	bpl.n	8000e9a <HAL_TIM_IRQHandler+0x36>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8000e94:	68da      	ldr	r2, [r3, #12]
 8000e96:	06d0      	lsls	r0, r2, #27
 8000e98:	d418      	bmi.n	8000ecc <HAL_TIM_IRQHandler+0x68>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8000e9a:	691a      	ldr	r2, [r3, #16]
 8000e9c:	07d1      	lsls	r1, r2, #31
 8000e9e:	d502      	bpl.n	8000ea6 <HAL_TIM_IRQHandler+0x42>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8000ea0:	68da      	ldr	r2, [r3, #12]
 8000ea2:	07d2      	lsls	r2, r2, #31
 8000ea4:	d45d      	bmi.n	8000f62 <HAL_TIM_IRQHandler+0xfe>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8000ea6:	691a      	ldr	r2, [r3, #16]
 8000ea8:	0610      	lsls	r0, r2, #24
 8000eaa:	d502      	bpl.n	8000eb2 <HAL_TIM_IRQHandler+0x4e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8000eac:	68da      	ldr	r2, [r3, #12]
 8000eae:	0611      	lsls	r1, r2, #24
 8000eb0:	d45f      	bmi.n	8000f72 <HAL_TIM_IRQHandler+0x10e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8000eb2:	691a      	ldr	r2, [r3, #16]
 8000eb4:	0652      	lsls	r2, r2, #25
 8000eb6:	d502      	bpl.n	8000ebe <HAL_TIM_IRQHandler+0x5a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8000eb8:	68da      	ldr	r2, [r3, #12]
 8000eba:	0650      	lsls	r0, r2, #25
 8000ebc:	d461      	bmi.n	8000f82 <HAL_TIM_IRQHandler+0x11e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8000ebe:	691a      	ldr	r2, [r3, #16]
 8000ec0:	0691      	lsls	r1, r2, #26
 8000ec2:	d502      	bpl.n	8000eca <HAL_TIM_IRQHandler+0x66>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8000ec4:	68da      	ldr	r2, [r3, #12]
 8000ec6:	0692      	lsls	r2, r2, #26
 8000ec8:	d443      	bmi.n	8000f52 <HAL_TIM_IRQHandler+0xee>
}
 8000eca:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8000ecc:	f06f 0210 	mvn.w	r2, #16
 8000ed0:	611a      	str	r2, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8000ed2:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8000ed4:	2208      	movs	r2, #8
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8000ed6:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8000eda:	7722      	strb	r2, [r4, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 8000edc:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8000ede:	d064      	beq.n	8000faa <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8000ee0:	f7ff ffba 	bl	8000e58 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8000ee4:	2200      	movs	r2, #0
 8000ee6:	6823      	ldr	r3, [r4, #0]
 8000ee8:	7722      	strb	r2, [r4, #28]
 8000eea:	e7d6      	b.n	8000e9a <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8000eec:	f06f 0208 	mvn.w	r2, #8
 8000ef0:	611a      	str	r2, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8000ef2:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8000ef4:	2204      	movs	r2, #4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8000ef6:	0799      	lsls	r1, r3, #30
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8000ef8:	7722      	strb	r2, [r4, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 8000efa:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8000efc:	d152      	bne.n	8000fa4 <HAL_TIM_IRQHandler+0x140>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8000efe:	f7ff ffa9 	bl	8000e54 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8000f02:	4620      	mov	r0, r4
 8000f04:	f7ff ffaa 	bl	8000e5c <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8000f08:	2200      	movs	r2, #0
 8000f0a:	6823      	ldr	r3, [r4, #0]
 8000f0c:	7722      	strb	r2, [r4, #28]
 8000f0e:	e7be      	b.n	8000e8e <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8000f10:	f06f 0204 	mvn.w	r2, #4
 8000f14:	611a      	str	r2, [r3, #16]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8000f16:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8000f18:	2202      	movs	r2, #2
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8000f1a:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8000f1e:	7722      	strb	r2, [r4, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 8000f20:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8000f22:	d13c      	bne.n	8000f9e <HAL_TIM_IRQHandler+0x13a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8000f24:	f7ff ff96 	bl	8000e54 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8000f28:	4620      	mov	r0, r4
 8000f2a:	f7ff ff97 	bl	8000e5c <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8000f2e:	2200      	movs	r2, #0
 8000f30:	6823      	ldr	r3, [r4, #0]
 8000f32:	7722      	strb	r2, [r4, #28]
 8000f34:	e7a5      	b.n	8000e82 <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8000f36:	f06f 0202 	mvn.w	r2, #2
 8000f3a:	611a      	str	r2, [r3, #16]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8000f3c:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8000f3e:	2201      	movs	r2, #1
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8000f40:	079b      	lsls	r3, r3, #30
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8000f42:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8000f44:	d025      	beq.n	8000f92 <HAL_TIM_IRQHandler+0x12e>
          HAL_TIM_IC_CaptureCallback(htim);
 8000f46:	f7ff ff87 	bl	8000e58 <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8000f4a:	2200      	movs	r2, #0
 8000f4c:	6823      	ldr	r3, [r4, #0]
 8000f4e:	7722      	strb	r2, [r4, #28]
 8000f50:	e791      	b.n	8000e76 <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8000f52:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 8000f56:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8000f58:	611a      	str	r2, [r3, #16]
}
 8000f5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 8000f5e:	f000 b84d 	b.w	8000ffc <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8000f62:	f06f 0201 	mvn.w	r2, #1
 8000f66:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8000f68:	4620      	mov	r0, r4
 8000f6a:	f004 fc31 	bl	80057d0 <HAL_TIM_PeriodElapsedCallback>
 8000f6e:	6823      	ldr	r3, [r4, #0]
 8000f70:	e799      	b.n	8000ea6 <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8000f72:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8000f76:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8000f78:	4620      	mov	r0, r4
 8000f7a:	f000 f841 	bl	8001000 <HAL_TIMEx_BreakCallback>
 8000f7e:	6823      	ldr	r3, [r4, #0]
 8000f80:	e797      	b.n	8000eb2 <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8000f82:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8000f86:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8000f88:	4620      	mov	r0, r4
 8000f8a:	f7ff ff69 	bl	8000e60 <HAL_TIM_TriggerCallback>
 8000f8e:	6823      	ldr	r3, [r4, #0]
 8000f90:	e795      	b.n	8000ebe <HAL_TIM_IRQHandler+0x5a>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8000f92:	f7ff ff5f 	bl	8000e54 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8000f96:	4620      	mov	r0, r4
 8000f98:	f7ff ff60 	bl	8000e5c <HAL_TIM_PWM_PulseFinishedCallback>
 8000f9c:	e7d5      	b.n	8000f4a <HAL_TIM_IRQHandler+0xe6>
        HAL_TIM_IC_CaptureCallback(htim);
 8000f9e:	f7ff ff5b 	bl	8000e58 <HAL_TIM_IC_CaptureCallback>
 8000fa2:	e7c4      	b.n	8000f2e <HAL_TIM_IRQHandler+0xca>
        HAL_TIM_IC_CaptureCallback(htim);
 8000fa4:	f7ff ff58 	bl	8000e58 <HAL_TIM_IC_CaptureCallback>
 8000fa8:	e7ae      	b.n	8000f08 <HAL_TIM_IRQHandler+0xa4>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8000faa:	f7ff ff53 	bl	8000e54 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8000fae:	4620      	mov	r0, r4
 8000fb0:	f7ff ff54 	bl	8000e5c <HAL_TIM_PWM_PulseFinishedCallback>
 8000fb4:	e796      	b.n	8000ee4 <HAL_TIM_IRQHandler+0x80>
 8000fb6:	bf00      	nop

08000fb8 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8000fb8:	f890 203c 	ldrb.w	r2, [r0, #60]	; 0x3c
 8000fbc:	2a01      	cmp	r2, #1
 8000fbe:	d01a      	beq.n	8000ff6 <HAL_TIMEx_MasterConfigSynchronization+0x3e>
{
 8000fc0:	b470      	push	{r4, r5, r6}

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8000fc2:	2202      	movs	r2, #2

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8000fc4:	6804      	ldr	r4, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8000fc6:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8000fca:	e9d1 6500 	ldrd	r6, r5, [r1]
 8000fce:	4603      	mov	r3, r0
  tmpcr2 = htim->Instance->CR2;
 8000fd0:	6860      	ldr	r0, [r4, #4]
  tmpsmcr = htim->Instance->SMCR;
 8000fd2:	68a2      	ldr	r2, [r4, #8]
  tmpcr2 &= ~TIM_CR2_MMS;
 8000fd4:	f020 0170 	bic.w	r1, r0, #112	; 0x70
  tmpsmcr &= ~TIM_SMCR_MSM;
 8000fd8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8000fdc:	4331      	orrs	r1, r6
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8000fde:	432a      	orrs	r2, r5

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8000fe0:	2601      	movs	r6, #1

  __HAL_UNLOCK(htim);
 8000fe2:	2500      	movs	r5, #0
  htim->Instance->CR2 = tmpcr2;
 8000fe4:	6061      	str	r1, [r4, #4]

  return HAL_OK;
 8000fe6:	4628      	mov	r0, r5
  htim->Instance->SMCR = tmpsmcr;
 8000fe8:	60a2      	str	r2, [r4, #8]
  htim->State = HAL_TIM_STATE_READY;
 8000fea:	f883 603d 	strb.w	r6, [r3, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8000fee:	f883 503c 	strb.w	r5, [r3, #60]	; 0x3c
}
 8000ff2:	bc70      	pop	{r4, r5, r6}
 8000ff4:	4770      	bx	lr
  __HAL_LOCK(htim);
 8000ff6:	2002      	movs	r0, #2
}
 8000ff8:	4770      	bx	lr
 8000ffa:	bf00      	nop

08000ffc <HAL_TIMEx_CommutCallback>:
 8000ffc:	4770      	bx	lr
 8000ffe:	bf00      	nop

08001000 <HAL_TIMEx_BreakCallback>:
 8001000:	4770      	bx	lr
 8001002:	bf00      	nop

08001004 <setup>:
 */

#include "displayDriver.h"

void setup(void)
{
 8001004:	b508      	push	{r3, lr}
    displayInit();
 8001006:	f005 fbf3 	bl	80067f0 <displayInit>
    displaySetBrightness(5);
 800100a:	2005      	movs	r0, #5
}
 800100c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    displaySetBrightness(5);
 8001010:	f005 bbe8 	b.w	80067e4 <displaySetBrightness>

08001014 <loop>:
unsigned char i=0;

void loop(void)
{ 
 8001014:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001018:	b086      	sub	sp, #24

    if(mountSD())
 800101a:	f006 f825 	bl	8007068 <mountSD>
 800101e:	2800      	cmp	r0, #0
 8001020:	f000 8103 	beq.w	800122a <loop+0x216>
    {
        displayClear();
        displayFill(COLOR(WHITE));
 8001024:	4d89      	ldr	r5, [pc, #548]	; (800124c <loop+0x238>)
        displayGoTo(16,0);
        for(i=0;i<5;i++)
 8001026:	4c8a      	ldr	r4, [pc, #552]	; (8001250 <loop+0x23c>)
        displayPlayImagesSD("anim/think", 1, TRUE);   
 8001028:	4e8a      	ldr	r6, [pc, #552]	; (8001254 <loop+0x240>)
        displayClear();
 800102a:	f005 fe59 	bl	8006ce0 <displayClear>
        displayFill(COLOR(WHITE));
 800102e:	682b      	ldr	r3, [r5, #0]
 8001030:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001034:	0c1b      	lsrs	r3, r3, #16
 8001036:	f88d 3006 	strb.w	r3, [sp, #6]
 800103a:	9801      	ldr	r0, [sp, #4]
 800103c:	f005 fe3a 	bl	8006cb4 <displayFill>
        displayGoTo(16,0);
 8001040:	2100      	movs	r1, #0
 8001042:	2010      	movs	r0, #16
 8001044:	f005 fefe 	bl	8006e44 <displayGoTo>
        for(i=0;i<5;i++)
 8001048:	2300      	movs	r3, #0
 800104a:	7023      	strb	r3, [r4, #0]
        displayPlayImagesSD("anim/think", 1, TRUE);   
 800104c:	2201      	movs	r2, #1
 800104e:	4611      	mov	r1, r2
 8001050:	4630      	mov	r0, r6
 8001052:	f006 f98f 	bl	8007374 <displayPlayImagesSD>
        for(i=0;i<5;i++)
 8001056:	7823      	ldrb	r3, [r4, #0]
 8001058:	3301      	adds	r3, #1
 800105a:	b2db      	uxtb	r3, r3
 800105c:	2b04      	cmp	r3, #4
 800105e:	7023      	strb	r3, [r4, #0]
 8001060:	d9f4      	bls.n	800104c <loop+0x38>
        displayDelay(1000);
 8001062:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001066:	f006 f9b9 	bl	80073dc <displayDelay>
        
        displayClear();
 800106a:	f005 fe39 	bl	8006ce0 <displayClear>
        displayGoTo(24,8);
 800106e:	2108      	movs	r1, #8
 8001070:	2018      	movs	r0, #24
 8001072:	f005 fee7 	bl	8006e44 <displayGoTo>
        displayPlayImagesSD("anim/KEL", 1, TRUE);   
 8001076:	2201      	movs	r2, #1
 8001078:	4611      	mov	r1, r2
 800107a:	4877      	ldr	r0, [pc, #476]	; (8001258 <loop+0x244>)

        
        displayClear();
        displayGoTo(0,0);
        for(i=0;i<2;i++)
        displayPlayImagesSD("anim/jannis", 1, TRUE);
 800107c:	4e77      	ldr	r6, [pc, #476]	; (800125c <loop+0x248>)
        displayPlayImagesSD("anim/KEL", 1, TRUE);   
 800107e:	f006 f979 	bl	8007374 <displayPlayImagesSD>
        displayScroll(LEFT,24,2);
 8001082:	2202      	movs	r2, #2
 8001084:	2118      	movs	r1, #24
 8001086:	2008      	movs	r0, #8
 8001088:	f005 fe38 	bl	8006cfc <displayScroll>
        displayGoTo(48,8);
 800108c:	2108      	movs	r1, #8
 800108e:	2030      	movs	r0, #48	; 0x30
 8001090:	f005 fed8 	bl	8006e44 <displayGoTo>
        displayPlayImagesSD("anim/DEET", 1, TRUE);  
 8001094:	2201      	movs	r2, #1
 8001096:	4611      	mov	r1, r2
 8001098:	4871      	ldr	r0, [pc, #452]	; (8001260 <loop+0x24c>)
 800109a:	f006 f96b 	bl	8007374 <displayPlayImagesSD>
        displayScroll(UP,8,2);
 800109e:	2202      	movs	r2, #2
 80010a0:	4610      	mov	r0, r2
 80010a2:	2108      	movs	r1, #8
 80010a4:	f005 fe2a 	bl	8006cfc <displayScroll>
        displayGoTo(5,47);
 80010a8:	212f      	movs	r1, #47	; 0x2f
 80010aa:	2005      	movs	r0, #5
 80010ac:	f005 feca 	bl	8006e44 <displayGoTo>
        displayPrint("Mikroracunarska", COLOR(YELLOW));
 80010b0:	686f      	ldr	r7, [r5, #4]
 80010b2:	f8ad 7008 	strh.w	r7, [sp, #8]
 80010b6:	ea4f 4817 	mov.w	r8, r7, lsr #16
 80010ba:	f88d 800a 	strb.w	r8, [sp, #10]
 80010be:	9902      	ldr	r1, [sp, #8]
 80010c0:	4868      	ldr	r0, [pc, #416]	; (8001264 <loop+0x250>)
 80010c2:	f005 ffc1 	bl	8007048 <displayPrint>
        displayGoTo(17,55);
 80010c6:	2137      	movs	r1, #55	; 0x37
 80010c8:	2011      	movs	r0, #17
 80010ca:	f005 febb 	bl	8006e44 <displayGoTo>
        displayPrint("elektronika", COLOR(YELLOW));
 80010ce:	f88d 800e 	strb.w	r8, [sp, #14]
 80010d2:	f8ad 700c 	strh.w	r7, [sp, #12]
 80010d6:	9903      	ldr	r1, [sp, #12]
 80010d8:	4863      	ldr	r0, [pc, #396]	; (8001268 <loop+0x254>)
 80010da:	f005 ffb5 	bl	8007048 <displayPrint>
        displayDelay(2000);
 80010de:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80010e2:	f006 f97b 	bl	80073dc <displayDelay>
        displayClear();
 80010e6:	f005 fdfb 	bl	8006ce0 <displayClear>
        displayGoTo(0,0);
 80010ea:	2100      	movs	r1, #0
 80010ec:	4608      	mov	r0, r1
 80010ee:	f005 fea9 	bl	8006e44 <displayGoTo>
        displayPlayImagesSD("anim/OELAB", 1, TRUE);
 80010f2:	2201      	movs	r2, #1
 80010f4:	4611      	mov	r1, r2
 80010f6:	485d      	ldr	r0, [pc, #372]	; (800126c <loop+0x258>)
 80010f8:	f006 f93c 	bl	8007374 <displayPlayImagesSD>
        displayDelay(2000);
 80010fc:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8001100:	f006 f96c 	bl	80073dc <displayDelay>
        displayClear();
 8001104:	f005 fdec 	bl	8006ce0 <displayClear>
        displayGoTo(0,0);
 8001108:	2100      	movs	r1, #0
 800110a:	4608      	mov	r0, r1
 800110c:	f005 fe9a 	bl	8006e44 <displayGoTo>
        for(i=0;i<2;i++)
 8001110:	2300      	movs	r3, #0
 8001112:	7023      	strb	r3, [r4, #0]
        displayPlayImagesSD("anim/jannis", 1, TRUE);
 8001114:	2201      	movs	r2, #1
 8001116:	4611      	mov	r1, r2
 8001118:	4630      	mov	r0, r6
 800111a:	f006 f92b 	bl	8007374 <displayPlayImagesSD>
        for(i=0;i<2;i++)
 800111e:	7823      	ldrb	r3, [r4, #0]
 8001120:	3301      	adds	r3, #1
 8001122:	b2db      	uxtb	r3, r3
 8001124:	2b01      	cmp	r3, #1
 8001126:	7023      	strb	r3, [r4, #0]
 8001128:	d9f4      	bls.n	8001114 <loop+0x100>

        
        displayClear();
 800112a:	f005 fdd9 	bl	8006ce0 <displayClear>
        displayGoTo(16,0);
 800112e:	2100      	movs	r1, #0
 8001130:	2010      	movs	r0, #16
 8001132:	f005 fe87 	bl	8006e44 <displayGoTo>
        for(i=0;i<3;i++)
        displayPlayImagesSD("anim/bisqwit", 1, TRUE);
 8001136:	4e4e      	ldr	r6, [pc, #312]	; (8001270 <loop+0x25c>)
        for(i=0;i<3;i++)
 8001138:	2300      	movs	r3, #0
 800113a:	7023      	strb	r3, [r4, #0]
        displayPlayImagesSD("anim/bisqwit", 1, TRUE);
 800113c:	2201      	movs	r2, #1
 800113e:	4611      	mov	r1, r2
 8001140:	4630      	mov	r0, r6
 8001142:	f006 f917 	bl	8007374 <displayPlayImagesSD>
        for(i=0;i<3;i++)
 8001146:	7823      	ldrb	r3, [r4, #0]
 8001148:	3301      	adds	r3, #1
 800114a:	b2db      	uxtb	r3, r3
 800114c:	2b02      	cmp	r3, #2
 800114e:	7023      	strb	r3, [r4, #0]
 8001150:	d9f4      	bls.n	800113c <loop+0x128>
        
        displayClear();
 8001152:	f005 fdc5 	bl	8006ce0 <displayClear>
        displayGoTo(16,0);
 8001156:	2100      	movs	r1, #0
 8001158:	2010      	movs	r0, #16
 800115a:	f005 fe73 	bl	8006e44 <displayGoTo>
        for(i=0;i<3;i++)
        displayPlayImagesSD("anim/squirrel", 1, TRUE);
 800115e:	4e45      	ldr	r6, [pc, #276]	; (8001274 <loop+0x260>)
        for(i=0;i<3;i++)
 8001160:	2300      	movs	r3, #0
 8001162:	7023      	strb	r3, [r4, #0]
        displayPlayImagesSD("anim/squirrel", 1, TRUE);
 8001164:	2201      	movs	r2, #1
 8001166:	4611      	mov	r1, r2
 8001168:	4630      	mov	r0, r6
 800116a:	f006 f903 	bl	8007374 <displayPlayImagesSD>
        for(i=0;i<3;i++)
 800116e:	7823      	ldrb	r3, [r4, #0]
 8001170:	3301      	adds	r3, #1
 8001172:	b2db      	uxtb	r3, r3
 8001174:	2b02      	cmp	r3, #2
 8001176:	7023      	strb	r3, [r4, #0]
 8001178:	d9f4      	bls.n	8001164 <loop+0x150>

        
        displayClear();
 800117a:	f005 fdb1 	bl	8006ce0 <displayClear>
        displayGoTo(0,0);
 800117e:	2100      	movs	r1, #0
 8001180:	4608      	mov	r0, r1
 8001182:	f005 fe5f 	bl	8006e44 <displayGoTo>
        displayPlayImagesSD("images/ARGB8888", 1000, TRUE);
 8001186:	2201      	movs	r2, #1
 8001188:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800118c:	483a      	ldr	r0, [pc, #232]	; (8001278 <loop+0x264>)
     

        displayFill(COLOR(WHITE));
        displayGoTo(22,0);
        for(i=0;i<5;i++)
        displayPlayImagesSD("anim/mamba", 10, TRUE);
 800118e:	4e3b      	ldr	r6, [pc, #236]	; (800127c <loop+0x268>)
        displayPlayImagesSD("images/ARGB8888", 1000, TRUE);
 8001190:	f006 f8f0 	bl	8007374 <displayPlayImagesSD>
        displayClear();
 8001194:	f005 fda4 	bl	8006ce0 <displayClear>
        displayGoTo(0,0);
 8001198:	2100      	movs	r1, #0
 800119a:	4608      	mov	r0, r1
 800119c:	f005 fe52 	bl	8006e44 <displayGoTo>
        displayPlayImagesSD("images/RGB888", 1000, TRUE);
 80011a0:	2201      	movs	r2, #1
 80011a2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80011a6:	4836      	ldr	r0, [pc, #216]	; (8001280 <loop+0x26c>)
 80011a8:	f006 f8e4 	bl	8007374 <displayPlayImagesSD>
        displayClear();
 80011ac:	f005 fd98 	bl	8006ce0 <displayClear>
        displayGoTo(0,0);
 80011b0:	2100      	movs	r1, #0
 80011b2:	4608      	mov	r0, r1
 80011b4:	f005 fe46 	bl	8006e44 <displayGoTo>
        displayPlayImagesSD("images/RGB565", 1000, TRUE);
 80011b8:	2201      	movs	r2, #1
 80011ba:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80011be:	4831      	ldr	r0, [pc, #196]	; (8001284 <loop+0x270>)
 80011c0:	f006 f8d8 	bl	8007374 <displayPlayImagesSD>
        displayFill(COLOR(WHITE));
 80011c4:	682b      	ldr	r3, [r5, #0]
 80011c6:	f8ad 3010 	strh.w	r3, [sp, #16]
 80011ca:	0c1b      	lsrs	r3, r3, #16
 80011cc:	f88d 3012 	strb.w	r3, [sp, #18]
 80011d0:	9804      	ldr	r0, [sp, #16]
 80011d2:	f005 fd6f 	bl	8006cb4 <displayFill>
        displayGoTo(22,0);
 80011d6:	2100      	movs	r1, #0
 80011d8:	2016      	movs	r0, #22
 80011da:	f005 fe33 	bl	8006e44 <displayGoTo>
        for(i=0;i<5;i++)
 80011de:	2300      	movs	r3, #0
 80011e0:	7023      	strb	r3, [r4, #0]
        displayPlayImagesSD("anim/mamba", 10, TRUE);
 80011e2:	2201      	movs	r2, #1
 80011e4:	210a      	movs	r1, #10
 80011e6:	4630      	mov	r0, r6
 80011e8:	f006 f8c4 	bl	8007374 <displayPlayImagesSD>
        for(i=0;i<5;i++)
 80011ec:	7823      	ldrb	r3, [r4, #0]
 80011ee:	3301      	adds	r3, #1
 80011f0:	b2db      	uxtb	r3, r3
 80011f2:	2b04      	cmp	r3, #4
 80011f4:	7023      	strb	r3, [r4, #0]
 80011f6:	d9f4      	bls.n	80011e2 <loop+0x1ce>
       
        displayGoTo(0,0);
 80011f8:	2100      	movs	r1, #0
 80011fa:	4608      	mov	r0, r1
 80011fc:	f005 fe22 	bl	8006e44 <displayGoTo>
        displayPlayImagesSD("anim/printer", 0, TRUE);
 8001200:	2201      	movs	r2, #1
 8001202:	2100      	movs	r1, #0
 8001204:	4820      	ldr	r0, [pc, #128]	; (8001288 <loop+0x274>)
 8001206:	f006 f8b5 	bl	8007374 <displayPlayImagesSD>
        
        displayClear();
 800120a:	f005 fd69 	bl	8006ce0 <displayClear>
        displayGoTo(0,0);
 800120e:	2100      	movs	r1, #0
 8001210:	4608      	mov	r0, r1
 8001212:	f005 fe17 	bl	8006e44 <displayGoTo>
        displayPlayImagesSD("anim/LF", 0, TRUE);
 8001216:	2201      	movs	r2, #1
 8001218:	2100      	movs	r1, #0
 800121a:	481c      	ldr	r0, [pc, #112]	; (800128c <loop+0x278>)
 800121c:	f006 f8aa 	bl	8007374 <displayPlayImagesSD>
    {
        displayGoTo(0,24);
        displayPrint("Error reading", COLOR(WHITE));
    }
  
}
 8001220:	b006      	add	sp, #24
 8001222:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        unmountSD();
 8001226:	f005 bf2d 	b.w	8007084 <unmountSD>
        displayGoTo(0,24);
 800122a:	2118      	movs	r1, #24
 800122c:	f005 fe0a 	bl	8006e44 <displayGoTo>
        displayPrint("Error reading", COLOR(WHITE));
 8001230:	4b06      	ldr	r3, [pc, #24]	; (800124c <loop+0x238>)
 8001232:	4817      	ldr	r0, [pc, #92]	; (8001290 <loop+0x27c>)
 8001234:	681b      	ldr	r3, [r3, #0]
 8001236:	f8ad 3014 	strh.w	r3, [sp, #20]
 800123a:	0c1b      	lsrs	r3, r3, #16
 800123c:	f88d 3016 	strb.w	r3, [sp, #22]
 8001240:	9905      	ldr	r1, [sp, #20]
}
 8001242:	b006      	add	sp, #24
 8001244:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        displayPrint("Error reading", COLOR(WHITE));
 8001248:	f005 befe 	b.w	8007048 <displayPrint>
 800124c:	08007c7c 	.word	0x08007c7c
 8001250:	200000a8 	.word	0x200000a8
 8001254:	08007cbc 	.word	0x08007cbc
 8001258:	08007cc8 	.word	0x08007cc8
 800125c:	08007d08 	.word	0x08007d08
 8001260:	08007cd4 	.word	0x08007cd4
 8001264:	08007ce0 	.word	0x08007ce0
 8001268:	08007cf0 	.word	0x08007cf0
 800126c:	08007cfc 	.word	0x08007cfc
 8001270:	08007d14 	.word	0x08007d14
 8001274:	08007d24 	.word	0x08007d24
 8001278:	08007d34 	.word	0x08007d34
 800127c:	08007d64 	.word	0x08007d64
 8001280:	08007d44 	.word	0x08007d44
 8001284:	08007d54 	.word	0x08007d54
 8001288:	08007d70 	.word	0x08007d70
 800128c:	08007d80 	.word	0x08007d80
 8001290:	08007d88 	.word	0x08007d88

08001294 <disk_status>:
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 8001294:	4b03      	ldr	r3, [pc, #12]	; (80012a4 <disk_status+0x10>)
 8001296:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800129a:	4403      	add	r3, r0
 800129c:	6852      	ldr	r2, [r2, #4]
 800129e:	7a18      	ldrb	r0, [r3, #8]
 80012a0:	6853      	ldr	r3, [r2, #4]
 80012a2:	4718      	bx	r3
 80012a4:	200000d4 	.word	0x200000d4

080012a8 <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;

  if(disk.is_initialized[pdrv] == 0)
 80012a8:	4b06      	ldr	r3, [pc, #24]	; (80012c4 <disk_initialize+0x1c>)
 80012aa:	5c1a      	ldrb	r2, [r3, r0]
 80012ac:	b942      	cbnz	r2, 80012c0 <disk_initialize+0x18>
  {
    disk.is_initialized[pdrv] = 1;
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 80012ae:	eb03 0280 	add.w	r2, r3, r0, lsl #2
    disk.is_initialized[pdrv] = 1;
 80012b2:	2101      	movs	r1, #1
 80012b4:	5419      	strb	r1, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 80012b6:	6852      	ldr	r2, [r2, #4]
 80012b8:	4403      	add	r3, r0
 80012ba:	6812      	ldr	r2, [r2, #0]
 80012bc:	7a18      	ldrb	r0, [r3, #8]
 80012be:	4710      	bx	r2
  }
  return stat;
}
 80012c0:	2000      	movs	r0, #0
 80012c2:	4770      	bx	lr
 80012c4:	200000d4 	.word	0x200000d4

080012c8 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 80012c8:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 80012ca:	4c05      	ldr	r4, [pc, #20]	; (80012e0 <disk_read+0x18>)
 80012cc:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 80012d0:	4404      	add	r4, r0
 80012d2:	686d      	ldr	r5, [r5, #4]
 80012d4:	7a20      	ldrb	r0, [r4, #8]
 80012d6:	68ac      	ldr	r4, [r5, #8]
 80012d8:	46a4      	mov	ip, r4
  return res;
}
 80012da:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 80012dc:	4760      	bx	ip
 80012de:	bf00      	nop
 80012e0:	200000d4 	.word	0x200000d4

080012e4 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 80012e4:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 80012e6:	4c05      	ldr	r4, [pc, #20]	; (80012fc <disk_write+0x18>)
 80012e8:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 80012ec:	4404      	add	r4, r0
 80012ee:	686d      	ldr	r5, [r5, #4]
 80012f0:	7a20      	ldrb	r0, [r4, #8]
 80012f2:	68ec      	ldr	r4, [r5, #12]
 80012f4:	46a4      	mov	ip, r4
  return res;
}
 80012f6:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 80012f8:	4760      	bx	ip
 80012fa:	bf00      	nop
 80012fc:	200000d4 	.word	0x200000d4

08001300 <disk_ioctl>:
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8001300:	4b05      	ldr	r3, [pc, #20]	; (8001318 <disk_ioctl+0x18>)
{
 8001302:	b410      	push	{r4}
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8001304:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 8001308:	4403      	add	r3, r0
 800130a:	6864      	ldr	r4, [r4, #4]
 800130c:	7a18      	ldrb	r0, [r3, #8]
 800130e:	6923      	ldr	r3, [r4, #16]
  return res;
}
 8001310:	f85d 4b04 	ldr.w	r4, [sp], #4
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8001314:	4718      	bx	r3
 8001316:	bf00      	nop
 8001318:	200000d4 	.word	0x200000d4

0800131c <move_window.part.7>:
}
#endif


static
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
 800131c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001320:	78c3      	ldrb	r3, [r0, #3]
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8001322:	4604      	mov	r4, r0
 8001324:	460e      	mov	r6, r1
 8001326:	f100 0730 	add.w	r7, r0, #48	; 0x30
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800132a:	b973      	cbnz	r3, 800134a <move_window.part.7+0x2e>
	if (sector != fs->winsect) {	/* Window offset changed? */
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800132c:	4632      	mov	r2, r6
 800132e:	4639      	mov	r1, r7
 8001330:	2301      	movs	r3, #1
 8001332:	7860      	ldrb	r0, [r4, #1]
 8001334:	f7ff ffc8 	bl	80012c8 <disk_read>
 8001338:	2800      	cmp	r0, #0
 800133a:	bf18      	it	ne
 800133c:	f04f 36ff 	movne.w	r6, #4294967295
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
 8001340:	62e6      	str	r6, [r4, #44]	; 0x2c
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001342:	bf14      	ite	ne
 8001344:	2001      	movne	r0, #1
 8001346:	2000      	moveq	r0, #0
 8001348:	e01f      	b.n	800138a <move_window.part.7+0x6e>
		wsect = fs->winsect;	/* Current sector number */
 800134a:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800134c:	7840      	ldrb	r0, [r0, #1]
 800134e:	462a      	mov	r2, r5
 8001350:	2301      	movs	r3, #1
 8001352:	4639      	mov	r1, r7
 8001354:	f7ff ffc6 	bl	80012e4 <disk_write>
 8001358:	b9b0      	cbnz	r0, 8001388 <move_window.part.7+0x6c>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800135a:	6a23      	ldr	r3, [r4, #32]
 800135c:	69a2      	ldr	r2, [r4, #24]
			fs->wflag = 0;
 800135e:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001360:	1aeb      	subs	r3, r5, r3
 8001362:	4293      	cmp	r3, r2
 8001364:	d2e2      	bcs.n	800132c <move_window.part.7+0x10>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001366:	f894 8002 	ldrb.w	r8, [r4, #2]
 800136a:	7860      	ldrb	r0, [r4, #1]
 800136c:	f1b8 0f01 	cmp.w	r8, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 8001370:	f04f 0301 	mov.w	r3, #1
 8001374:	4639      	mov	r1, r7
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001376:	d9d9      	bls.n	800132c <move_window.part.7+0x10>
					wsect += fs->fsize;
 8001378:	69a2      	ldr	r2, [r4, #24]
 800137a:	4415      	add	r5, r2
					disk_write(fs->drv, fs->win, wsect, 1);
 800137c:	462a      	mov	r2, r5
 800137e:	f7ff ffb1 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001382:	f108 38ff 	add.w	r8, r8, #4294967295
 8001386:	e7f0      	b.n	800136a <move_window.part.7+0x4e>
			res = FR_DISK_ERR;
 8001388:	2001      	movs	r0, #1
		}
	}
	return res;
}
 800138a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08001390 <sync_fs>:

static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
 8001390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001392:	78c3      	ldrb	r3, [r0, #3]
{
 8001394:	4604      	mov	r4, r0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001396:	b95b      	cbnz	r3, 80013b0 <sync_fs+0x20>


	res = sync_window(fs);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 8001398:	7823      	ldrb	r3, [r4, #0]
 800139a:	2b03      	cmp	r3, #3
 800139c:	d029      	beq.n	80013f2 <sync_fs+0x62>
			fs->winsect = fs->volbase + 1;
			disk_write(fs->drv, fs->win, fs->winsect, 1);
			fs->fsi_flag = 0;
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 800139e:	2200      	movs	r2, #0
 80013a0:	7860      	ldrb	r0, [r4, #1]
 80013a2:	4611      	mov	r1, r2
 80013a4:	f7ff ffac 	bl	8001300 <disk_ioctl>
			res = FR_DISK_ERR;
 80013a8:	3000      	adds	r0, #0
 80013aa:	bf18      	it	ne
 80013ac:	2001      	movne	r0, #1
	}

	return res;
}
 80013ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		wsect = fs->winsect;	/* Current sector number */
 80013b0:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80013b2:	7840      	ldrb	r0, [r0, #1]
 80013b4:	f104 0730 	add.w	r7, r4, #48	; 0x30
 80013b8:	462a      	mov	r2, r5
 80013ba:	4639      	mov	r1, r7
 80013bc:	2301      	movs	r3, #1
 80013be:	f7ff ff91 	bl	80012e4 <disk_write>
 80013c2:	2800      	cmp	r0, #0
 80013c4:	d155      	bne.n	8001472 <sync_fs+0xe2>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80013c6:	6a22      	ldr	r2, [r4, #32]
 80013c8:	69a3      	ldr	r3, [r4, #24]
			fs->wflag = 0;
 80013ca:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80013cc:	1aaa      	subs	r2, r5, r2
 80013ce:	429a      	cmp	r2, r3
 80013d0:	d2e2      	bcs.n	8001398 <sync_fs+0x8>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80013d2:	78a6      	ldrb	r6, [r4, #2]
 80013d4:	2e01      	cmp	r6, #1
 80013d6:	d801      	bhi.n	80013dc <sync_fs+0x4c>
 80013d8:	e7de      	b.n	8001398 <sync_fs+0x8>
 80013da:	69a3      	ldr	r3, [r4, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 80013dc:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 80013de:	441d      	add	r5, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80013e0:	3e01      	subs	r6, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 80013e2:	462a      	mov	r2, r5
 80013e4:	2301      	movs	r3, #1
 80013e6:	4639      	mov	r1, r7
 80013e8:	f7ff ff7c 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80013ec:	2e01      	cmp	r6, #1
 80013ee:	d1f4      	bne.n	80013da <sync_fs+0x4a>
 80013f0:	e7d2      	b.n	8001398 <sync_fs+0x8>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 80013f2:	7925      	ldrb	r5, [r4, #4]
 80013f4:	2d01      	cmp	r5, #1
 80013f6:	d1d2      	bne.n	800139e <sync_fs+0xe>
		*d++ = (BYTE)val;
 80013f8:	f104 0630 	add.w	r6, r4, #48	; 0x30
 80013fc:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001400:	2100      	movs	r1, #0
 8001402:	4630      	mov	r0, r6
 8001404:	f006 f844 	bl	8007490 <memset>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 8001408:	e9d4 2103 	ldrd	r2, r1, [r4, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 800140c:	2300      	movs	r3, #0
 800140e:	0a08      	lsrs	r0, r1, #8
 8001410:	f361 0307 	bfi	r3, r1, #0, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8001414:	0c0f      	lsrs	r7, r1, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8001416:	f360 230f 	bfi	r3, r0, #8, #8
 800141a:	2000      	movs	r0, #0
 800141c:	f362 0007 	bfi	r0, r2, #0, #8
 8001420:	f367 4317 	bfi	r3, r7, #16, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8001424:	0e09      	lsrs	r1, r1, #24
	*ptr++ = (BYTE)val; val >>= 8;
 8001426:	0a17      	lsrs	r7, r2, #8
 8001428:	f361 631f 	bfi	r3, r1, #24, #8
 800142c:	f367 200f 	bfi	r0, r7, #8, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8001430:	0c11      	lsrs	r1, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8001432:	f361 4017 	bfi	r0, r1, #16, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8001436:	0e12      	lsrs	r2, r2, #24
			fs->winsect = fs->volbase + 1;
 8001438:	69e1      	ldr	r1, [r4, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 800143a:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
 800143e:	f362 601f 	bfi	r0, r2, #24, #8
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8001442:	462b      	mov	r3, r5
			fs->winsect = fs->volbase + 1;
 8001444:	1c4a      	adds	r2, r1, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8001446:	f04f 0c55 	mov.w	ip, #85	; 0x55
	*ptr++ = (BYTE)val; val >>= 8;
 800144a:	f8c4 021c 	str.w	r0, [r4, #540]	; 0x21c
	*ptr++ = (BYTE)val;
 800144e:	27aa      	movs	r7, #170	; 0xaa
	*ptr++ = (BYTE)val; val >>= 8;
 8001450:	4809      	ldr	r0, [pc, #36]	; (8001478 <sync_fs+0xe8>)
 8001452:	4d0a      	ldr	r5, [pc, #40]	; (800147c <sync_fs+0xec>)
 8001454:	f8c4 0214 	str.w	r0, [r4, #532]	; 0x214
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8001458:	4631      	mov	r1, r6
			fs->winsect = fs->volbase + 1;
 800145a:	62e2      	str	r2, [r4, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 800145c:	f884 c22e 	strb.w	ip, [r4, #558]	; 0x22e
	*ptr++ = (BYTE)val;
 8001460:	f884 722f 	strb.w	r7, [r4, #559]	; 0x22f
	*ptr++ = (BYTE)val; val >>= 8;
 8001464:	6325      	str	r5, [r4, #48]	; 0x30
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8001466:	7860      	ldrb	r0, [r4, #1]
 8001468:	f7ff ff3c 	bl	80012e4 <disk_write>
			fs->fsi_flag = 0;
 800146c:	2300      	movs	r3, #0
 800146e:	7123      	strb	r3, [r4, #4]
 8001470:	e795      	b.n	800139e <sync_fs+0xe>
			res = FR_DISK_ERR;
 8001472:	2001      	movs	r0, #1
}
 8001474:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001476:	bf00      	nop
 8001478:	61417272 	.word	0x61417272
 800147c:	41615252 	.word	0x41615252

08001480 <put_fat.part.9>:
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/

static
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 8001480:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;

	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
		switch (fs->fs_type) {
 8001484:	7803      	ldrb	r3, [r0, #0]
 8001486:	2b02      	cmp	r3, #2
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 8001488:	4604      	mov	r4, r0
 800148a:	460d      	mov	r5, r1
 800148c:	4617      	mov	r7, r2
		switch (fs->fs_type) {
 800148e:	f000 808d 	beq.w	80015ac <put_fat.part.9+0x12c>
 8001492:	2b03      	cmp	r3, #3
 8001494:	d064      	beq.n	8001560 <put_fat.part.9+0xe0>
 8001496:	2b01      	cmp	r3, #1
 8001498:	d002      	beq.n	80014a0 <put_fat.part.9+0x20>
	FRESULT res = FR_INT_ERR;
 800149a:	2002      	movs	r0, #2
			fs->wflag = 1;
			break;
		}
	}
	return res;
}
 800149c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80014a0:	6a02      	ldr	r2, [r0, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80014a2:	f8d0 a02c 	ldr.w	sl, [r0, #44]	; 0x2c
			bc = (UINT)clst; bc += bc / 2;
 80014a6:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80014aa:	eb02 2958 	add.w	r9, r2, r8, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 80014ae:	45d1      	cmp	r9, sl
 80014b0:	f100 0630 	add.w	r6, r0, #48	; 0x30
 80014b4:	f040 80f1 	bne.w	800169a <put_fat.part.9+0x21a>
			p = fs->win + bc++ % SS(fs);
 80014b8:	f108 0901 	add.w	r9, r8, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80014bc:	f015 0501 	ands.w	r5, r5, #1
			p = fs->win + bc++ % SS(fs);
 80014c0:	f3c8 0808 	ubfx	r8, r8, #0, #9
 80014c4:	ea4f 2259 	mov.w	r2, r9, lsr #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80014c8:	f000 8115 	beq.w	80016f6 <put_fat.part.9+0x276>
 80014cc:	f816 3008 	ldrb.w	r3, [r6, r8]
 80014d0:	f003 030f 	and.w	r3, r3, #15
 80014d4:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
 80014d8:	f806 3008 	strb.w	r3, [r6, r8]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80014dc:	6a23      	ldr	r3, [r4, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80014de:	f8d4 a02c 	ldr.w	sl, [r4, #44]	; 0x2c
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80014e2:	eb02 0803 	add.w	r8, r2, r3
	if (sector != fs->winsect) {	/* Window offset changed? */
 80014e6:	45d0      	cmp	r8, sl
			fs->wflag = 1;
 80014e8:	f04f 0301 	mov.w	r3, #1
 80014ec:	70e3      	strb	r3, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80014ee:	f000 8121 	beq.w	8001734 <put_fat.part.9+0x2b4>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80014f2:	2301      	movs	r3, #1
 80014f4:	4652      	mov	r2, sl
 80014f6:	4631      	mov	r1, r6
 80014f8:	7860      	ldrb	r0, [r4, #1]
 80014fa:	f7ff fef3 	bl	80012e4 <disk_write>
 80014fe:	2800      	cmp	r0, #0
 8001500:	f040 80c8 	bne.w	8001694 <put_fat.part.9+0x214>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001504:	6a22      	ldr	r2, [r4, #32]
 8001506:	69a3      	ldr	r3, [r4, #24]
			fs->wflag = 0;
 8001508:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800150a:	ebaa 0202 	sub.w	r2, sl, r2
 800150e:	429a      	cmp	r2, r3
 8001510:	d212      	bcs.n	8001538 <put_fat.part.9+0xb8>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001512:	f894 b002 	ldrb.w	fp, [r4, #2]
 8001516:	f1bb 0f01 	cmp.w	fp, #1
 800151a:	d801      	bhi.n	8001520 <put_fat.part.9+0xa0>
 800151c:	e00c      	b.n	8001538 <put_fat.part.9+0xb8>
 800151e:	69a3      	ldr	r3, [r4, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8001520:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 8001522:	449a      	add	sl, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001524:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001528:	4652      	mov	r2, sl
 800152a:	2301      	movs	r3, #1
 800152c:	4631      	mov	r1, r6
 800152e:	f7ff fed9 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001532:	f1bb 0f01 	cmp.w	fp, #1
 8001536:	d1f2      	bne.n	800151e <put_fat.part.9+0x9e>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001538:	2301      	movs	r3, #1
 800153a:	4642      	mov	r2, r8
 800153c:	4631      	mov	r1, r6
 800153e:	7860      	ldrb	r0, [r4, #1]
 8001540:	f7ff fec2 	bl	80012c8 <disk_read>
 8001544:	2800      	cmp	r0, #0
 8001546:	f040 80a2 	bne.w	800168e <put_fat.part.9+0x20e>
			p = fs->win + bc % SS(fs);
 800154a:	f3c9 0908 	ubfx	r9, r9, #0, #9
 800154e:	444e      	add	r6, r9
			fs->winsect = sector;
 8001550:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8001554:	2d00      	cmp	r5, #0
 8001556:	f000 80de 	beq.w	8001716 <put_fat.part.9+0x296>
 800155a:	f3c7 1707 	ubfx	r7, r7, #4, #8
 800155e:	e0e0      	b.n	8001722 <put_fat.part.9+0x2a2>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8001560:	6a03      	ldr	r3, [r0, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001562:	f8d0 902c 	ldr.w	r9, [r0, #44]	; 0x2c
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8001566:	eb03 18d1 	add.w	r8, r3, r1, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800156a:	45c8      	cmp	r8, r9
 800156c:	f100 0630 	add.w	r6, r0, #48	; 0x30
 8001570:	d161      	bne.n	8001636 <put_fat.part.9+0x1b6>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8001572:	00ad      	lsls	r5, r5, #2
 8001574:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 8001578:	1973      	adds	r3, r6, r5
 800157a:	f027 4770 	bic.w	r7, r7, #4026531840	; 0xf0000000
	rv = rv << 8 | ptr[2];
 800157e:	885a      	ldrh	r2, [r3, #2]
	rv = rv << 8 | ptr[0];
 8001580:	0412      	lsls	r2, r2, #16
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8001582:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 8001586:	433a      	orrs	r2, r7
	*ptr++ = (BYTE)val; val >>= 8;
 8001588:	2300      	movs	r3, #0
 800158a:	0a11      	lsrs	r1, r2, #8
 800158c:	f362 0307 	bfi	r3, r2, #0, #8
 8001590:	f361 230f 	bfi	r3, r1, #8, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8001594:	0c11      	lsrs	r1, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8001596:	f361 4317 	bfi	r3, r1, #16, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800159a:	0e12      	lsrs	r2, r2, #24
	*ptr++ = (BYTE)val; val >>= 8;
 800159c:	f362 631f 	bfi	r3, r2, #24, #8
 80015a0:	5173      	str	r3, [r6, r5]
			fs->wflag = 1;
 80015a2:	2201      	movs	r2, #1
 80015a4:	70e2      	strb	r2, [r4, #3]
 80015a6:	2000      	movs	r0, #0
}
 80015a8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 80015ac:	6a06      	ldr	r6, [r0, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80015ae:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 80015b2:	eb06 2611 	add.w	r6, r6, r1, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 80015b6:	4546      	cmp	r6, r8
 80015b8:	f100 0930 	add.w	r9, r0, #48	; 0x30
 80015bc:	d02c      	beq.n	8001618 <put_fat.part.9+0x198>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80015be:	78c3      	ldrb	r3, [r0, #3]
 80015c0:	7840      	ldrb	r0, [r0, #1]
 80015c2:	b30b      	cbz	r3, 8001608 <put_fat.part.9+0x188>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80015c4:	2301      	movs	r3, #1
 80015c6:	4642      	mov	r2, r8
 80015c8:	4649      	mov	r1, r9
 80015ca:	f7ff fe8b 	bl	80012e4 <disk_write>
 80015ce:	2800      	cmp	r0, #0
 80015d0:	d160      	bne.n	8001694 <put_fat.part.9+0x214>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80015d2:	6a22      	ldr	r2, [r4, #32]
 80015d4:	69a3      	ldr	r3, [r4, #24]
			fs->wflag = 0;
 80015d6:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80015d8:	eba8 0202 	sub.w	r2, r8, r2
 80015dc:	429a      	cmp	r2, r3
 80015de:	d212      	bcs.n	8001606 <put_fat.part.9+0x186>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80015e0:	f894 a002 	ldrb.w	sl, [r4, #2]
 80015e4:	f1ba 0f01 	cmp.w	sl, #1
 80015e8:	d801      	bhi.n	80015ee <put_fat.part.9+0x16e>
 80015ea:	e00c      	b.n	8001606 <put_fat.part.9+0x186>
 80015ec:	69a3      	ldr	r3, [r4, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 80015ee:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 80015f0:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80015f2:	f10a 3aff 	add.w	sl, sl, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 80015f6:	4642      	mov	r2, r8
 80015f8:	2301      	movs	r3, #1
 80015fa:	4649      	mov	r1, r9
 80015fc:	f7ff fe72 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001600:	f1ba 0f01 	cmp.w	sl, #1
 8001604:	d1f2      	bne.n	80015ec <put_fat.part.9+0x16c>
 8001606:	7860      	ldrb	r0, [r4, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001608:	2301      	movs	r3, #1
 800160a:	4632      	mov	r2, r6
 800160c:	4649      	mov	r1, r9
 800160e:	f7ff fe5b 	bl	80012c8 <disk_read>
 8001612:	2800      	cmp	r0, #0
 8001614:	d13b      	bne.n	800168e <put_fat.part.9+0x20e>
			fs->winsect = sector;
 8001616:	62e6      	str	r6, [r4, #44]	; 0x2c
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 8001618:	006d      	lsls	r5, r5, #1
 800161a:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
 800161e:	eb09 0205 	add.w	r2, r9, r5
	*ptr++ = (BYTE)val; val >>= 8;
 8001622:	f809 7005 	strb.w	r7, [r9, r5]
 8001626:	f3c7 2107 	ubfx	r1, r7, #8, #8
			fs->wflag = 1;
 800162a:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val;
 800162c:	7051      	strb	r1, [r2, #1]
			fs->wflag = 1;
 800162e:	70e3      	strb	r3, [r4, #3]
 8001630:	2000      	movs	r0, #0
}
 8001632:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001636:	78c3      	ldrb	r3, [r0, #3]
 8001638:	7840      	ldrb	r0, [r0, #1]
 800163a:	b30b      	cbz	r3, 8001680 <put_fat.part.9+0x200>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800163c:	2301      	movs	r3, #1
 800163e:	464a      	mov	r2, r9
 8001640:	4631      	mov	r1, r6
 8001642:	f7ff fe4f 	bl	80012e4 <disk_write>
 8001646:	bb28      	cbnz	r0, 8001694 <put_fat.part.9+0x214>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001648:	6a22      	ldr	r2, [r4, #32]
 800164a:	69a3      	ldr	r3, [r4, #24]
			fs->wflag = 0;
 800164c:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800164e:	eba9 0202 	sub.w	r2, r9, r2
 8001652:	429a      	cmp	r2, r3
 8001654:	7860      	ldrb	r0, [r4, #1]
 8001656:	d213      	bcs.n	8001680 <put_fat.part.9+0x200>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001658:	f894 a002 	ldrb.w	sl, [r4, #2]
 800165c:	f1ba 0f01 	cmp.w	sl, #1
 8001660:	d802      	bhi.n	8001668 <put_fat.part.9+0x1e8>
 8001662:	e00d      	b.n	8001680 <put_fat.part.9+0x200>
 8001664:	69a3      	ldr	r3, [r4, #24]
 8001666:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 8001668:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800166a:	f10a 3aff 	add.w	sl, sl, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 800166e:	464a      	mov	r2, r9
 8001670:	2301      	movs	r3, #1
 8001672:	4631      	mov	r1, r6
 8001674:	f7ff fe36 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001678:	f1ba 0f01 	cmp.w	sl, #1
 800167c:	d1f2      	bne.n	8001664 <put_fat.part.9+0x1e4>
 800167e:	7860      	ldrb	r0, [r4, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001680:	2301      	movs	r3, #1
 8001682:	4642      	mov	r2, r8
 8001684:	4631      	mov	r1, r6
 8001686:	f7ff fe1f 	bl	80012c8 <disk_read>
 800168a:	2800      	cmp	r0, #0
 800168c:	d04f      	beq.n	800172e <put_fat.part.9+0x2ae>
			fs->winsect = sector;
 800168e:	f04f 33ff 	mov.w	r3, #4294967295
 8001692:	62e3      	str	r3, [r4, #44]	; 0x2c
				res = FR_DISK_ERR;
 8001694:	2001      	movs	r0, #1
}
 8001696:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800169a:	78c2      	ldrb	r2, [r0, #3]
 800169c:	7840      	ldrb	r0, [r0, #1]
 800169e:	b302      	cbz	r2, 80016e2 <put_fat.part.9+0x262>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80016a0:	4652      	mov	r2, sl
 80016a2:	4631      	mov	r1, r6
 80016a4:	f7ff fe1e 	bl	80012e4 <disk_write>
 80016a8:	2800      	cmp	r0, #0
 80016aa:	d1f3      	bne.n	8001694 <put_fat.part.9+0x214>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80016ac:	6a22      	ldr	r2, [r4, #32]
 80016ae:	69a3      	ldr	r3, [r4, #24]
			fs->wflag = 0;
 80016b0:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80016b2:	ebaa 0202 	sub.w	r2, sl, r2
 80016b6:	429a      	cmp	r2, r3
 80016b8:	d212      	bcs.n	80016e0 <put_fat.part.9+0x260>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80016ba:	f894 b002 	ldrb.w	fp, [r4, #2]
 80016be:	f1bb 0f01 	cmp.w	fp, #1
 80016c2:	d801      	bhi.n	80016c8 <put_fat.part.9+0x248>
 80016c4:	e00c      	b.n	80016e0 <put_fat.part.9+0x260>
 80016c6:	69a3      	ldr	r3, [r4, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 80016c8:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 80016ca:	449a      	add	sl, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80016cc:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 80016d0:	4652      	mov	r2, sl
 80016d2:	2301      	movs	r3, #1
 80016d4:	4631      	mov	r1, r6
 80016d6:	f7ff fe05 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80016da:	f1bb 0f01 	cmp.w	fp, #1
 80016de:	d1f2      	bne.n	80016c6 <put_fat.part.9+0x246>
 80016e0:	7860      	ldrb	r0, [r4, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80016e2:	2301      	movs	r3, #1
 80016e4:	464a      	mov	r2, r9
 80016e6:	4631      	mov	r1, r6
 80016e8:	f7ff fdee 	bl	80012c8 <disk_read>
 80016ec:	2800      	cmp	r0, #0
 80016ee:	d1ce      	bne.n	800168e <put_fat.part.9+0x20e>
			fs->winsect = sector;
 80016f0:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
 80016f4:	e6e0      	b.n	80014b8 <put_fat.part.9+0x38>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80016f6:	f806 7008 	strb.w	r7, [r6, r8]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80016fa:	6a23      	ldr	r3, [r4, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80016fc:	f8d4 a02c 	ldr.w	sl, [r4, #44]	; 0x2c
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8001700:	eb02 0803 	add.w	r8, r2, r3
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001704:	45c2      	cmp	sl, r8
			fs->wflag = 1;
 8001706:	f04f 0301 	mov.w	r3, #1
 800170a:	70e3      	strb	r3, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800170c:	f47f aef1 	bne.w	80014f2 <put_fat.part.9+0x72>
			p = fs->win + bc % SS(fs);
 8001710:	f3c9 0908 	ubfx	r9, r9, #0, #9
 8001714:	444e      	add	r6, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8001716:	7833      	ldrb	r3, [r6, #0]
 8001718:	f3c7 2203 	ubfx	r2, r7, #8, #4
 800171c:	f023 070f 	bic.w	r7, r3, #15
 8001720:	4317      	orrs	r7, r2
			fs->wflag = 1;
 8001722:	2301      	movs	r3, #1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8001724:	7037      	strb	r7, [r6, #0]
			fs->wflag = 1;
 8001726:	70e3      	strb	r3, [r4, #3]
 8001728:	2000      	movs	r0, #0
}
 800172a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fs->winsect = sector;
 800172e:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
 8001732:	e71e      	b.n	8001572 <put_fat.part.9+0xf2>
			p = fs->win + bc % SS(fs);
 8001734:	f3c9 0908 	ubfx	r9, r9, #0, #9
 8001738:	444e      	add	r6, r9
 800173a:	e70e      	b.n	800155a <put_fat.part.9+0xda>

0800173c <remove_chain>:
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	_FDID* obj,			/* Corresponding object */
	DWORD clst,			/* Cluster to remove a chain from */
	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
)
{
 800173c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001740:	b085      	sub	sp, #20
#endif
#if _USE_TRIM
	DWORD rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8001742:	2901      	cmp	r1, #1
{
 8001744:	9000      	str	r0, [sp, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8001746:	d914      	bls.n	8001772 <remove_chain+0x36>
	FATFS *fs = obj->fs;
 8001748:	6804      	ldr	r4, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800174a:	6963      	ldr	r3, [r4, #20]
 800174c:	428b      	cmp	r3, r1
 800174e:	460d      	mov	r5, r1
 8001750:	4606      	mov	r6, r0
 8001752:	d90e      	bls.n	8001772 <remove_chain+0x36>

	/* Mark the previous cluster 'EOC' on the FAT if it exists */
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 8001754:	b98a      	cbnz	r2, 800177a <remove_chain+0x3e>
 8001756:	46a3      	mov	fp, r4
 8001758:	f104 0a30 	add.w	sl, r4, #48	; 0x30
 800175c:	465e      	mov	r6, fp
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800175e:	429d      	cmp	r5, r3
 8001760:	d207      	bcs.n	8001772 <remove_chain+0x36>
		switch (fs->fs_type) {
 8001762:	7833      	ldrb	r3, [r6, #0]
 8001764:	2b02      	cmp	r3, #2
 8001766:	f000 8135 	beq.w	80019d4 <remove_chain+0x298>
 800176a:	2b03      	cmp	r3, #3
 800176c:	d068      	beq.n	8001840 <remove_chain+0x104>
 800176e:	2b01      	cmp	r3, #1
 8001770:	d014      	beq.n	800179c <remove_chain+0x60>

	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
		if (nxt == 0) break;				/* Empty cluster? */
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 8001772:	2002      	movs	r0, #2
			}
		}
	}
#endif
	return FR_OK;
}
 8001774:	b005      	add	sp, #20
 8001776:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800177a:	2a01      	cmp	r2, #1
 800177c:	d9f9      	bls.n	8001772 <remove_chain+0x36>
 800177e:	4293      	cmp	r3, r2
 8001780:	d9f7      	bls.n	8001772 <remove_chain+0x36>
 8001782:	4611      	mov	r1, r2
 8001784:	4620      	mov	r0, r4
 8001786:	f04f 32ff 	mov.w	r2, #4294967295
 800178a:	f7ff fe79 	bl	8001480 <put_fat.part.9>
		if (res != FR_OK) return res;
 800178e:	2800      	cmp	r0, #0
 8001790:	d1f0      	bne.n	8001774 <remove_chain+0x38>
 8001792:	f8d6 b000 	ldr.w	fp, [r6]
 8001796:	f8db 3014 	ldr.w	r3, [fp, #20]
 800179a:	e7dd      	b.n	8001758 <remove_chain+0x1c>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800179c:	6a32      	ldr	r2, [r6, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800179e:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
			bc = (UINT)clst; bc += bc / 2;
 80017a2:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80017a6:	eb02 2857 	add.w	r8, r2, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 80017aa:	45c8      	cmp	r8, r9
 80017ac:	f040 8156 	bne.w	8001a5c <remove_chain+0x320>
			wc = fs->win[bc++ % SS(fs)];
 80017b0:	f3c7 0308 	ubfx	r3, r7, #0, #9
 80017b4:	3701      	adds	r7, #1
 80017b6:	4433      	add	r3, r6
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80017b8:	eb02 2857 	add.w	r8, r2, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 80017bc:	45c8      	cmp	r8, r9
			wc = fs->win[bc++ % SS(fs)];
 80017be:	f893 b030 	ldrb.w	fp, [r3, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 80017c2:	f000 8260 	beq.w	8001c86 <remove_chain+0x54a>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80017c6:	78f3      	ldrb	r3, [r6, #3]
 80017c8:	7870      	ldrb	r0, [r6, #1]
 80017ca:	f106 0230 	add.w	r2, r6, #48	; 0x30
 80017ce:	4611      	mov	r1, r2
 80017d0:	9201      	str	r2, [sp, #4]
 80017d2:	b333      	cbz	r3, 8001822 <remove_chain+0xe6>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80017d4:	2301      	movs	r3, #1
 80017d6:	464a      	mov	r2, r9
 80017d8:	f7ff fd84 	bl	80012e4 <disk_write>
 80017dc:	2800      	cmp	r0, #0
 80017de:	f040 81a1 	bne.w	8001b24 <remove_chain+0x3e8>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80017e2:	6a32      	ldr	r2, [r6, #32]
 80017e4:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 80017e6:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80017e8:	eba9 0202 	sub.w	r2, r9, r2
 80017ec:	429a      	cmp	r2, r3
 80017ee:	7870      	ldrb	r0, [r6, #1]
 80017f0:	d217      	bcs.n	8001822 <remove_chain+0xe6>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80017f2:	f896 c002 	ldrb.w	ip, [r6, #2]
 80017f6:	4662      	mov	r2, ip
 80017f8:	2a01      	cmp	r2, #1
 80017fa:	d912      	bls.n	8001822 <remove_chain+0xe6>
 80017fc:	9402      	str	r4, [sp, #8]
 80017fe:	9503      	str	r5, [sp, #12]
 8001800:	4664      	mov	r4, ip
 8001802:	9d01      	ldr	r5, [sp, #4]
 8001804:	e001      	b.n	800180a <remove_chain+0xce>
 8001806:	69b3      	ldr	r3, [r6, #24]
 8001808:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 800180a:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800180c:	3c01      	subs	r4, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 800180e:	464a      	mov	r2, r9
 8001810:	2301      	movs	r3, #1
 8001812:	4629      	mov	r1, r5
 8001814:	f7ff fd66 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001818:	2c01      	cmp	r4, #1
 800181a:	d1f4      	bne.n	8001806 <remove_chain+0xca>
 800181c:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8001820:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001822:	9901      	ldr	r1, [sp, #4]
 8001824:	2301      	movs	r3, #1
 8001826:	4642      	mov	r2, r8
 8001828:	f7ff fd4e 	bl	80012c8 <disk_read>
 800182c:	2800      	cmp	r0, #0
 800182e:	f000 8228 	beq.w	8001c82 <remove_chain+0x546>
			fs->winsect = sector;
 8001832:	f04f 33ff 	mov.w	r3, #4294967295
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8001836:	2001      	movs	r0, #1
			fs->winsect = sector;
 8001838:	62f3      	str	r3, [r6, #44]	; 0x2c
}
 800183a:	b005      	add	sp, #20
 800183c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8001840:	6a37      	ldr	r7, [r6, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001842:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8001846:	eb07 17d5 	add.w	r7, r7, r5, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800184a:	454f      	cmp	r7, r9
 800184c:	f106 0830 	add.w	r8, r6, #48	; 0x30
 8001850:	f040 8136 	bne.w	8001ac0 <remove_chain+0x384>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8001854:	00ab      	lsls	r3, r5, #2
 8001856:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 800185a:	eb08 0203 	add.w	r2, r8, r3
	rv = rv << 8 | ptr[0];
 800185e:	f818 7003 	ldrb.w	r7, [r8, r3]
	rv = rv << 8 | ptr[1];
 8001862:	f892 b001 	ldrb.w	fp, [r2, #1]
	rv = rv << 8 | ptr[2];
 8001866:	8853      	ldrh	r3, [r2, #2]
	rv = rv << 8 | ptr[1];
 8001868:	ea4b 2b03 	orr.w	fp, fp, r3, lsl #8
	rv = rv << 8 | ptr[0];
 800186c:	ea47 270b 	orr.w	r7, r7, fp, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8001870:	f027 4770 	bic.w	r7, r7, #4026531840	; 0xf0000000
		if (nxt == 0) break;				/* Empty cluster? */
 8001874:	2f00      	cmp	r7, #0
 8001876:	f000 8214 	beq.w	8001ca2 <remove_chain+0x566>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 800187a:	2f01      	cmp	r7, #1
 800187c:	f43f af79 	beq.w	8001772 <remove_chain+0x36>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8001880:	6963      	ldr	r3, [r4, #20]
 8001882:	429d      	cmp	r5, r3
 8001884:	f4bf af75 	bcs.w	8001772 <remove_chain+0x36>
		switch (fs->fs_type) {
 8001888:	7823      	ldrb	r3, [r4, #0]
 800188a:	2b02      	cmp	r3, #2
 800188c:	f000 8197 	beq.w	8001bbe <remove_chain+0x482>
 8001890:	2b03      	cmp	r3, #3
 8001892:	f000 814b 	beq.w	8001b2c <remove_chain+0x3f0>
 8001896:	2b01      	cmp	r3, #1
 8001898:	f47f af6b 	bne.w	8001772 <remove_chain+0x36>
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800189c:	6a22      	ldr	r2, [r4, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800189e:	f8d4 902c 	ldr.w	r9, [r4, #44]	; 0x2c
			bc = (UINT)clst; bc += bc / 2;
 80018a2:	eb05 0655 	add.w	r6, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80018a6:	eb02 2856 	add.w	r8, r2, r6, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 80018aa:	45c8      	cmp	r8, r9
 80018ac:	d02e      	beq.n	800190c <remove_chain+0x1d0>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80018ae:	78e2      	ldrb	r2, [r4, #3]
 80018b0:	7860      	ldrb	r0, [r4, #1]
 80018b2:	b30a      	cbz	r2, 80018f8 <remove_chain+0x1bc>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80018b4:	464a      	mov	r2, r9
 80018b6:	4651      	mov	r1, sl
 80018b8:	f7ff fd14 	bl	80012e4 <disk_write>
 80018bc:	2800      	cmp	r0, #0
 80018be:	f040 8131 	bne.w	8001b24 <remove_chain+0x3e8>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80018c2:	6a22      	ldr	r2, [r4, #32]
 80018c4:	69a3      	ldr	r3, [r4, #24]
			fs->wflag = 0;
 80018c6:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80018c8:	eba9 0202 	sub.w	r2, r9, r2
 80018cc:	429a      	cmp	r2, r3
 80018ce:	d212      	bcs.n	80018f6 <remove_chain+0x1ba>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80018d0:	f894 b002 	ldrb.w	fp, [r4, #2]
 80018d4:	f1bb 0f01 	cmp.w	fp, #1
 80018d8:	d801      	bhi.n	80018de <remove_chain+0x1a2>
 80018da:	e00c      	b.n	80018f6 <remove_chain+0x1ba>
 80018dc:	69a3      	ldr	r3, [r4, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 80018de:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 80018e0:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80018e2:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 80018e6:	464a      	mov	r2, r9
 80018e8:	2301      	movs	r3, #1
 80018ea:	4651      	mov	r1, sl
 80018ec:	f7ff fcfa 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80018f0:	f1bb 0f01 	cmp.w	fp, #1
 80018f4:	d1f2      	bne.n	80018dc <remove_chain+0x1a0>
 80018f6:	7860      	ldrb	r0, [r4, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80018f8:	2301      	movs	r3, #1
 80018fa:	4642      	mov	r2, r8
 80018fc:	4651      	mov	r1, sl
 80018fe:	f7ff fce3 	bl	80012c8 <disk_read>
 8001902:	2800      	cmp	r0, #0
 8001904:	f040 810b 	bne.w	8001b1e <remove_chain+0x3e2>
			fs->winsect = sector;
 8001908:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
			p = fs->win + bc++ % SS(fs);
 800190c:	f106 0801 	add.w	r8, r6, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8001910:	f015 0901 	ands.w	r9, r5, #1
			p = fs->win + bc++ % SS(fs);
 8001914:	f3c6 0608 	ubfx	r6, r6, #0, #9
 8001918:	ea4f 2258 	mov.w	r2, r8, lsr #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 800191c:	f000 819e 	beq.w	8001c5c <remove_chain+0x520>
 8001920:	f81a 3006 	ldrb.w	r3, [sl, r6]
 8001924:	f003 030f 	and.w	r3, r3, #15
 8001928:	f80a 3006 	strb.w	r3, [sl, r6]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800192c:	6a26      	ldr	r6, [r4, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800192e:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8001930:	4416      	add	r6, r2
			fs->wflag = 1;
 8001932:	f04f 0301 	mov.w	r3, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001936:	42b5      	cmp	r5, r6
			fs->wflag = 1;
 8001938:	70e3      	strb	r3, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800193a:	f000 81b4 	beq.w	8001ca6 <remove_chain+0x56a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800193e:	2301      	movs	r3, #1
 8001940:	462a      	mov	r2, r5
 8001942:	4651      	mov	r1, sl
 8001944:	7860      	ldrb	r0, [r4, #1]
 8001946:	f7ff fccd 	bl	80012e4 <disk_write>
 800194a:	2800      	cmp	r0, #0
 800194c:	f040 80ea 	bne.w	8001b24 <remove_chain+0x3e8>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001950:	6a22      	ldr	r2, [r4, #32]
 8001952:	69a3      	ldr	r3, [r4, #24]
			fs->wflag = 0;
 8001954:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001956:	1aaa      	subs	r2, r5, r2
 8001958:	429a      	cmp	r2, r3
 800195a:	d212      	bcs.n	8001982 <remove_chain+0x246>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800195c:	f894 b002 	ldrb.w	fp, [r4, #2]
 8001960:	f1bb 0f01 	cmp.w	fp, #1
 8001964:	d801      	bhi.n	800196a <remove_chain+0x22e>
 8001966:	e00c      	b.n	8001982 <remove_chain+0x246>
 8001968:	69a3      	ldr	r3, [r4, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 800196a:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 800196c:	441d      	add	r5, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800196e:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001972:	462a      	mov	r2, r5
 8001974:	2301      	movs	r3, #1
 8001976:	4651      	mov	r1, sl
 8001978:	f7ff fcb4 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800197c:	f1bb 0f01 	cmp.w	fp, #1
 8001980:	d1f2      	bne.n	8001968 <remove_chain+0x22c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001982:	2301      	movs	r3, #1
 8001984:	4632      	mov	r2, r6
 8001986:	4651      	mov	r1, sl
 8001988:	7860      	ldrb	r0, [r4, #1]
 800198a:	f7ff fc9d 	bl	80012c8 <disk_read>
 800198e:	2800      	cmp	r0, #0
 8001990:	f040 80c5 	bne.w	8001b1e <remove_chain+0x3e2>
			p = fs->win + bc % SS(fs);
 8001994:	f3c8 0808 	ubfx	r8, r8, #0, #9
 8001998:	44d0      	add	r8, sl
			fs->winsect = sector;
 800199a:	62e6      	str	r6, [r4, #44]	; 0x2c
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800199c:	f1b9 0f00 	cmp.w	r9, #0
 80019a0:	f000 816a 	beq.w	8001c78 <remove_chain+0x53c>
			fs->wflag = 1;
 80019a4:	f04f 0301 	mov.w	r3, #1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 80019a8:	f888 0000 	strb.w	r0, [r8]
			fs->wflag = 1;
 80019ac:	70e3      	strb	r3, [r4, #3]
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 80019ae:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 80019b2:	1e91      	subs	r1, r2, #2
 80019b4:	428b      	cmp	r3, r1
 80019b6:	d205      	bcs.n	80019c4 <remove_chain+0x288>
			fs->fsi_flag |= 1;
 80019b8:	7921      	ldrb	r1, [r4, #4]
			fs->free_clst++;
 80019ba:	3301      	adds	r3, #1
			fs->fsi_flag |= 1;
 80019bc:	f041 0101 	orr.w	r1, r1, #1
			fs->free_clst++;
 80019c0:	6123      	str	r3, [r4, #16]
			fs->fsi_flag |= 1;
 80019c2:	7121      	strb	r1, [r4, #4]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 80019c4:	42ba      	cmp	r2, r7
 80019c6:	f240 816c 	bls.w	8001ca2 <remove_chain+0x566>
		nxt = get_fat(obj, clst);			/* Get cluster status */
 80019ca:	9b00      	ldr	r3, [sp, #0]
 80019cc:	681e      	ldr	r6, [r3, #0]
 80019ce:	463d      	mov	r5, r7
 80019d0:	6973      	ldr	r3, [r6, #20]
 80019d2:	e6c4      	b.n	800175e <remove_chain+0x22>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 80019d4:	6a37      	ldr	r7, [r6, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80019d6:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 80019da:	eb07 2715 	add.w	r7, r7, r5, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 80019de:	454f      	cmp	r7, r9
 80019e0:	f106 0830 	add.w	r8, r6, #48	; 0x30
 80019e4:	d02e      	beq.n	8001a44 <remove_chain+0x308>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80019e6:	78f3      	ldrb	r3, [r6, #3]
 80019e8:	7870      	ldrb	r0, [r6, #1]
 80019ea:	b313      	cbz	r3, 8001a32 <remove_chain+0x2f6>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80019ec:	2301      	movs	r3, #1
 80019ee:	464a      	mov	r2, r9
 80019f0:	4641      	mov	r1, r8
 80019f2:	f7ff fc77 	bl	80012e4 <disk_write>
 80019f6:	2800      	cmp	r0, #0
 80019f8:	f040 8094 	bne.w	8001b24 <remove_chain+0x3e8>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80019fc:	6a32      	ldr	r2, [r6, #32]
 80019fe:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 8001a00:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001a02:	eba9 0202 	sub.w	r2, r9, r2
 8001a06:	429a      	cmp	r2, r3
 8001a08:	d212      	bcs.n	8001a30 <remove_chain+0x2f4>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001a0a:	f896 b002 	ldrb.w	fp, [r6, #2]
 8001a0e:	f1bb 0f01 	cmp.w	fp, #1
 8001a12:	d801      	bhi.n	8001a18 <remove_chain+0x2dc>
 8001a14:	e00c      	b.n	8001a30 <remove_chain+0x2f4>
 8001a16:	69b3      	ldr	r3, [r6, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8001a18:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 8001a1a:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001a1c:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001a20:	464a      	mov	r2, r9
 8001a22:	2301      	movs	r3, #1
 8001a24:	4641      	mov	r1, r8
 8001a26:	f7ff fc5d 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001a2a:	f1bb 0f01 	cmp.w	fp, #1
 8001a2e:	d1f2      	bne.n	8001a16 <remove_chain+0x2da>
 8001a30:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001a32:	2301      	movs	r3, #1
 8001a34:	463a      	mov	r2, r7
 8001a36:	4641      	mov	r1, r8
 8001a38:	f7ff fc46 	bl	80012c8 <disk_read>
 8001a3c:	2800      	cmp	r0, #0
 8001a3e:	f47f aef8 	bne.w	8001832 <remove_chain+0xf6>
			fs->winsect = sector;
 8001a42:	62f7      	str	r7, [r6, #44]	; 0x2c
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8001a44:	006b      	lsls	r3, r5, #1
 8001a46:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 8001a4a:	eb08 0203 	add.w	r2, r8, r3
	rv = rv << 8 | ptr[0];
 8001a4e:	f818 7003 	ldrb.w	r7, [r8, r3]
 8001a52:	f892 b001 	ldrb.w	fp, [r2, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8001a56:	ea47 270b 	orr.w	r7, r7, fp, lsl #8
 8001a5a:	e70b      	b.n	8001874 <remove_chain+0x138>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001a5c:	78f2      	ldrb	r2, [r6, #3]
 8001a5e:	7870      	ldrb	r0, [r6, #1]
 8001a60:	f106 0b30 	add.w	fp, r6, #48	; 0x30
 8001a64:	b1fa      	cbz	r2, 8001aa6 <remove_chain+0x36a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8001a66:	464a      	mov	r2, r9
 8001a68:	4659      	mov	r1, fp
 8001a6a:	f7ff fc3b 	bl	80012e4 <disk_write>
 8001a6e:	2800      	cmp	r0, #0
 8001a70:	d158      	bne.n	8001b24 <remove_chain+0x3e8>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001a72:	6a32      	ldr	r2, [r6, #32]
 8001a74:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 8001a76:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001a78:	eba9 0202 	sub.w	r2, r9, r2
 8001a7c:	429a      	cmp	r2, r3
 8001a7e:	d211      	bcs.n	8001aa4 <remove_chain+0x368>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001a80:	78b2      	ldrb	r2, [r6, #2]
 8001a82:	2a01      	cmp	r2, #1
 8001a84:	d90e      	bls.n	8001aa4 <remove_chain+0x368>
 8001a86:	9401      	str	r4, [sp, #4]
 8001a88:	4614      	mov	r4, r2
 8001a8a:	e000      	b.n	8001a8e <remove_chain+0x352>
 8001a8c:	69b3      	ldr	r3, [r6, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8001a8e:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 8001a90:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001a92:	3c01      	subs	r4, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 8001a94:	464a      	mov	r2, r9
 8001a96:	2301      	movs	r3, #1
 8001a98:	4659      	mov	r1, fp
 8001a9a:	f7ff fc23 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001a9e:	2c01      	cmp	r4, #1
 8001aa0:	d1f4      	bne.n	8001a8c <remove_chain+0x350>
 8001aa2:	9c01      	ldr	r4, [sp, #4]
 8001aa4:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001aa6:	4659      	mov	r1, fp
 8001aa8:	2301      	movs	r3, #1
 8001aaa:	4642      	mov	r2, r8
 8001aac:	f7ff fc0c 	bl	80012c8 <disk_read>
 8001ab0:	2800      	cmp	r0, #0
 8001ab2:	f47f aebe 	bne.w	8001832 <remove_chain+0xf6>
 8001ab6:	6a32      	ldr	r2, [r6, #32]
			fs->winsect = sector;
 8001ab8:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
 8001abc:	46c1      	mov	r9, r8
 8001abe:	e677      	b.n	80017b0 <remove_chain+0x74>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001ac0:	78f3      	ldrb	r3, [r6, #3]
 8001ac2:	7870      	ldrb	r0, [r6, #1]
 8001ac4:	b30b      	cbz	r3, 8001b0a <remove_chain+0x3ce>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8001ac6:	2301      	movs	r3, #1
 8001ac8:	464a      	mov	r2, r9
 8001aca:	4641      	mov	r1, r8
 8001acc:	f7ff fc0a 	bl	80012e4 <disk_write>
 8001ad0:	bb40      	cbnz	r0, 8001b24 <remove_chain+0x3e8>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001ad2:	6a32      	ldr	r2, [r6, #32]
 8001ad4:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 8001ad6:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001ad8:	eba9 0202 	sub.w	r2, r9, r2
 8001adc:	429a      	cmp	r2, r3
 8001ade:	7870      	ldrb	r0, [r6, #1]
 8001ae0:	d213      	bcs.n	8001b0a <remove_chain+0x3ce>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001ae2:	f896 b002 	ldrb.w	fp, [r6, #2]
 8001ae6:	f1bb 0f01 	cmp.w	fp, #1
 8001aea:	d802      	bhi.n	8001af2 <remove_chain+0x3b6>
 8001aec:	e00d      	b.n	8001b0a <remove_chain+0x3ce>
 8001aee:	69b3      	ldr	r3, [r6, #24]
 8001af0:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 8001af2:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001af4:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001af8:	464a      	mov	r2, r9
 8001afa:	2301      	movs	r3, #1
 8001afc:	4641      	mov	r1, r8
 8001afe:	f7ff fbf1 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001b02:	f1bb 0f01 	cmp.w	fp, #1
 8001b06:	d1f2      	bne.n	8001aee <remove_chain+0x3b2>
 8001b08:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001b0a:	2301      	movs	r3, #1
 8001b0c:	463a      	mov	r2, r7
 8001b0e:	4641      	mov	r1, r8
 8001b10:	f7ff fbda 	bl	80012c8 <disk_read>
 8001b14:	2800      	cmp	r0, #0
 8001b16:	f47f ae8c 	bne.w	8001832 <remove_chain+0xf6>
			fs->winsect = sector;
 8001b1a:	62f7      	str	r7, [r6, #44]	; 0x2c
 8001b1c:	e69a      	b.n	8001854 <remove_chain+0x118>
 8001b1e:	f04f 33ff 	mov.w	r3, #4294967295
 8001b22:	62e3      	str	r3, [r4, #44]	; 0x2c
				res = FR_DISK_ERR;
 8001b24:	2001      	movs	r0, #1
}
 8001b26:	b005      	add	sp, #20
 8001b28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8001b2c:	6a26      	ldr	r6, [r4, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001b2e:	f8d4 802c 	ldr.w	r8, [r4, #44]	; 0x2c
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8001b32:	eb06 16d5 	add.w	r6, r6, r5, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001b36:	4546      	cmp	r6, r8
 8001b38:	d02d      	beq.n	8001b96 <remove_chain+0x45a>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001b3a:	78e3      	ldrb	r3, [r4, #3]
 8001b3c:	7860      	ldrb	r0, [r4, #1]
 8001b3e:	b313      	cbz	r3, 8001b86 <remove_chain+0x44a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8001b40:	2301      	movs	r3, #1
 8001b42:	4642      	mov	r2, r8
 8001b44:	4651      	mov	r1, sl
 8001b46:	f7ff fbcd 	bl	80012e4 <disk_write>
 8001b4a:	2800      	cmp	r0, #0
 8001b4c:	d1ea      	bne.n	8001b24 <remove_chain+0x3e8>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001b4e:	6a22      	ldr	r2, [r4, #32]
 8001b50:	69a3      	ldr	r3, [r4, #24]
			fs->wflag = 0;
 8001b52:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001b54:	eba8 0202 	sub.w	r2, r8, r2
 8001b58:	429a      	cmp	r2, r3
 8001b5a:	7860      	ldrb	r0, [r4, #1]
 8001b5c:	d213      	bcs.n	8001b86 <remove_chain+0x44a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001b5e:	f894 9002 	ldrb.w	r9, [r4, #2]
 8001b62:	f1b9 0f01 	cmp.w	r9, #1
 8001b66:	d802      	bhi.n	8001b6e <remove_chain+0x432>
 8001b68:	e00d      	b.n	8001b86 <remove_chain+0x44a>
 8001b6a:	69a3      	ldr	r3, [r4, #24]
 8001b6c:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 8001b6e:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001b70:	f109 39ff 	add.w	r9, r9, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001b74:	4642      	mov	r2, r8
 8001b76:	2301      	movs	r3, #1
 8001b78:	4651      	mov	r1, sl
 8001b7a:	f7ff fbb3 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001b7e:	f1b9 0f01 	cmp.w	r9, #1
 8001b82:	d1f2      	bne.n	8001b6a <remove_chain+0x42e>
 8001b84:	7860      	ldrb	r0, [r4, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001b86:	2301      	movs	r3, #1
 8001b88:	4632      	mov	r2, r6
 8001b8a:	4651      	mov	r1, sl
 8001b8c:	f7ff fb9c 	bl	80012c8 <disk_read>
 8001b90:	2800      	cmp	r0, #0
 8001b92:	d1c4      	bne.n	8001b1e <remove_chain+0x3e2>
			fs->winsect = sector;
 8001b94:	62e6      	str	r6, [r4, #44]	; 0x2c
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8001b96:	00ad      	lsls	r5, r5, #2
 8001b98:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 8001b9c:	eb0a 0205 	add.w	r2, sl, r5
	*ptr++ = (BYTE)val; val >>= 8;
 8001ba0:	f04f 0100 	mov.w	r1, #0
	rv = rv << 8 | ptr[2];
 8001ba4:	8853      	ldrh	r3, [r2, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 8001ba6:	f80a 1005 	strb.w	r1, [sl, r5]
	*ptr++ = (BYTE)val; val >>= 8;
 8001baa:	0a1b      	lsrs	r3, r3, #8
 8001bac:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
	*ptr++ = (BYTE)val;
 8001bb0:	70d3      	strb	r3, [r2, #3]
			fs->wflag = 1;
 8001bb2:	f04f 0301 	mov.w	r3, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8001bb6:	7051      	strb	r1, [r2, #1]
	*ptr++ = (BYTE)val; val >>= 8;
 8001bb8:	7091      	strb	r1, [r2, #2]
			fs->wflag = 1;
 8001bba:	70e3      	strb	r3, [r4, #3]
 8001bbc:	e6f7      	b.n	80019ae <remove_chain+0x272>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8001bbe:	6a26      	ldr	r6, [r4, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001bc0:	f8d4 802c 	ldr.w	r8, [r4, #44]	; 0x2c
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8001bc4:	eb06 2615 	add.w	r6, r6, r5, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001bc8:	4546      	cmp	r6, r8
 8001bca:	d039      	beq.n	8001c40 <remove_chain+0x504>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001bcc:	78e3      	ldrb	r3, [r4, #3]
 8001bce:	7860      	ldrb	r0, [r4, #1]
 8001bd0:	b30b      	cbz	r3, 8001c16 <remove_chain+0x4da>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8001bd2:	2301      	movs	r3, #1
 8001bd4:	4642      	mov	r2, r8
 8001bd6:	4651      	mov	r1, sl
 8001bd8:	f7ff fb84 	bl	80012e4 <disk_write>
 8001bdc:	2800      	cmp	r0, #0
 8001bde:	d1a1      	bne.n	8001b24 <remove_chain+0x3e8>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001be0:	6a22      	ldr	r2, [r4, #32]
 8001be2:	69a3      	ldr	r3, [r4, #24]
			fs->wflag = 0;
 8001be4:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001be6:	eba8 0202 	sub.w	r2, r8, r2
 8001bea:	429a      	cmp	r2, r3
 8001bec:	d212      	bcs.n	8001c14 <remove_chain+0x4d8>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001bee:	f894 9002 	ldrb.w	r9, [r4, #2]
 8001bf2:	f1b9 0f01 	cmp.w	r9, #1
 8001bf6:	d801      	bhi.n	8001bfc <remove_chain+0x4c0>
 8001bf8:	e00c      	b.n	8001c14 <remove_chain+0x4d8>
 8001bfa:	69a3      	ldr	r3, [r4, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8001bfc:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 8001bfe:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001c00:	f109 39ff 	add.w	r9, r9, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001c04:	4642      	mov	r2, r8
 8001c06:	2301      	movs	r3, #1
 8001c08:	4651      	mov	r1, sl
 8001c0a:	f7ff fb6b 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001c0e:	f1b9 0f01 	cmp.w	r9, #1
 8001c12:	d1f2      	bne.n	8001bfa <remove_chain+0x4be>
 8001c14:	7860      	ldrb	r0, [r4, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001c16:	2301      	movs	r3, #1
 8001c18:	4632      	mov	r2, r6
 8001c1a:	4651      	mov	r1, sl
 8001c1c:	f7ff fb54 	bl	80012c8 <disk_read>
 8001c20:	2800      	cmp	r0, #0
 8001c22:	f47f af7c 	bne.w	8001b1e <remove_chain+0x3e2>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 8001c26:	006d      	lsls	r5, r5, #1
 8001c28:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
 8001c2c:	eb0a 0305 	add.w	r3, sl, r5
			fs->winsect = sector;
 8001c30:	62e6      	str	r6, [r4, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 8001c32:	f80a 0005 	strb.w	r0, [sl, r5]
	*ptr++ = (BYTE)val;
 8001c36:	7058      	strb	r0, [r3, #1]
			fs->wflag = 1;
 8001c38:	f04f 0301 	mov.w	r3, #1
 8001c3c:	70e3      	strb	r3, [r4, #3]
 8001c3e:	e6b6      	b.n	80019ae <remove_chain+0x272>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 8001c40:	006d      	lsls	r5, r5, #1
 8001c42:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
 8001c46:	eb0a 0305 	add.w	r3, sl, r5
	*ptr++ = (BYTE)val; val >>= 8;
 8001c4a:	f04f 0200 	mov.w	r2, #0
 8001c4e:	f80a 2005 	strb.w	r2, [sl, r5]
	*ptr++ = (BYTE)val;
 8001c52:	705a      	strb	r2, [r3, #1]
			fs->wflag = 1;
 8001c54:	f04f 0301 	mov.w	r3, #1
 8001c58:	70e3      	strb	r3, [r4, #3]
 8001c5a:	e6a8      	b.n	80019ae <remove_chain+0x272>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8001c5c:	f80a 9006 	strb.w	r9, [sl, r6]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8001c60:	6a26      	ldr	r6, [r4, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001c62:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8001c64:	4416      	add	r6, r2
			fs->wflag = 1;
 8001c66:	f04f 0301 	mov.w	r3, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001c6a:	42b5      	cmp	r5, r6
			fs->wflag = 1;
 8001c6c:	70e3      	strb	r3, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001c6e:	f47f ae66 	bne.w	800193e <remove_chain+0x202>
			p = fs->win + bc % SS(fs);
 8001c72:	f3c8 0808 	ubfx	r8, r8, #0, #9
 8001c76:	44d0      	add	r8, sl
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8001c78:	f898 0000 	ldrb.w	r0, [r8]
 8001c7c:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
 8001c80:	e690      	b.n	80019a4 <remove_chain+0x268>
			fs->winsect = sector;
 8001c82:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
			wc |= fs->win[bc % SS(fs)] << 8;
 8001c86:	f3c7 0708 	ubfx	r7, r7, #0, #9
 8001c8a:	443e      	add	r6, r7
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8001c8c:	07eb      	lsls	r3, r5, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 8001c8e:	f896 7030 	ldrb.w	r7, [r6, #48]	; 0x30
 8001c92:	ea4b 2b07 	orr.w	fp, fp, r7, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8001c96:	bf4c      	ite	mi
 8001c98:	ea4f 171b 	movmi.w	r7, fp, lsr #4
 8001c9c:	f3cb 070b 	ubfxpl	r7, fp, #0, #12
 8001ca0:	e5e8      	b.n	8001874 <remove_chain+0x138>
	return FR_OK;
 8001ca2:	2000      	movs	r0, #0
 8001ca4:	e566      	b.n	8001774 <remove_chain+0x38>
			p = fs->win + bc % SS(fs);
 8001ca6:	f3c8 0808 	ubfx	r8, r8, #0, #9
 8001caa:	44d0      	add	r8, sl
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8001cac:	2000      	movs	r0, #0
 8001cae:	e679      	b.n	80019a4 <remove_chain+0x268>

08001cb0 <dir_sdi.constprop.14>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 8001cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
		return FR_INT_ERR;
	}
	dp->dptr = ofs;				/* Set current offset */
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8001cb4:	6884      	ldr	r4, [r0, #8]
	FATFS *fs = dp->obj.fs;
 8001cb6:	f8d0 8000 	ldr.w	r8, [r0]
	dp->dptr = ofs;				/* Set current offset */
 8001cba:	2300      	movs	r3, #0
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 8001cbc:	b085      	sub	sp, #20
	dp->dptr = ofs;				/* Set current offset */
 8001cbe:	6143      	str	r3, [r0, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 8001cc0:	bb2c      	cbnz	r4, 8001d0e <dir_sdi.constprop.14+0x5e>
 8001cc2:	f898 3000 	ldrb.w	r3, [r8]
 8001cc6:	2b02      	cmp	r3, #2
 8001cc8:	d81c      	bhi.n	8001d04 <dir_sdi.constprop.14+0x54>
		clst = fs->dirbase;
		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
	}

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 8001cca:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 8001cce:	b1ab      	cbz	r3, 8001cfc <dir_sdi.constprop.14+0x4c>
		dp->sect = fs->dirbase;
 8001cd0:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8001cd4:	61c3      	str	r3, [r0, #28]
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
			ofs -= csz;
		}
		dp->sect = clust2sect(fs, clst);
	}
	dp->clust = clst;					/* Current cluster# */
 8001cd6:	6184      	str	r4, [r0, #24]
	if (!dp->sect) return FR_INT_ERR;
 8001cd8:	b183      	cbz	r3, 8001cfc <dir_sdi.constprop.14+0x4c>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8001cda:	f108 0330 	add.w	r3, r8, #48	; 0x30
 8001cde:	6203      	str	r3, [r0, #32]

	return FR_OK;
 8001ce0:	2000      	movs	r0, #0
}
 8001ce2:	b005      	add	sp, #20
 8001ce4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8001ce8:	f8d8 2014 	ldr.w	r2, [r8, #20]
	clst -= 2;
 8001cec:	1ea1      	subs	r1, r4, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8001cee:	3a02      	subs	r2, #2
 8001cf0:	4291      	cmp	r1, r2
 8001cf2:	f0c0 814d 	bcc.w	8001f90 <dir_sdi.constprop.14+0x2e0>
		dp->sect = clust2sect(fs, clst);
 8001cf6:	2300      	movs	r3, #0
 8001cf8:	e9c0 4306 	strd	r4, r3, [r0, #24]
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 8001cfc:	2002      	movs	r0, #2
}
 8001cfe:	b005      	add	sp, #20
 8001d00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		clst = fs->dirbase;
 8001d04:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 8001d08:	2b00      	cmp	r3, #0
 8001d0a:	d0de      	beq.n	8001cca <dir_sdi.constprop.14+0x1a>
 8001d0c:	461c      	mov	r4, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 8001d0e:	f8b8 300a 	ldrh.w	r3, [r8, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
 8001d12:	2b00      	cmp	r3, #0
 8001d14:	d1e8      	bne.n	8001ce8 <dir_sdi.constprop.14+0x38>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8001d16:	2c01      	cmp	r4, #1
 8001d18:	d9f0      	bls.n	8001cfc <dir_sdi.constprop.14+0x4c>
 8001d1a:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8001d1e:	42a3      	cmp	r3, r4
 8001d20:	d9ec      	bls.n	8001cfc <dir_sdi.constprop.14+0x4c>
 8001d22:	4645      	mov	r5, r8
 8001d24:	4607      	mov	r7, r0
		switch (fs->fs_type) {
 8001d26:	782b      	ldrb	r3, [r5, #0]
 8001d28:	2b02      	cmp	r3, #2
 8001d2a:	f000 809a 	beq.w	8001e62 <dir_sdi.constprop.14+0x1b2>
 8001d2e:	2b03      	cmp	r3, #3
 8001d30:	d040      	beq.n	8001db4 <dir_sdi.constprop.14+0x104>
 8001d32:	2b01      	cmp	r3, #1
 8001d34:	d1e2      	bne.n	8001cfc <dir_sdi.constprop.14+0x4c>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8001d36:	6a2a      	ldr	r2, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001d38:	f8d5 902c 	ldr.w	r9, [r5, #44]	; 0x2c
			bc = (UINT)clst; bc += bc / 2;
 8001d3c:	eb04 0654 	add.w	r6, r4, r4, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8001d40:	eb02 2a56 	add.w	sl, r2, r6, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001d44:	45ca      	cmp	sl, r9
 8001d46:	f000 80d2 	beq.w	8001eee <dir_sdi.constprop.14+0x23e>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001d4a:	78ea      	ldrb	r2, [r5, #3]
 8001d4c:	7868      	ldrb	r0, [r5, #1]
 8001d4e:	f105 0b30 	add.w	fp, r5, #48	; 0x30
 8001d52:	b312      	cbz	r2, 8001d9a <dir_sdi.constprop.14+0xea>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8001d54:	464a      	mov	r2, r9
 8001d56:	4659      	mov	r1, fp
 8001d58:	f7ff fac4 	bl	80012e4 <disk_write>
 8001d5c:	bb40      	cbnz	r0, 8001db0 <dir_sdi.constprop.14+0x100>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001d5e:	6a2a      	ldr	r2, [r5, #32]
 8001d60:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8001d62:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001d64:	eba9 0202 	sub.w	r2, r9, r2
 8001d68:	429a      	cmp	r2, r3
 8001d6a:	d215      	bcs.n	8001d98 <dir_sdi.constprop.14+0xe8>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001d6c:	78aa      	ldrb	r2, [r5, #2]
 8001d6e:	2a01      	cmp	r2, #1
 8001d70:	d912      	bls.n	8001d98 <dir_sdi.constprop.14+0xe8>
 8001d72:	f8cd 8004 	str.w	r8, [sp, #4]
 8001d76:	4690      	mov	r8, r2
 8001d78:	e000      	b.n	8001d7c <dir_sdi.constprop.14+0xcc>
 8001d7a:	69ab      	ldr	r3, [r5, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8001d7c:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8001d7e:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001d80:	f108 38ff 	add.w	r8, r8, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001d84:	464a      	mov	r2, r9
 8001d86:	2301      	movs	r3, #1
 8001d88:	4659      	mov	r1, fp
 8001d8a:	f7ff faab 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001d8e:	f1b8 0f01 	cmp.w	r8, #1
 8001d92:	d1f2      	bne.n	8001d7a <dir_sdi.constprop.14+0xca>
 8001d94:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8001d98:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001d9a:	4659      	mov	r1, fp
 8001d9c:	2301      	movs	r3, #1
 8001d9e:	4652      	mov	r2, sl
 8001da0:	f7ff fa92 	bl	80012c8 <disk_read>
 8001da4:	2800      	cmp	r0, #0
 8001da6:	f000 809e 	beq.w	8001ee6 <dir_sdi.constprop.14+0x236>
			fs->winsect = sector;
 8001daa:	f04f 33ff 	mov.w	r3, #4294967295
 8001dae:	62eb      	str	r3, [r5, #44]	; 0x2c
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8001db0:	2001      	movs	r0, #1
 8001db2:	e796      	b.n	8001ce2 <dir_sdi.constprop.14+0x32>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8001db4:	6a2e      	ldr	r6, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001db6:	f8d5 a02c 	ldr.w	sl, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8001dba:	eb06 16d4 	add.w	r6, r6, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001dbe:	4556      	cmp	r6, sl
 8001dc0:	f105 0930 	add.w	r9, r5, #48	; 0x30
 8001dc4:	d02d      	beq.n	8001e22 <dir_sdi.constprop.14+0x172>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001dc6:	78eb      	ldrb	r3, [r5, #3]
 8001dc8:	7868      	ldrb	r0, [r5, #1]
 8001dca:	b313      	cbz	r3, 8001e12 <dir_sdi.constprop.14+0x162>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8001dcc:	2301      	movs	r3, #1
 8001dce:	4652      	mov	r2, sl
 8001dd0:	4649      	mov	r1, r9
 8001dd2:	f7ff fa87 	bl	80012e4 <disk_write>
 8001dd6:	2800      	cmp	r0, #0
 8001dd8:	d1ea      	bne.n	8001db0 <dir_sdi.constprop.14+0x100>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001dda:	6a2a      	ldr	r2, [r5, #32]
 8001ddc:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8001dde:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001de0:	ebaa 0202 	sub.w	r2, sl, r2
 8001de4:	429a      	cmp	r2, r3
 8001de6:	7868      	ldrb	r0, [r5, #1]
 8001de8:	d213      	bcs.n	8001e12 <dir_sdi.constprop.14+0x162>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001dea:	f895 b002 	ldrb.w	fp, [r5, #2]
 8001dee:	f1bb 0f01 	cmp.w	fp, #1
 8001df2:	d802      	bhi.n	8001dfa <dir_sdi.constprop.14+0x14a>
 8001df4:	e00d      	b.n	8001e12 <dir_sdi.constprop.14+0x162>
 8001df6:	69ab      	ldr	r3, [r5, #24]
 8001df8:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8001dfa:	449a      	add	sl, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001dfc:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001e00:	4652      	mov	r2, sl
 8001e02:	2301      	movs	r3, #1
 8001e04:	4649      	mov	r1, r9
 8001e06:	f7ff fa6d 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001e0a:	f1bb 0f01 	cmp.w	fp, #1
 8001e0e:	d1f2      	bne.n	8001df6 <dir_sdi.constprop.14+0x146>
 8001e10:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001e12:	2301      	movs	r3, #1
 8001e14:	4632      	mov	r2, r6
 8001e16:	4649      	mov	r1, r9
 8001e18:	f7ff fa56 	bl	80012c8 <disk_read>
 8001e1c:	2800      	cmp	r0, #0
 8001e1e:	d1c4      	bne.n	8001daa <dir_sdi.constprop.14+0xfa>
			fs->winsect = sector;
 8001e20:	62ee      	str	r6, [r5, #44]	; 0x2c
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8001e22:	00a4      	lsls	r4, r4, #2
 8001e24:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
 8001e28:	eb09 0204 	add.w	r2, r9, r4
	rv = rv << 8 | ptr[0];
 8001e2c:	f819 4004 	ldrb.w	r4, [r9, r4]
	rv = rv << 8 | ptr[2];
 8001e30:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 8001e32:	7853      	ldrb	r3, [r2, #1]
 8001e34:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 8001e38:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8001e3c:	f024 4470 	bic.w	r4, r4, #4026531840	; 0xf0000000
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 8001e40:	2c01      	cmp	r4, #1
 8001e42:	f67f af5b 	bls.w	8001cfc <dir_sdi.constprop.14+0x4c>
 8001e46:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8001e4a:	42a3      	cmp	r3, r4
 8001e4c:	f67f af56 	bls.w	8001cfc <dir_sdi.constprop.14+0x4c>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8001e50:	683d      	ldr	r5, [r7, #0]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8001e52:	696b      	ldr	r3, [r5, #20]
 8001e54:	42a3      	cmp	r3, r4
 8001e56:	f67f af51 	bls.w	8001cfc <dir_sdi.constprop.14+0x4c>
		switch (fs->fs_type) {
 8001e5a:	782b      	ldrb	r3, [r5, #0]
 8001e5c:	2b02      	cmp	r3, #2
 8001e5e:	f47f af66 	bne.w	8001d2e <dir_sdi.constprop.14+0x7e>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8001e62:	6a2e      	ldr	r6, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001e64:	f8d5 a02c 	ldr.w	sl, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8001e68:	eb06 2614 	add.w	r6, r6, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001e6c:	4556      	cmp	r6, sl
 8001e6e:	f105 0930 	add.w	r9, r5, #48	; 0x30
 8001e72:	d02d      	beq.n	8001ed0 <dir_sdi.constprop.14+0x220>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001e74:	78eb      	ldrb	r3, [r5, #3]
 8001e76:	7868      	ldrb	r0, [r5, #1]
 8001e78:	b30b      	cbz	r3, 8001ebe <dir_sdi.constprop.14+0x20e>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8001e7a:	2301      	movs	r3, #1
 8001e7c:	4652      	mov	r2, sl
 8001e7e:	4649      	mov	r1, r9
 8001e80:	f7ff fa30 	bl	80012e4 <disk_write>
 8001e84:	2800      	cmp	r0, #0
 8001e86:	d193      	bne.n	8001db0 <dir_sdi.constprop.14+0x100>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001e88:	6a2a      	ldr	r2, [r5, #32]
 8001e8a:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8001e8c:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001e8e:	ebaa 0202 	sub.w	r2, sl, r2
 8001e92:	429a      	cmp	r2, r3
 8001e94:	d212      	bcs.n	8001ebc <dir_sdi.constprop.14+0x20c>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001e96:	f895 b002 	ldrb.w	fp, [r5, #2]
 8001e9a:	f1bb 0f01 	cmp.w	fp, #1
 8001e9e:	d801      	bhi.n	8001ea4 <dir_sdi.constprop.14+0x1f4>
 8001ea0:	e00c      	b.n	8001ebc <dir_sdi.constprop.14+0x20c>
 8001ea2:	69ab      	ldr	r3, [r5, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8001ea4:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8001ea6:	449a      	add	sl, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001ea8:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001eac:	4652      	mov	r2, sl
 8001eae:	2301      	movs	r3, #1
 8001eb0:	4649      	mov	r1, r9
 8001eb2:	f7ff fa17 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001eb6:	f1bb 0f01 	cmp.w	fp, #1
 8001eba:	d1f2      	bne.n	8001ea2 <dir_sdi.constprop.14+0x1f2>
 8001ebc:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001ebe:	2301      	movs	r3, #1
 8001ec0:	4632      	mov	r2, r6
 8001ec2:	4649      	mov	r1, r9
 8001ec4:	f7ff fa00 	bl	80012c8 <disk_read>
 8001ec8:	2800      	cmp	r0, #0
 8001eca:	f47f af6e 	bne.w	8001daa <dir_sdi.constprop.14+0xfa>
			fs->winsect = sector;
 8001ece:	62ee      	str	r6, [r5, #44]	; 0x2c
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8001ed0:	0064      	lsls	r4, r4, #1
 8001ed2:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
 8001ed6:	eb09 0304 	add.w	r3, r9, r4
	rv = rv << 8 | ptr[0];
 8001eda:	f819 4004 	ldrb.w	r4, [r9, r4]
 8001ede:	785b      	ldrb	r3, [r3, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8001ee0:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 8001ee4:	e7ac      	b.n	8001e40 <dir_sdi.constprop.14+0x190>
 8001ee6:	6a2a      	ldr	r2, [r5, #32]
			fs->winsect = sector;
 8001ee8:	f8c5 a02c 	str.w	sl, [r5, #44]	; 0x2c
 8001eec:	46d1      	mov	r9, sl
			wc = fs->win[bc++ % SS(fs)];
 8001eee:	f3c6 0308 	ubfx	r3, r6, #0, #9
 8001ef2:	3601      	adds	r6, #1
 8001ef4:	442b      	add	r3, r5
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8001ef6:	eb02 2a56 	add.w	sl, r2, r6, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001efa:	45ca      	cmp	sl, r9
			wc = fs->win[bc++ % SS(fs)];
 8001efc:	f893 b030 	ldrb.w	fp, [r3, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001f00:	d039      	beq.n	8001f76 <dir_sdi.constprop.14+0x2c6>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8001f02:	78eb      	ldrb	r3, [r5, #3]
 8001f04:	7868      	ldrb	r0, [r5, #1]
 8001f06:	f105 0230 	add.w	r2, r5, #48	; 0x30
 8001f0a:	4611      	mov	r1, r2
 8001f0c:	9201      	str	r2, [sp, #4]
 8001f0e:	b343      	cbz	r3, 8001f62 <dir_sdi.constprop.14+0x2b2>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8001f10:	2301      	movs	r3, #1
 8001f12:	464a      	mov	r2, r9
 8001f14:	f7ff f9e6 	bl	80012e4 <disk_write>
 8001f18:	2800      	cmp	r0, #0
 8001f1a:	f47f af49 	bne.w	8001db0 <dir_sdi.constprop.14+0x100>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001f1e:	6a2a      	ldr	r2, [r5, #32]
 8001f20:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8001f22:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8001f24:	eba9 0202 	sub.w	r2, r9, r2
 8001f28:	429a      	cmp	r2, r3
 8001f2a:	7868      	ldrb	r0, [r5, #1]
 8001f2c:	d219      	bcs.n	8001f62 <dir_sdi.constprop.14+0x2b2>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001f2e:	f895 c002 	ldrb.w	ip, [r5, #2]
 8001f32:	4662      	mov	r2, ip
 8001f34:	2a01      	cmp	r2, #1
 8001f36:	d914      	bls.n	8001f62 <dir_sdi.constprop.14+0x2b2>
 8001f38:	e9cd 8402 	strd	r8, r4, [sp, #8]
 8001f3c:	46e0      	mov	r8, ip
 8001f3e:	9c01      	ldr	r4, [sp, #4]
 8001f40:	e001      	b.n	8001f46 <dir_sdi.constprop.14+0x296>
 8001f42:	69ab      	ldr	r3, [r5, #24]
 8001f44:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8001f46:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001f48:	f108 38ff 	add.w	r8, r8, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8001f4c:	464a      	mov	r2, r9
 8001f4e:	2301      	movs	r3, #1
 8001f50:	4621      	mov	r1, r4
 8001f52:	f7ff f9c7 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8001f56:	f1b8 0f01 	cmp.w	r8, #1
 8001f5a:	d1f2      	bne.n	8001f42 <dir_sdi.constprop.14+0x292>
 8001f5c:	e9dd 8402 	ldrd	r8, r4, [sp, #8]
 8001f60:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8001f62:	9901      	ldr	r1, [sp, #4]
 8001f64:	2301      	movs	r3, #1
 8001f66:	4652      	mov	r2, sl
 8001f68:	f7ff f9ae 	bl	80012c8 <disk_read>
 8001f6c:	2800      	cmp	r0, #0
 8001f6e:	f47f af1c 	bne.w	8001daa <dir_sdi.constprop.14+0xfa>
			fs->winsect = sector;
 8001f72:	f8c5 a02c 	str.w	sl, [r5, #44]	; 0x2c
			wc |= fs->win[bc % SS(fs)] << 8;
 8001f76:	f3c6 0608 	ubfx	r6, r6, #0, #9
 8001f7a:	4435      	add	r5, r6
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8001f7c:	07e2      	lsls	r2, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 8001f7e:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
 8001f82:	ea4b 2303 	orr.w	r3, fp, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8001f86:	bf4c      	ite	mi
 8001f88:	091c      	lsrmi	r4, r3, #4
 8001f8a:	f3c3 040b 	ubfxpl	r4, r3, #0, #12
 8001f8e:	e757      	b.n	8001e40 <dir_sdi.constprop.14+0x190>
	return clst * fs->csize + fs->database;
 8001f90:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
 8001f94:	fb01 2303 	mla	r3, r1, r3, r2
		dp->sect = clust2sect(fs, clst);
 8001f98:	61c3      	str	r3, [r0, #28]
 8001f9a:	e69c      	b.n	8001cd6 <dir_sdi.constprop.14+0x26>

08001f9c <get_fat.isra.10>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8001f9c:	2901      	cmp	r1, #1
 8001f9e:	d932      	bls.n	8002006 <get_fat.isra.10+0x6a>
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 8001fa0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8001fa4:	6943      	ldr	r3, [r0, #20]
 8001fa6:	4299      	cmp	r1, r3
 8001fa8:	d22a      	bcs.n	8002000 <get_fat.isra.10+0x64>
		switch (fs->fs_type) {
 8001faa:	7803      	ldrb	r3, [r0, #0]
 8001fac:	2b02      	cmp	r3, #2
 8001fae:	4606      	mov	r6, r0
 8001fb0:	460c      	mov	r4, r1
 8001fb2:	d041      	beq.n	8002038 <get_fat.isra.10+0x9c>
 8001fb4:	2b03      	cmp	r3, #3
 8001fb6:	d028      	beq.n	800200a <get_fat.isra.10+0x6e>
 8001fb8:	2b01      	cmp	r3, #1
 8001fba:	d121      	bne.n	8002000 <get_fat.isra.10+0x64>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8001fbc:	6a02      	ldr	r2, [r0, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001fbe:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
			bc = (UINT)clst; bc += bc / 2;
 8001fc2:	eb01 0551 	add.w	r5, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8001fc6:	eb02 2755 	add.w	r7, r2, r5, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001fca:	4547      	cmp	r7, r8
 8001fcc:	f040 80a5 	bne.w	800211a <get_fat.isra.10+0x17e>
			wc = fs->win[bc++ % SS(fs)];
 8001fd0:	f3c5 0308 	ubfx	r3, r5, #0, #9
 8001fd4:	1c6f      	adds	r7, r5, #1
 8001fd6:	4433      	add	r3, r6
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8001fd8:	eb02 2957 	add.w	r9, r2, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001fdc:	45c1      	cmp	r9, r8
			wc = fs->win[bc++ % SS(fs)];
 8001fde:	f893 5030 	ldrb.w	r5, [r3, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001fe2:	f040 80ca 	bne.w	800217a <get_fat.isra.10+0x1de>
			wc |= fs->win[bc % SS(fs)] << 8;
 8001fe6:	f3c7 0008 	ubfx	r0, r7, #0, #9
 8001fea:	4430      	add	r0, r6
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8001fec:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 8001fee:	f890 0030 	ldrb.w	r0, [r0, #48]	; 0x30
 8001ff2:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8001ff6:	bf4c      	ite	mi
 8001ff8:	0900      	lsrmi	r0, r0, #4
 8001ffa:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 8001ffe:	e000      	b.n	8002002 <get_fat.isra.10+0x66>
			val = 1;	/* Internal error */
 8002000:	2001      	movs	r0, #1
}
 8002002:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		val = 1;	/* Internal error */
 8002006:	2001      	movs	r0, #1
}
 8002008:	4770      	bx	lr
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800200a:	6a05      	ldr	r5, [r0, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800200c:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8002010:	eb05 15d1 	add.w	r5, r5, r1, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002014:	4545      	cmp	r5, r8
 8002016:	f100 0730 	add.w	r7, r0, #48	; 0x30
 800201a:	d14e      	bne.n	80020ba <get_fat.isra.10+0x11e>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800201c:	00a1      	lsls	r1, r4, #2
 800201e:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
 8002022:	187a      	adds	r2, r7, r1
	rv = rv << 8 | ptr[0];
 8002024:	5c78      	ldrb	r0, [r7, r1]
	rv = rv << 8 | ptr[1];
 8002026:	7853      	ldrb	r3, [r2, #1]
	rv = rv << 8 | ptr[2];
 8002028:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 800202a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800202e:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8002032:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 8002036:	e7e4      	b.n	8002002 <get_fat.isra.10+0x66>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8002038:	6a05      	ldr	r5, [r0, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800203a:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800203e:	eb05 2511 	add.w	r5, r5, r1, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002042:	4545      	cmp	r5, r8
 8002044:	f100 0730 	add.w	r7, r0, #48	; 0x30
 8002048:	d02e      	beq.n	80020a8 <get_fat.isra.10+0x10c>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800204a:	78c3      	ldrb	r3, [r0, #3]
 800204c:	7840      	ldrb	r0, [r0, #1]
 800204e:	b313      	cbz	r3, 8002096 <get_fat.isra.10+0xfa>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8002050:	2301      	movs	r3, #1
 8002052:	4642      	mov	r2, r8
 8002054:	4639      	mov	r1, r7
 8002056:	f7ff f945 	bl	80012e4 <disk_write>
 800205a:	2800      	cmp	r0, #0
 800205c:	f040 80c1 	bne.w	80021e2 <get_fat.isra.10+0x246>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002060:	6a32      	ldr	r2, [r6, #32]
 8002062:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 8002064:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002066:	eba8 0202 	sub.w	r2, r8, r2
 800206a:	429a      	cmp	r2, r3
 800206c:	d212      	bcs.n	8002094 <get_fat.isra.10+0xf8>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800206e:	f896 9002 	ldrb.w	r9, [r6, #2]
 8002072:	f1b9 0f01 	cmp.w	r9, #1
 8002076:	d801      	bhi.n	800207c <get_fat.isra.10+0xe0>
 8002078:	e00c      	b.n	8002094 <get_fat.isra.10+0xf8>
 800207a:	69b3      	ldr	r3, [r6, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 800207c:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 800207e:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002080:	f109 39ff 	add.w	r9, r9, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8002084:	4642      	mov	r2, r8
 8002086:	2301      	movs	r3, #1
 8002088:	4639      	mov	r1, r7
 800208a:	f7ff f92b 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800208e:	f1b9 0f01 	cmp.w	r9, #1
 8002092:	d1f2      	bne.n	800207a <get_fat.isra.10+0xde>
 8002094:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002096:	2301      	movs	r3, #1
 8002098:	462a      	mov	r2, r5
 800209a:	4639      	mov	r1, r7
 800209c:	f7ff f914 	bl	80012c8 <disk_read>
 80020a0:	2800      	cmp	r0, #0
 80020a2:	f040 809a 	bne.w	80021da <get_fat.isra.10+0x23e>
			fs->winsect = sector;
 80020a6:	62f5      	str	r5, [r6, #44]	; 0x2c
			val = ld_word(fs->win + clst * 2 % SS(fs));
 80020a8:	0061      	lsls	r1, r4, #1
 80020aa:	f401 71ff 	and.w	r1, r1, #510	; 0x1fe
 80020ae:	187b      	adds	r3, r7, r1
	rv = rv << 8 | ptr[0];
 80020b0:	5c78      	ldrb	r0, [r7, r1]
 80020b2:	785b      	ldrb	r3, [r3, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 80020b4:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 80020b8:	e7a3      	b.n	8002002 <get_fat.isra.10+0x66>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80020ba:	78c3      	ldrb	r3, [r0, #3]
 80020bc:	7840      	ldrb	r0, [r0, #1]
 80020be:	b31b      	cbz	r3, 8002108 <get_fat.isra.10+0x16c>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80020c0:	2301      	movs	r3, #1
 80020c2:	4642      	mov	r2, r8
 80020c4:	4639      	mov	r1, r7
 80020c6:	f7ff f90d 	bl	80012e4 <disk_write>
 80020ca:	2800      	cmp	r0, #0
 80020cc:	f040 8089 	bne.w	80021e2 <get_fat.isra.10+0x246>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80020d0:	6a32      	ldr	r2, [r6, #32]
 80020d2:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 80020d4:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80020d6:	eba8 0202 	sub.w	r2, r8, r2
 80020da:	429a      	cmp	r2, r3
 80020dc:	7870      	ldrb	r0, [r6, #1]
 80020de:	d213      	bcs.n	8002108 <get_fat.isra.10+0x16c>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80020e0:	f896 9002 	ldrb.w	r9, [r6, #2]
 80020e4:	f1b9 0f01 	cmp.w	r9, #1
 80020e8:	d802      	bhi.n	80020f0 <get_fat.isra.10+0x154>
 80020ea:	e00d      	b.n	8002108 <get_fat.isra.10+0x16c>
 80020ec:	69b3      	ldr	r3, [r6, #24]
 80020ee:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 80020f0:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80020f2:	f109 39ff 	add.w	r9, r9, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 80020f6:	4642      	mov	r2, r8
 80020f8:	2301      	movs	r3, #1
 80020fa:	4639      	mov	r1, r7
 80020fc:	f7ff f8f2 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002100:	f1b9 0f01 	cmp.w	r9, #1
 8002104:	d1f2      	bne.n	80020ec <get_fat.isra.10+0x150>
 8002106:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002108:	2301      	movs	r3, #1
 800210a:	462a      	mov	r2, r5
 800210c:	4639      	mov	r1, r7
 800210e:	f7ff f8db 	bl	80012c8 <disk_read>
 8002112:	2800      	cmp	r0, #0
 8002114:	d161      	bne.n	80021da <get_fat.isra.10+0x23e>
			fs->winsect = sector;
 8002116:	62f5      	str	r5, [r6, #44]	; 0x2c
 8002118:	e780      	b.n	800201c <get_fat.isra.10+0x80>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800211a:	78c2      	ldrb	r2, [r0, #3]
 800211c:	7840      	ldrb	r0, [r0, #1]
 800211e:	f106 0930 	add.w	r9, r6, #48	; 0x30
 8002122:	b302      	cbz	r2, 8002166 <get_fat.isra.10+0x1ca>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8002124:	4642      	mov	r2, r8
 8002126:	4649      	mov	r1, r9
 8002128:	f7ff f8dc 	bl	80012e4 <disk_write>
 800212c:	2800      	cmp	r0, #0
 800212e:	d158      	bne.n	80021e2 <get_fat.isra.10+0x246>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002130:	6a32      	ldr	r2, [r6, #32]
 8002132:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 8002134:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002136:	eba8 0202 	sub.w	r2, r8, r2
 800213a:	429a      	cmp	r2, r3
 800213c:	d212      	bcs.n	8002164 <get_fat.isra.10+0x1c8>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800213e:	f896 a002 	ldrb.w	sl, [r6, #2]
 8002142:	f1ba 0f01 	cmp.w	sl, #1
 8002146:	d801      	bhi.n	800214c <get_fat.isra.10+0x1b0>
 8002148:	e00c      	b.n	8002164 <get_fat.isra.10+0x1c8>
 800214a:	69b3      	ldr	r3, [r6, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 800214c:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 800214e:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002150:	f10a 3aff 	add.w	sl, sl, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8002154:	4642      	mov	r2, r8
 8002156:	2301      	movs	r3, #1
 8002158:	4649      	mov	r1, r9
 800215a:	f7ff f8c3 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800215e:	f1ba 0f01 	cmp.w	sl, #1
 8002162:	d1f2      	bne.n	800214a <get_fat.isra.10+0x1ae>
 8002164:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002166:	4649      	mov	r1, r9
 8002168:	2301      	movs	r3, #1
 800216a:	463a      	mov	r2, r7
 800216c:	f7ff f8ac 	bl	80012c8 <disk_read>
 8002170:	bb98      	cbnz	r0, 80021da <get_fat.isra.10+0x23e>
 8002172:	6a32      	ldr	r2, [r6, #32]
			fs->winsect = sector;
 8002174:	62f7      	str	r7, [r6, #44]	; 0x2c
 8002176:	46b8      	mov	r8, r7
 8002178:	e72a      	b.n	8001fd0 <get_fat.isra.10+0x34>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800217a:	78f3      	ldrb	r3, [r6, #3]
 800217c:	7870      	ldrb	r0, [r6, #1]
 800217e:	f106 0a30 	add.w	sl, r6, #48	; 0x30
 8002182:	b30b      	cbz	r3, 80021c8 <get_fat.isra.10+0x22c>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8002184:	2301      	movs	r3, #1
 8002186:	4642      	mov	r2, r8
 8002188:	4651      	mov	r1, sl
 800218a:	f7ff f8ab 	bl	80012e4 <disk_write>
 800218e:	bb40      	cbnz	r0, 80021e2 <get_fat.isra.10+0x246>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002190:	6a32      	ldr	r2, [r6, #32]
 8002192:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 8002194:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002196:	eba8 0202 	sub.w	r2, r8, r2
 800219a:	429a      	cmp	r2, r3
 800219c:	7870      	ldrb	r0, [r6, #1]
 800219e:	d213      	bcs.n	80021c8 <get_fat.isra.10+0x22c>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80021a0:	f896 b002 	ldrb.w	fp, [r6, #2]
 80021a4:	f1bb 0f01 	cmp.w	fp, #1
 80021a8:	d802      	bhi.n	80021b0 <get_fat.isra.10+0x214>
 80021aa:	e00d      	b.n	80021c8 <get_fat.isra.10+0x22c>
 80021ac:	69b3      	ldr	r3, [r6, #24]
 80021ae:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 80021b0:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80021b2:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 80021b6:	4642      	mov	r2, r8
 80021b8:	2301      	movs	r3, #1
 80021ba:	4651      	mov	r1, sl
 80021bc:	f7ff f892 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80021c0:	f1bb 0f01 	cmp.w	fp, #1
 80021c4:	d1f2      	bne.n	80021ac <get_fat.isra.10+0x210>
 80021c6:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80021c8:	4651      	mov	r1, sl
 80021ca:	2301      	movs	r3, #1
 80021cc:	464a      	mov	r2, r9
 80021ce:	f7ff f87b 	bl	80012c8 <disk_read>
 80021d2:	b910      	cbnz	r0, 80021da <get_fat.isra.10+0x23e>
			fs->winsect = sector;
 80021d4:	f8c6 902c 	str.w	r9, [r6, #44]	; 0x2c
 80021d8:	e705      	b.n	8001fe6 <get_fat.isra.10+0x4a>
 80021da:	f04f 30ff 	mov.w	r0, #4294967295
 80021de:	62f0      	str	r0, [r6, #44]	; 0x2c
 80021e0:	e70f      	b.n	8002002 <get_fat.isra.10+0x66>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 80021e2:	f04f 30ff 	mov.w	r0, #4294967295
 80021e6:	e70c      	b.n	8002002 <get_fat.isra.10+0x66>

080021e8 <create_chain>:
{
 80021e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80021ec:	b087      	sub	sp, #28
 80021ee:	4682      	mov	sl, r0
	if (clst == 0) {	/* Create a new chain */
 80021f0:	9101      	str	r1, [sp, #4]
	FATFS *fs = obj->fs;
 80021f2:	f8d0 b000 	ldr.w	fp, [r0]
	if (clst == 0) {	/* Create a new chain */
 80021f6:	2900      	cmp	r1, #0
 80021f8:	f040 815e 	bne.w	80024b8 <create_chain+0x2d0>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
 80021fc:	f8db 800c 	ldr.w	r8, [fp, #12]
 8002200:	f8db 3014 	ldr.w	r3, [fp, #20]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8002204:	f1b8 0f00 	cmp.w	r8, #0
 8002208:	d11d      	bne.n	8002246 <create_chain+0x5e>
 800220a:	f04f 0801 	mov.w	r8, #1
 800220e:	4644      	mov	r4, r8
			ncl++;							/* Next cluster */
 8002210:	3401      	adds	r4, #1
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8002212:	429c      	cmp	r4, r3
 8002214:	d31c      	bcc.n	8002250 <create_chain+0x68>
				if (ncl > scl) return 0;	/* No free cluster */
 8002216:	f1b8 0f01 	cmp.w	r8, #1
 800221a:	f240 8173 	bls.w	8002504 <create_chain+0x31c>
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 800221e:	f8da 5000 	ldr.w	r5, [sl]
				ncl = 2;
 8002222:	2402      	movs	r4, #2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8002224:	696b      	ldr	r3, [r5, #20]
 8002226:	42a3      	cmp	r3, r4
 8002228:	d908      	bls.n	800223c <create_chain+0x54>
		switch (fs->fs_type) {
 800222a:	782b      	ldrb	r3, [r5, #0]
 800222c:	2b02      	cmp	r3, #2
 800222e:	f000 80fb 	beq.w	8002428 <create_chain+0x240>
 8002232:	2b03      	cmp	r3, #3
 8002234:	f000 80af 	beq.w	8002396 <create_chain+0x1ae>
 8002238:	2b01      	cmp	r3, #1
 800223a:	d00e      	beq.n	800225a <create_chain+0x72>
 800223c:	2401      	movs	r4, #1
}
 800223e:	4620      	mov	r0, r4
 8002240:	b007      	add	sp, #28
 8002242:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8002246:	4598      	cmp	r8, r3
 8002248:	bf28      	it	cs
 800224a:	f04f 0801 	movcs.w	r8, #1
 800224e:	e7de      	b.n	800220e <create_chain+0x26>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8002250:	2c01      	cmp	r4, #1
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 8002252:	f8da 5000 	ldr.w	r5, [sl]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8002256:	d9f1      	bls.n	800223c <create_chain+0x54>
 8002258:	e7e4      	b.n	8002224 <create_chain+0x3c>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800225a:	6a2a      	ldr	r2, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800225c:	f8d5 902c 	ldr.w	r9, [r5, #44]	; 0x2c
			bc = (UINT)clst; bc += bc / 2;
 8002260:	eb04 0654 	add.w	r6, r4, r4, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8002264:	eb02 2756 	add.w	r7, r2, r6, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002268:	454f      	cmp	r7, r9
 800226a:	d036      	beq.n	80022da <create_chain+0xf2>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800226c:	78ea      	ldrb	r2, [r5, #3]
 800226e:	7868      	ldrb	r0, [r5, #1]
 8002270:	f105 0130 	add.w	r1, r5, #48	; 0x30
 8002274:	9102      	str	r1, [sp, #8]
 8002276:	b332      	cbz	r2, 80022c6 <create_chain+0xde>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8002278:	464a      	mov	r2, r9
 800227a:	f7ff f833 	bl	80012e4 <disk_write>
 800227e:	2800      	cmp	r0, #0
 8002280:	f040 813a 	bne.w	80024f8 <create_chain+0x310>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002284:	6a2a      	ldr	r2, [r5, #32]
 8002286:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8002288:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800228a:	eba9 0202 	sub.w	r2, r9, r2
 800228e:	429a      	cmp	r2, r3
 8002290:	d217      	bcs.n	80022c2 <create_chain+0xda>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002292:	78aa      	ldrb	r2, [r5, #2]
 8002294:	2a01      	cmp	r2, #1
 8002296:	d914      	bls.n	80022c2 <create_chain+0xda>
 8002298:	f8cd 800c 	str.w	r8, [sp, #12]
 800229c:	9404      	str	r4, [sp, #16]
 800229e:	4690      	mov	r8, r2
 80022a0:	9c02      	ldr	r4, [sp, #8]
 80022a2:	e000      	b.n	80022a6 <create_chain+0xbe>
 80022a4:	69ab      	ldr	r3, [r5, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 80022a6:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 80022a8:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80022aa:	f108 38ff 	add.w	r8, r8, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 80022ae:	464a      	mov	r2, r9
 80022b0:	2301      	movs	r3, #1
 80022b2:	4621      	mov	r1, r4
 80022b4:	f7ff f816 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80022b8:	f1b8 0f01 	cmp.w	r8, #1
 80022bc:	d1f2      	bne.n	80022a4 <create_chain+0xbc>
 80022be:	e9dd 8403 	ldrd	r8, r4, [sp, #12]
 80022c2:	7868      	ldrb	r0, [r5, #1]
 80022c4:	9902      	ldr	r1, [sp, #8]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80022c6:	2301      	movs	r3, #1
 80022c8:	463a      	mov	r2, r7
 80022ca:	f7fe fffd 	bl	80012c8 <disk_read>
 80022ce:	2800      	cmp	r0, #0
 80022d0:	f040 80e1 	bne.w	8002496 <create_chain+0x2ae>
 80022d4:	6a2a      	ldr	r2, [r5, #32]
			fs->winsect = sector;
 80022d6:	62ef      	str	r7, [r5, #44]	; 0x2c
 80022d8:	46b9      	mov	r9, r7
			wc = fs->win[bc++ % SS(fs)];
 80022da:	f3c6 0308 	ubfx	r3, r6, #0, #9
 80022de:	3601      	adds	r6, #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80022e0:	eb02 2256 	add.w	r2, r2, r6, lsr #9
			wc = fs->win[bc++ % SS(fs)];
 80022e4:	442b      	add	r3, r5
	if (sector != fs->winsect) {	/* Window offset changed? */
 80022e6:	454a      	cmp	r2, r9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80022e8:	9202      	str	r2, [sp, #8]
			wc = fs->win[bc++ % SS(fs)];
 80022ea:	f893 7030 	ldrb.w	r7, [r3, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 80022ee:	d03a      	beq.n	8002366 <create_chain+0x17e>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80022f0:	78eb      	ldrb	r3, [r5, #3]
 80022f2:	7868      	ldrb	r0, [r5, #1]
 80022f4:	f105 0230 	add.w	r2, r5, #48	; 0x30
 80022f8:	4611      	mov	r1, r2
 80022fa:	9203      	str	r2, [sp, #12]
 80022fc:	b34b      	cbz	r3, 8002352 <create_chain+0x16a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80022fe:	2301      	movs	r3, #1
 8002300:	464a      	mov	r2, r9
 8002302:	f7fe ffef 	bl	80012e4 <disk_write>
 8002306:	2800      	cmp	r0, #0
 8002308:	f040 80f6 	bne.w	80024f8 <create_chain+0x310>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800230c:	6a2a      	ldr	r2, [r5, #32]
 800230e:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8002310:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002312:	eba9 0202 	sub.w	r2, r9, r2
 8002316:	429a      	cmp	r2, r3
 8002318:	7868      	ldrb	r0, [r5, #1]
 800231a:	d21a      	bcs.n	8002352 <create_chain+0x16a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800231c:	f895 c002 	ldrb.w	ip, [r5, #2]
 8002320:	4662      	mov	r2, ip
 8002322:	2a01      	cmp	r2, #1
 8002324:	d915      	bls.n	8002352 <create_chain+0x16a>
 8002326:	f8cd 8010 	str.w	r8, [sp, #16]
 800232a:	9405      	str	r4, [sp, #20]
 800232c:	46e0      	mov	r8, ip
 800232e:	9c03      	ldr	r4, [sp, #12]
 8002330:	e001      	b.n	8002336 <create_chain+0x14e>
 8002332:	69ab      	ldr	r3, [r5, #24]
 8002334:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8002336:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002338:	f108 38ff 	add.w	r8, r8, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 800233c:	464a      	mov	r2, r9
 800233e:	2301      	movs	r3, #1
 8002340:	4621      	mov	r1, r4
 8002342:	f7fe ffcf 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002346:	f1b8 0f01 	cmp.w	r8, #1
 800234a:	d1f2      	bne.n	8002332 <create_chain+0x14a>
 800234c:	e9dd 8404 	ldrd	r8, r4, [sp, #16]
 8002350:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002352:	9903      	ldr	r1, [sp, #12]
 8002354:	9a02      	ldr	r2, [sp, #8]
 8002356:	2301      	movs	r3, #1
 8002358:	f7fe ffb6 	bl	80012c8 <disk_read>
 800235c:	2800      	cmp	r0, #0
 800235e:	f040 809a 	bne.w	8002496 <create_chain+0x2ae>
			fs->winsect = sector;
 8002362:	9b02      	ldr	r3, [sp, #8]
 8002364:	62eb      	str	r3, [r5, #44]	; 0x2c
			wc |= fs->win[bc % SS(fs)] << 8;
 8002366:	f3c6 0608 	ubfx	r6, r6, #0, #9
 800236a:	4435      	add	r5, r6
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800236c:	07e2      	lsls	r2, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 800236e:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
 8002372:	ea47 2303 	orr.w	r3, r7, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8002376:	bf4c      	ite	mi
 8002378:	091b      	lsrmi	r3, r3, #4
 800237a:	f3c3 030b 	ubfxpl	r3, r3, #0, #12
			if (cs == 0) break;				/* Found a free cluster */
 800237e:	2b00      	cmp	r3, #0
 8002380:	f000 80ab 	beq.w	80024da <create_chain+0x2f2>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
 8002384:	2b01      	cmp	r3, #1
 8002386:	f43f af59 	beq.w	800223c <create_chain+0x54>
			if (ncl == scl) return 0;		/* No free cluster */
 800238a:	45a0      	cmp	r8, r4
 800238c:	f000 80ba 	beq.w	8002504 <create_chain+0x31c>
 8002390:	f8db 3014 	ldr.w	r3, [fp, #20]
 8002394:	e73c      	b.n	8002210 <create_chain+0x28>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8002396:	6a2e      	ldr	r6, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002398:	f8d5 902c 	ldr.w	r9, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800239c:	eb06 16d4 	add.w	r6, r6, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 80023a0:	454e      	cmp	r6, r9
 80023a2:	f105 0730 	add.w	r7, r5, #48	; 0x30
 80023a6:	d031      	beq.n	800240c <create_chain+0x224>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80023a8:	78eb      	ldrb	r3, [r5, #3]
 80023aa:	7868      	ldrb	r0, [r5, #1]
 80023ac:	b333      	cbz	r3, 80023fc <create_chain+0x214>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80023ae:	2301      	movs	r3, #1
 80023b0:	464a      	mov	r2, r9
 80023b2:	4639      	mov	r1, r7
 80023b4:	f7fe ff96 	bl	80012e4 <disk_write>
 80023b8:	2800      	cmp	r0, #0
 80023ba:	f040 809d 	bne.w	80024f8 <create_chain+0x310>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80023be:	6a2a      	ldr	r2, [r5, #32]
 80023c0:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 80023c2:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80023c4:	eba9 0202 	sub.w	r2, r9, r2
 80023c8:	429a      	cmp	r2, r3
 80023ca:	7868      	ldrb	r0, [r5, #1]
 80023cc:	d216      	bcs.n	80023fc <create_chain+0x214>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80023ce:	78aa      	ldrb	r2, [r5, #2]
 80023d0:	2a01      	cmp	r2, #1
 80023d2:	d913      	bls.n	80023fc <create_chain+0x214>
 80023d4:	f8cd 8008 	str.w	r8, [sp, #8]
 80023d8:	4690      	mov	r8, r2
 80023da:	e001      	b.n	80023e0 <create_chain+0x1f8>
 80023dc:	69ab      	ldr	r3, [r5, #24]
 80023de:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 80023e0:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80023e2:	f108 38ff 	add.w	r8, r8, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 80023e6:	464a      	mov	r2, r9
 80023e8:	2301      	movs	r3, #1
 80023ea:	4639      	mov	r1, r7
 80023ec:	f7fe ff7a 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80023f0:	f1b8 0f01 	cmp.w	r8, #1
 80023f4:	d1f2      	bne.n	80023dc <create_chain+0x1f4>
 80023f6:	f8dd 8008 	ldr.w	r8, [sp, #8]
 80023fa:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80023fc:	2301      	movs	r3, #1
 80023fe:	4632      	mov	r2, r6
 8002400:	4639      	mov	r1, r7
 8002402:	f7fe ff61 	bl	80012c8 <disk_read>
 8002406:	2800      	cmp	r0, #0
 8002408:	d145      	bne.n	8002496 <create_chain+0x2ae>
			fs->winsect = sector;
 800240a:	62ee      	str	r6, [r5, #44]	; 0x2c
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800240c:	00a3      	lsls	r3, r4, #2
 800240e:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 8002412:	18f9      	adds	r1, r7, r3
	rv = rv << 8 | ptr[0];
 8002414:	5cfb      	ldrb	r3, [r7, r3]
	rv = rv << 8 | ptr[2];
 8002416:	8848      	ldrh	r0, [r1, #2]
	rv = rv << 8 | ptr[1];
 8002418:	784a      	ldrb	r2, [r1, #1]
 800241a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 800241e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8002422:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8002426:	e7aa      	b.n	800237e <create_chain+0x196>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8002428:	6a2e      	ldr	r6, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800242a:	f8d5 902c 	ldr.w	r9, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800242e:	eb06 2614 	add.w	r6, r6, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002432:	454e      	cmp	r6, r9
 8002434:	f105 0730 	add.w	r7, r5, #48	; 0x30
 8002438:	d035      	beq.n	80024a6 <create_chain+0x2be>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800243a:	78eb      	ldrb	r3, [r5, #3]
 800243c:	7868      	ldrb	r0, [r5, #1]
 800243e:	b323      	cbz	r3, 800248a <create_chain+0x2a2>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8002440:	2301      	movs	r3, #1
 8002442:	464a      	mov	r2, r9
 8002444:	4639      	mov	r1, r7
 8002446:	f7fe ff4d 	bl	80012e4 <disk_write>
 800244a:	2800      	cmp	r0, #0
 800244c:	d154      	bne.n	80024f8 <create_chain+0x310>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800244e:	6a2a      	ldr	r2, [r5, #32]
 8002450:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8002452:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002454:	eba9 0202 	sub.w	r2, r9, r2
 8002458:	429a      	cmp	r2, r3
 800245a:	d215      	bcs.n	8002488 <create_chain+0x2a0>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800245c:	78aa      	ldrb	r2, [r5, #2]
 800245e:	2a01      	cmp	r2, #1
 8002460:	d912      	bls.n	8002488 <create_chain+0x2a0>
 8002462:	f8cd 8008 	str.w	r8, [sp, #8]
 8002466:	4690      	mov	r8, r2
 8002468:	e000      	b.n	800246c <create_chain+0x284>
 800246a:	69ab      	ldr	r3, [r5, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 800246c:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 800246e:	4499      	add	r9, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002470:	f108 38ff 	add.w	r8, r8, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8002474:	464a      	mov	r2, r9
 8002476:	2301      	movs	r3, #1
 8002478:	4639      	mov	r1, r7
 800247a:	f7fe ff33 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800247e:	f1b8 0f01 	cmp.w	r8, #1
 8002482:	d1f2      	bne.n	800246a <create_chain+0x282>
 8002484:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8002488:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800248a:	2301      	movs	r3, #1
 800248c:	4632      	mov	r2, r6
 800248e:	4639      	mov	r1, r7
 8002490:	f7fe ff1a 	bl	80012c8 <disk_read>
 8002494:	b130      	cbz	r0, 80024a4 <create_chain+0x2bc>
			fs->winsect = sector;
 8002496:	f04f 34ff 	mov.w	r4, #4294967295
}
 800249a:	4620      	mov	r0, r4
			fs->winsect = sector;
 800249c:	62ec      	str	r4, [r5, #44]	; 0x2c
}
 800249e:	b007      	add	sp, #28
 80024a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fs->winsect = sector;
 80024a4:	62ee      	str	r6, [r5, #44]	; 0x2c
			val = ld_word(fs->win + clst * 2 % SS(fs));
 80024a6:	0063      	lsls	r3, r4, #1
 80024a8:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 80024ac:	18fa      	adds	r2, r7, r3
	rv = rv << 8 | ptr[0];
 80024ae:	5cfb      	ldrb	r3, [r7, r3]
 80024b0:	7852      	ldrb	r2, [r2, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 80024b2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80024b6:	e762      	b.n	800237e <create_chain+0x196>
		cs = get_fat(obj, clst);			/* Check the cluster status */
 80024b8:	4658      	mov	r0, fp
 80024ba:	f7ff fd6f 	bl	8001f9c <get_fat.isra.10>
		if (cs < 2) return 1;				/* Invalid FAT value */
 80024be:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
 80024c0:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Invalid FAT value */
 80024c2:	f67f aebb 	bls.w	800223c <create_chain+0x54>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 80024c6:	1c41      	adds	r1, r0, #1
 80024c8:	d016      	beq.n	80024f8 <create_chain+0x310>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 80024ca:	f8db 3014 	ldr.w	r3, [fp, #20]
 80024ce:	4283      	cmp	r3, r0
 80024d0:	f63f aeb5 	bhi.w	800223e <create_chain+0x56>
 80024d4:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80024d8:	e699      	b.n	800220e <create_chain+0x26>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 80024da:	f8db 3014 	ldr.w	r3, [fp, #20]
 80024de:	42a3      	cmp	r3, r4
 80024e0:	f67f aeac 	bls.w	800223c <create_chain+0x54>
 80024e4:	f04f 32ff 	mov.w	r2, #4294967295
 80024e8:	4621      	mov	r1, r4
 80024ea:	4658      	mov	r0, fp
 80024ec:	f7fe ffc8 	bl	8001480 <put_fat.part.9>
		if (res == FR_OK && clst != 0) {
 80024f0:	b168      	cbz	r0, 800250e <create_chain+0x326>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 80024f2:	2801      	cmp	r0, #1
 80024f4:	f47f aea2 	bne.w	800223c <create_chain+0x54>
 80024f8:	f04f 34ff 	mov.w	r4, #4294967295
}
 80024fc:	4620      	mov	r0, r4
 80024fe:	b007      	add	sp, #28
 8002500:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (ncl > scl) return 0;	/* No free cluster */
 8002504:	2400      	movs	r4, #0
}
 8002506:	4620      	mov	r0, r4
 8002508:	b007      	add	sp, #28
 800250a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (res == FR_OK && clst != 0) {
 800250e:	9b01      	ldr	r3, [sp, #4]
 8002510:	b17b      	cbz	r3, 8002532 <create_chain+0x34a>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8002512:	2b01      	cmp	r3, #1
 8002514:	461a      	mov	r2, r3
 8002516:	f67f ae91 	bls.w	800223c <create_chain+0x54>
 800251a:	f8db 3014 	ldr.w	r3, [fp, #20]
 800251e:	429a      	cmp	r2, r3
 8002520:	f4bf ae8c 	bcs.w	800223c <create_chain+0x54>
 8002524:	4611      	mov	r1, r2
 8002526:	4658      	mov	r0, fp
 8002528:	4622      	mov	r2, r4
 800252a:	f7fe ffa9 	bl	8001480 <put_fat.part.9>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 800252e:	2800      	cmp	r0, #0
 8002530:	d1df      	bne.n	80024f2 <create_chain+0x30a>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8002532:	e9db 2304 	ldrd	r2, r3, [fp, #16]
 8002536:	3b02      	subs	r3, #2
 8002538:	429a      	cmp	r2, r3
		fs->last_clst = ncl;
 800253a:	f8cb 400c 	str.w	r4, [fp, #12]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800253e:	d802      	bhi.n	8002546 <create_chain+0x35e>
 8002540:	3a01      	subs	r2, #1
 8002542:	f8cb 2010 	str.w	r2, [fp, #16]
		fs->fsi_flag |= 1;
 8002546:	f89b 3004 	ldrb.w	r3, [fp, #4]
 800254a:	f043 0301 	orr.w	r3, r3, #1
 800254e:	f88b 3004 	strb.w	r3, [fp, #4]
 8002552:	e674      	b.n	800223e <create_chain+0x56>

08002554 <dir_register>:

static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 8002554:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002558:	b089      	sub	sp, #36	; 0x24
 800255a:	4607      	mov	r7, r0
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 800255c:	6806      	ldr	r6, [r0, #0]
	res = dir_sdi(dp, 0);
 800255e:	f7ff fba7 	bl	8001cb0 <dir_sdi.constprop.14>
	if (res == FR_OK) {
 8002562:	4683      	mov	fp, r0
 8002564:	b138      	cbz	r0, 8002576 <dir_register+0x22>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8002566:	2804      	cmp	r0, #4
 8002568:	d101      	bne.n	800256e <dir_register+0x1a>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800256a:	f04f 0b07 	mov.w	fp, #7
			fs->wflag = 1;
		}
	}

	return res;
}
 800256e:	4658      	mov	r0, fp
 8002570:	b009      	add	sp, #36	; 0x24
 8002572:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002576:	f8d7 801c 	ldr.w	r8, [r7, #28]
 800257a:	f8d6 a02c 	ldr.w	sl, [r6, #44]	; 0x2c
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800257e:	9002      	str	r0, [sp, #8]
 8002580:	f106 0330 	add.w	r3, r6, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002584:	45c2      	cmp	sl, r8
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002586:	469b      	mov	fp, r3
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002588:	f000 8090 	beq.w	80026ac <dir_register+0x158>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800258c:	78f3      	ldrb	r3, [r6, #3]
 800258e:	7870      	ldrb	r0, [r6, #1]
 8002590:	b1fb      	cbz	r3, 80025d2 <dir_register+0x7e>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8002592:	2301      	movs	r3, #1
 8002594:	4652      	mov	r2, sl
 8002596:	4659      	mov	r1, fp
 8002598:	f7fe fea4 	bl	80012e4 <disk_write>
 800259c:	2800      	cmp	r0, #0
 800259e:	f040 8087 	bne.w	80026b0 <dir_register+0x15c>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80025a2:	6a32      	ldr	r2, [r6, #32]
 80025a4:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 80025a6:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80025a8:	ebaa 0202 	sub.w	r2, sl, r2
 80025ac:	429a      	cmp	r2, r3
 80025ae:	7870      	ldrb	r0, [r6, #1]
 80025b0:	d20f      	bcs.n	80025d2 <dir_register+0x7e>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80025b2:	78b4      	ldrb	r4, [r6, #2]
 80025b4:	2c01      	cmp	r4, #1
 80025b6:	d802      	bhi.n	80025be <dir_register+0x6a>
 80025b8:	e00b      	b.n	80025d2 <dir_register+0x7e>
 80025ba:	69b3      	ldr	r3, [r6, #24]
 80025bc:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 80025be:	449a      	add	sl, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80025c0:	3c01      	subs	r4, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 80025c2:	4652      	mov	r2, sl
 80025c4:	2301      	movs	r3, #1
 80025c6:	4659      	mov	r1, fp
 80025c8:	f7fe fe8c 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80025cc:	2c01      	cmp	r4, #1
 80025ce:	d1f4      	bne.n	80025ba <dir_register+0x66>
 80025d0:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80025d2:	2301      	movs	r3, #1
 80025d4:	4642      	mov	r2, r8
 80025d6:	4659      	mov	r1, fp
 80025d8:	f7fe fe76 	bl	80012c8 <disk_read>
 80025dc:	2800      	cmp	r0, #0
 80025de:	d139      	bne.n	8002654 <dir_register+0x100>
 80025e0:	69fb      	ldr	r3, [r7, #28]
			fs->winsect = sector;
 80025e2:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 80025e6:	6a38      	ldr	r0, [r7, #32]
 80025e8:	7802      	ldrb	r2, [r0, #0]
 80025ea:	2ae5      	cmp	r2, #229	; 0xe5
 80025ec:	d001      	beq.n	80025f2 <dir_register+0x9e>
 80025ee:	2a00      	cmp	r2, #0
 80025f0:	d139      	bne.n	8002666 <dir_register+0x112>
	if (sector != fs->winsect) {	/* Window offset changed? */
 80025f2:	4543      	cmp	r3, r8
 80025f4:	4699      	mov	r9, r3
 80025f6:	f8dd b008 	ldr.w	fp, [sp, #8]
 80025fa:	f000 808b 	beq.w	8002714 <dir_register+0x1c0>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80025fe:	78f3      	ldrb	r3, [r6, #3]
 8002600:	7870      	ldrb	r0, [r6, #1]
 8002602:	f106 0430 	add.w	r4, r6, #48	; 0x30
 8002606:	b1f3      	cbz	r3, 8002646 <dir_register+0xf2>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8002608:	2301      	movs	r3, #1
 800260a:	4642      	mov	r2, r8
 800260c:	4621      	mov	r1, r4
 800260e:	f7fe fe69 	bl	80012e4 <disk_write>
 8002612:	2800      	cmp	r0, #0
 8002614:	d14c      	bne.n	80026b0 <dir_register+0x15c>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002616:	6a32      	ldr	r2, [r6, #32]
 8002618:	69b3      	ldr	r3, [r6, #24]
			fs->wflag = 0;
 800261a:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800261c:	eba8 0202 	sub.w	r2, r8, r2
 8002620:	429a      	cmp	r2, r3
 8002622:	7870      	ldrb	r0, [r6, #1]
 8002624:	d20f      	bcs.n	8002646 <dir_register+0xf2>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002626:	78b5      	ldrb	r5, [r6, #2]
 8002628:	2d01      	cmp	r5, #1
 800262a:	d802      	bhi.n	8002632 <dir_register+0xde>
 800262c:	e00b      	b.n	8002646 <dir_register+0xf2>
 800262e:	69b3      	ldr	r3, [r6, #24]
 8002630:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 8002632:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002634:	3d01      	subs	r5, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 8002636:	4642      	mov	r2, r8
 8002638:	2301      	movs	r3, #1
 800263a:	4621      	mov	r1, r4
 800263c:	f7fe fe52 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002640:	2d01      	cmp	r5, #1
 8002642:	d1f4      	bne.n	800262e <dir_register+0xda>
 8002644:	7870      	ldrb	r0, [r6, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002646:	4621      	mov	r1, r4
 8002648:	2301      	movs	r3, #1
 800264a:	464a      	mov	r2, r9
 800264c:	f7fe fe3c 	bl	80012c8 <disk_read>
 8002650:	2800      	cmp	r0, #0
 8002652:	d05c      	beq.n	800270e <dir_register+0x1ba>
				res = FR_DISK_ERR;
 8002654:	f04f 0b01 	mov.w	fp, #1
			fs->winsect = sector;
 8002658:	f04f 33ff 	mov.w	r3, #4294967295
}
 800265c:	4658      	mov	r0, fp
			fs->winsect = sector;
 800265e:	62f3      	str	r3, [r6, #44]	; 0x2c
}
 8002660:	b009      	add	sp, #36	; 0x24
 8002662:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8002666:	2b00      	cmp	r3, #0
 8002668:	f43f af7f 	beq.w	800256a <dir_register+0x16>
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800266c:	697c      	ldr	r4, [r7, #20]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800266e:	4a91      	ldr	r2, [pc, #580]	; (80028b4 <dir_register+0x360>)
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8002670:	3420      	adds	r4, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8002672:	4294      	cmp	r4, r2
 8002674:	f63f af79 	bhi.w	800256a <dir_register+0x16>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8002678:	f3c4 0908 	ubfx	r9, r4, #0, #9
	FATFS *fs = dp->obj.fs;
 800267c:	683d      	ldr	r5, [r7, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800267e:	f1b9 0f00 	cmp.w	r9, #0
 8002682:	d107      	bne.n	8002694 <dir_register+0x140>
		if (!dp->clust) {		/* Static table */
 8002684:	69b9      	ldr	r1, [r7, #24]
		dp->sect++;				/* Next sector */
 8002686:	3301      	adds	r3, #1
 8002688:	61fb      	str	r3, [r7, #28]
		if (!dp->clust) {		/* Static table */
 800268a:	b9a1      	cbnz	r1, 80026b6 <dir_register+0x162>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800268c:	892a      	ldrh	r2, [r5, #8]
 800268e:	ebb2 1f54 	cmp.w	r2, r4, lsr #5
 8002692:	d95d      	bls.n	8002750 <dir_register+0x1fc>
 8002694:	f105 0230 	add.w	r2, r5, #48	; 0x30
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 8002698:	46c2      	mov	sl, r8
 800269a:	9201      	str	r2, [sp, #4]
 800269c:	4698      	mov	r8, r3
 800269e:	4613      	mov	r3, r2
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 80026a0:	444b      	add	r3, r9
	if (sector != fs->winsect) {	/* Window offset changed? */
 80026a2:	45c2      	cmp	sl, r8
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 80026a4:	623b      	str	r3, [r7, #32]
	dp->dptr = ofs;						/* Current entry */
 80026a6:	617c      	str	r4, [r7, #20]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80026a8:	f47f af70 	bne.w	800258c <dir_register+0x38>
 80026ac:	4643      	mov	r3, r8
 80026ae:	e79a      	b.n	80025e6 <dir_register+0x92>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 80026b0:	f04f 0b01 	mov.w	fp, #1
 80026b4:	e75b      	b.n	800256e <dir_register+0x1a>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 80026b6:	896a      	ldrh	r2, [r5, #10]
 80026b8:	3a01      	subs	r2, #1
 80026ba:	ea12 2254 	ands.w	r2, r2, r4, lsr #9
 80026be:	d1e9      	bne.n	8002694 <dir_register+0x140>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 80026c0:	4628      	mov	r0, r5
 80026c2:	f7ff fc6b 	bl	8001f9c <get_fat.isra.10>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 80026c6:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 80026c8:	4680      	mov	r8, r0
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 80026ca:	f240 80c9 	bls.w	8002860 <dir_register+0x30c>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 80026ce:	f1b0 3fff 	cmp.w	r0, #4294967295
 80026d2:	d0ed      	beq.n	80026b0 <dir_register+0x15c>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 80026d4:	696a      	ldr	r2, [r5, #20]
 80026d6:	4290      	cmp	r0, r2
 80026d8:	d257      	bcs.n	800278a <dir_register+0x236>
 80026da:	1e83      	subs	r3, r0, #2
 80026dc:	9303      	str	r3, [sp, #12]
 80026de:	f105 0330 	add.w	r3, r5, #48	; 0x30
 80026e2:	3a02      	subs	r2, #2
 80026e4:	9301      	str	r3, [sp, #4]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80026e6:	9903      	ldr	r1, [sp, #12]
				dp->clust = clst;		/* Initialize data for new cluster */
 80026e8:	f8c7 8018 	str.w	r8, [r7, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80026ec:	4291      	cmp	r1, r2
 80026ee:	460b      	mov	r3, r1
	return clst * fs->csize + fs->database;
 80026f0:	bf3c      	itt	cc
 80026f2:	f8b5 800a 	ldrhcc.w	r8, [r5, #10]
 80026f6:	6aab      	ldrcc	r3, [r5, #40]	; 0x28
 80026f8:	f8d6 a02c 	ldr.w	sl, [r6, #44]	; 0x2c
 80026fc:	bf34      	ite	cc
 80026fe:	fb01 3808 	mlacc	r8, r1, r8, r3
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8002702:	f04f 0800 	movcs.w	r8, #0
				dp->sect = clust2sect(fs, clst);
 8002706:	f8c7 801c 	str.w	r8, [r7, #28]
 800270a:	9b01      	ldr	r3, [sp, #4]
 800270c:	e7c8      	b.n	80026a0 <dir_register+0x14c>
 800270e:	6a38      	ldr	r0, [r7, #32]
			fs->winsect = sector;
 8002710:	f8c6 902c 	str.w	r9, [r6, #44]	; 0x2c
 8002714:	2220      	movs	r2, #32
 8002716:	2100      	movs	r1, #0
 8002718:	f004 feba 	bl	8007490 <memset>
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 800271c:	6a3b      	ldr	r3, [r7, #32]
 800271e:	f107 0224 	add.w	r2, r7, #36	; 0x24
 8002722:	1d19      	adds	r1, r3, #4
 8002724:	428a      	cmp	r2, r1
 8002726:	d203      	bcs.n	8002730 <dir_register+0x1dc>
 8002728:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800272c:	4293      	cmp	r3, r2
 800272e:	d313      	bcc.n	8002758 <dir_register+0x204>
			*d++ = *s++;
 8002730:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002732:	601a      	str	r2, [r3, #0]
 8002734:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8002736:	605a      	str	r2, [r3, #4]
 8002738:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 800273c:	721a      	strb	r2, [r3, #8]
 800273e:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 8002742:	725a      	strb	r2, [r3, #9]
 8002744:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 8002748:	729a      	strb	r2, [r3, #10]
			fs->wflag = 1;
 800274a:	2301      	movs	r3, #1
 800274c:	70f3      	strb	r3, [r6, #3]
 800274e:	e70e      	b.n	800256e <dir_register+0x1a>
				dp->sect = 0; return FR_NO_FILE;
 8002750:	61f9      	str	r1, [r7, #28]
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8002752:	f04f 0b07 	mov.w	fp, #7
 8002756:	e70a      	b.n	800256e <dir_register+0x1a>
			*d++ = *s++;
 8002758:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
 800275c:	701a      	strb	r2, [r3, #0]
 800275e:	f897 2025 	ldrb.w	r2, [r7, #37]	; 0x25
 8002762:	705a      	strb	r2, [r3, #1]
 8002764:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 8002768:	709a      	strb	r2, [r3, #2]
 800276a:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800276e:	70da      	strb	r2, [r3, #3]
 8002770:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
 8002774:	711a      	strb	r2, [r3, #4]
 8002776:	f897 2029 	ldrb.w	r2, [r7, #41]	; 0x29
 800277a:	715a      	strb	r2, [r3, #5]
 800277c:	f897 202a 	ldrb.w	r2, [r7, #42]	; 0x2a
 8002780:	719a      	strb	r2, [r3, #6]
 8002782:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
 8002786:	71da      	strb	r2, [r3, #7]
 8002788:	e7d6      	b.n	8002738 <dir_register+0x1e4>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 800278a:	69b9      	ldr	r1, [r7, #24]
 800278c:	4638      	mov	r0, r7
 800278e:	f7ff fd2b 	bl	80021e8 <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8002792:	4680      	mov	r8, r0
 8002794:	2800      	cmp	r0, #0
 8002796:	f43f aee8 	beq.w	800256a <dir_register+0x16>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 800279a:	2801      	cmp	r0, #1
 800279c:	d060      	beq.n	8002860 <dir_register+0x30c>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800279e:	f1b0 3fff 	cmp.w	r0, #4294967295
 80027a2:	d085      	beq.n	80026b0 <dir_register+0x15c>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80027a4:	78eb      	ldrb	r3, [r5, #3]
 80027a6:	f105 0230 	add.w	r2, r5, #48	; 0x30
 80027aa:	9204      	str	r2, [sp, #16]
 80027ac:	9201      	str	r2, [sp, #4]
 80027ae:	2b00      	cmp	r3, #0
 80027b0:	d159      	bne.n	8002866 <dir_register+0x312>
 80027b2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80027b6:	2100      	movs	r1, #0
 80027b8:	9804      	ldr	r0, [sp, #16]
 80027ba:	f004 fe69 	bl	8007490 <memset>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80027be:	696b      	ldr	r3, [r5, #20]
 80027c0:	8969      	ldrh	r1, [r5, #10]
	clst -= 2;
 80027c2:	f1a8 0002 	sub.w	r0, r8, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80027c6:	1e9a      	subs	r2, r3, #2
 80027c8:	4290      	cmp	r0, r2
 80027ca:	4603      	mov	r3, r0
	return clst * fs->csize + fs->database;
 80027cc:	bf38      	it	cc
 80027ce:	6aab      	ldrcc	r3, [r5, #40]	; 0x28
	clst -= 2;
 80027d0:	9003      	str	r0, [sp, #12]
	return clst * fs->csize + fs->database;
 80027d2:	bf34      	ite	cc
 80027d4:	fb00 3a01 	mlacc	sl, r0, r1, r3
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80027d8:	f04f 0a00 	movcs.w	sl, #0
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 80027dc:	f8c5 a02c 	str.w	sl, [r5, #44]	; 0x2c
 80027e0:	2900      	cmp	r1, #0
 80027e2:	d039      	beq.n	8002858 <dir_register+0x304>
 80027e4:	2300      	movs	r3, #0
 80027e6:	e9cd 6405 	strd	r6, r4, [sp, #20]
 80027ea:	4654      	mov	r4, sl
 80027ec:	f8dd a010 	ldr.w	sl, [sp, #16]
 80027f0:	f8cd 901c 	str.w	r9, [sp, #28]
 80027f4:	4699      	mov	r9, r3
						fs->wflag = 1;
 80027f6:	f04f 0301 	mov.w	r3, #1
 80027fa:	70eb      	strb	r3, [r5, #3]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80027fc:	4622      	mov	r2, r4
 80027fe:	2301      	movs	r3, #1
 8002800:	4651      	mov	r1, sl
 8002802:	7868      	ldrb	r0, [r5, #1]
 8002804:	f7fe fd6e 	bl	80012e4 <disk_write>
 8002808:	2800      	cmp	r0, #0
 800280a:	f47f af51 	bne.w	80026b0 <dir_register+0x15c>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800280e:	6a2a      	ldr	r2, [r5, #32]
 8002810:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8002812:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002814:	1aa2      	subs	r2, r4, r2
 8002816:	429a      	cmp	r2, r3
 8002818:	d20e      	bcs.n	8002838 <dir_register+0x2e4>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800281a:	78ae      	ldrb	r6, [r5, #2]
 800281c:	2e01      	cmp	r6, #1
 800281e:	d801      	bhi.n	8002824 <dir_register+0x2d0>
 8002820:	e00a      	b.n	8002838 <dir_register+0x2e4>
 8002822:	69ab      	ldr	r3, [r5, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8002824:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8002826:	441c      	add	r4, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002828:	3e01      	subs	r6, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 800282a:	4622      	mov	r2, r4
 800282c:	2301      	movs	r3, #1
 800282e:	4651      	mov	r1, sl
 8002830:	f7fe fd58 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8002834:	2e01      	cmp	r6, #1
 8002836:	d1f4      	bne.n	8002822 <dir_register+0x2ce>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 8002838:	6aec      	ldr	r4, [r5, #44]	; 0x2c
 800283a:	896b      	ldrh	r3, [r5, #10]
 800283c:	f109 0901 	add.w	r9, r9, #1
 8002840:	3401      	adds	r4, #1
 8002842:	4599      	cmp	r9, r3
 8002844:	62ec      	str	r4, [r5, #44]	; 0x2c
 8002846:	d3d6      	bcc.n	80027f6 <dir_register+0x2a2>
 8002848:	696b      	ldr	r3, [r5, #20]
 800284a:	9e05      	ldr	r6, [sp, #20]
 800284c:	4649      	mov	r1, r9
 800284e:	46a2      	mov	sl, r4
 8002850:	f8dd 901c 	ldr.w	r9, [sp, #28]
 8002854:	9c06      	ldr	r4, [sp, #24]
 8002856:	1e9a      	subs	r2, r3, #2
					fs->winsect -= n;							/* Restore window offset */
 8002858:	ebaa 0301 	sub.w	r3, sl, r1
 800285c:	62eb      	str	r3, [r5, #44]	; 0x2c
 800285e:	e742      	b.n	80026e6 <dir_register+0x192>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8002860:	f04f 0b02 	mov.w	fp, #2
 8002864:	e683      	b.n	800256e <dir_register+0x1a>
		wsect = fs->winsect;	/* Current sector number */
 8002866:	f8d5 a02c 	ldr.w	sl, [r5, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800286a:	7868      	ldrb	r0, [r5, #1]
 800286c:	4611      	mov	r1, r2
 800286e:	2301      	movs	r3, #1
 8002870:	4652      	mov	r2, sl
 8002872:	f7fe fd37 	bl	80012e4 <disk_write>
 8002876:	2800      	cmp	r0, #0
 8002878:	f47f af1a 	bne.w	80026b0 <dir_register+0x15c>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800287c:	6a2a      	ldr	r2, [r5, #32]
 800287e:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8002880:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8002882:	ebaa 0202 	sub.w	r2, sl, r2
 8002886:	429a      	cmp	r2, r3
 8002888:	d293      	bcs.n	80027b2 <dir_register+0x25e>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800288a:	78aa      	ldrb	r2, [r5, #2]
 800288c:	9203      	str	r2, [sp, #12]
 800288e:	2a01      	cmp	r2, #1
 8002890:	d801      	bhi.n	8002896 <dir_register+0x342>
 8002892:	e78e      	b.n	80027b2 <dir_register+0x25e>
 8002894:	69ab      	ldr	r3, [r5, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8002896:	9904      	ldr	r1, [sp, #16]
 8002898:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 800289a:	449a      	add	sl, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800289c:	9b03      	ldr	r3, [sp, #12]
 800289e:	3b01      	subs	r3, #1
 80028a0:	9303      	str	r3, [sp, #12]
					disk_write(fs->drv, fs->win, wsect, 1);
 80028a2:	4652      	mov	r2, sl
 80028a4:	2301      	movs	r3, #1
 80028a6:	f7fe fd1d 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80028aa:	9b03      	ldr	r3, [sp, #12]
 80028ac:	2b01      	cmp	r3, #1
 80028ae:	d1f1      	bne.n	8002894 <dir_register+0x340>
 80028b0:	e77f      	b.n	80027b2 <dir_register+0x25e>
 80028b2:	bf00      	nop
 80028b4:	001fffff 	.word	0x001fffff

080028b8 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 80028b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80028bc:	b087      	sub	sp, #28
	FRESULT res;
	BYTE ns;
	_FDID *obj = &dp->obj;
	FATFS *fs = obj->fs;
 80028be:	6803      	ldr	r3, [r0, #0]
 80028c0:	9302      	str	r3, [sp, #8]
{
 80028c2:	4604      	mov	r4, r0
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
		obj->sclust = fs->cdir;				/* Start from current directory */
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 80028c4:	780b      	ldrb	r3, [r1, #0]
 80028c6:	2b2f      	cmp	r3, #47	; 0x2f
 80028c8:	4689      	mov	r9, r1
 80028ca:	f101 0101 	add.w	r1, r1, #1
 80028ce:	d0f9      	beq.n	80028c4 <follow_path+0xc>
 80028d0:	2b5c      	cmp	r3, #92	; 0x5c
 80028d2:	d0f7      	beq.n	80028c4 <follow_path+0xc>
		obj->sclust = 0;					/* Start from root directory */
 80028d4:	2300      	movs	r3, #0
 80028d6:	60a3      	str	r3, [r4, #8]
		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
	}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 80028d8:	f899 3000 	ldrb.w	r3, [r9]
 80028dc:	2b1f      	cmp	r3, #31
 80028de:	f240 8156 	bls.w	8002b8e <follow_path+0x2d6>
 80028e2:	f104 0324 	add.w	r3, r4, #36	; 0x24
 80028e6:	9303      	str	r3, [sp, #12]
		*d++ = (BYTE)val;
 80028e8:	2320      	movs	r3, #32
 80028ea:	f04f 3220 	mov.w	r2, #538976288	; 0x20202020
	si = i = 0; ni = 8;
 80028ee:	2000      	movs	r0, #0
		*d++ = (BYTE)val;
 80028f0:	6262      	str	r2, [r4, #36]	; 0x24
 80028f2:	62a2      	str	r2, [r4, #40]	; 0x28
 80028f4:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
 80028f8:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
 80028fc:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
	si = i = 0; ni = 8;
 8002900:	4602      	mov	r2, r0
 8002902:	f109 35ff 	add.w	r5, r9, #4294967295
 8002906:	2708      	movs	r7, #8
		c = (BYTE)p[si++];
 8002908:	f815 3f01 	ldrb.w	r3, [r5, #1]!
		if (c <= ' ') break; 			/* Break if end of the path name */
 800290c:	2b20      	cmp	r3, #32
		c = (BYTE)p[si++];
 800290e:	f102 0201 	add.w	r2, r2, #1
		if (c <= ' ') break; 			/* Break if end of the path name */
 8002912:	d91b      	bls.n	800294c <follow_path+0x94>
		if (c == '/' || c == '\\') {	/* Break if a separator is found */
 8002914:	2b2f      	cmp	r3, #47	; 0x2f
 8002916:	f000 8090 	beq.w	8002a3a <follow_path+0x182>
 800291a:	2b5c      	cmp	r3, #92	; 0x5c
 800291c:	f000 808d 	beq.w	8002a3a <follow_path+0x182>
		if (c == '.' || i >= ni) {		/* End of body or over size? */
 8002920:	2b2e      	cmp	r3, #46	; 0x2e
 8002922:	d007      	beq.n	8002934 <follow_path+0x7c>
 8002924:	4287      	cmp	r7, r0
 8002926:	d86f      	bhi.n	8002a08 <follow_path+0x150>
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Over size or invalid dot */
 8002928:	2306      	movs	r3, #6
 800292a:	9301      	str	r3, [sp, #4]
			}
		}
	}

	return res;
}
 800292c:	9801      	ldr	r0, [sp, #4]
 800292e:	b007      	add	sp, #28
 8002930:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Over size or invalid dot */
 8002934:	2f0b      	cmp	r7, #11
 8002936:	d0f7      	beq.n	8002928 <follow_path+0x70>
		c = (BYTE)p[si++];
 8002938:	f815 3f01 	ldrb.w	r3, [r5, #1]!
		if (c <= ' ') break; 			/* Break if end of the path name */
 800293c:	2b20      	cmp	r3, #32
			i = 8; ni = 11;				/* Goto extension */
 800293e:	f04f 0008 	mov.w	r0, #8
 8002942:	f04f 070b 	mov.w	r7, #11
		c = (BYTE)p[si++];
 8002946:	f102 0201 	add.w	r2, r2, #1
		if (c <= ' ') break; 			/* Break if end of the path name */
 800294a:	d8e3      	bhi.n	8002914 <follow_path+0x5c>
 800294c:	4491      	add	r9, r2
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 800294e:	2800      	cmp	r0, #0
 8002950:	d0ea      	beq.n	8002928 <follow_path+0x70>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8002952:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
	FATFS *fs = dp->obj.fs;
 8002956:	f8d4 a000 	ldr.w	sl, [r4]
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800295a:	2ae5      	cmp	r2, #229	; 0xe5
 800295c:	bf04      	itt	eq
 800295e:	2205      	moveq	r2, #5
 8002960:	f884 2024 	strbeq.w	r2, [r4, #36]	; 0x24
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 8002964:	2b20      	cmp	r3, #32
 8002966:	bf8c      	ite	hi
 8002968:	2300      	movhi	r3, #0
 800296a:	2304      	movls	r3, #4
 800296c:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8002970:	4620      	mov	r0, r4
 8002972:	f7ff f99d 	bl	8001cb0 <dir_sdi.constprop.14>
	if (res != FR_OK) return res;
 8002976:	9001      	str	r0, [sp, #4]
 8002978:	2800      	cmp	r0, #0
 800297a:	f040 80c3 	bne.w	8002b04 <follow_path+0x24c>
 800297e:	69e5      	ldr	r5, [r4, #28]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8002980:	f8df 824c 	ldr.w	r8, [pc, #588]	; 8002bd0 <follow_path+0x318>
 8002984:	f10a 0b30 	add.w	fp, sl, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002988:	f8da 602c 	ldr.w	r6, [sl, #44]	; 0x2c
 800298c:	42ae      	cmp	r6, r5
 800298e:	d05f      	beq.n	8002a50 <follow_path+0x198>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8002990:	f89a 3003 	ldrb.w	r3, [sl, #3]
 8002994:	f89a 0001 	ldrb.w	r0, [sl, #1]
 8002998:	b333      	cbz	r3, 80029e8 <follow_path+0x130>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800299a:	2301      	movs	r3, #1
 800299c:	4632      	mov	r2, r6
 800299e:	4659      	mov	r1, fp
 80029a0:	f7fe fca0 	bl	80012e4 <disk_write>
 80029a4:	2800      	cmp	r0, #0
 80029a6:	f040 80d4 	bne.w	8002b52 <follow_path+0x29a>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80029aa:	f8da 2020 	ldr.w	r2, [sl, #32]
 80029ae:	f8da 3018 	ldr.w	r3, [sl, #24]
			fs->wflag = 0;
 80029b2:	f88a 0003 	strb.w	r0, [sl, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80029b6:	1ab2      	subs	r2, r6, r2
 80029b8:	429a      	cmp	r2, r3
 80029ba:	f89a 0001 	ldrb.w	r0, [sl, #1]
 80029be:	d213      	bcs.n	80029e8 <follow_path+0x130>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80029c0:	f89a 7002 	ldrb.w	r7, [sl, #2]
 80029c4:	2f01      	cmp	r7, #1
 80029c6:	d804      	bhi.n	80029d2 <follow_path+0x11a>
 80029c8:	e00e      	b.n	80029e8 <follow_path+0x130>
 80029ca:	f8da 3018 	ldr.w	r3, [sl, #24]
 80029ce:	f89a 0001 	ldrb.w	r0, [sl, #1]
					wsect += fs->fsize;
 80029d2:	441e      	add	r6, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80029d4:	3f01      	subs	r7, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 80029d6:	4632      	mov	r2, r6
 80029d8:	2301      	movs	r3, #1
 80029da:	4659      	mov	r1, fp
 80029dc:	f7fe fc82 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80029e0:	2f01      	cmp	r7, #1
 80029e2:	d1f2      	bne.n	80029ca <follow_path+0x112>
 80029e4:	f89a 0001 	ldrb.w	r0, [sl, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80029e8:	2301      	movs	r3, #1
 80029ea:	462a      	mov	r2, r5
 80029ec:	4659      	mov	r1, fp
 80029ee:	f7fe fc6b 	bl	80012c8 <disk_read>
 80029f2:	b358      	cbz	r0, 8002a4c <follow_path+0x194>
			fs->winsect = sector;
 80029f4:	f04f 33ff 	mov.w	r3, #4294967295
 80029f8:	f8ca 302c 	str.w	r3, [sl, #44]	; 0x2c
				res = FR_DISK_ERR;
 80029fc:	2301      	movs	r3, #1
 80029fe:	9301      	str	r3, [sp, #4]
}
 8002a00:	9801      	ldr	r0, [sp, #4]
 8002a02:	b007      	add	sp, #28
 8002a04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (c >= 0x80) {				/* Extended character? */
 8002a08:	0619      	lsls	r1, r3, #24
 8002a0a:	d502      	bpl.n	8002a12 <follow_path+0x15a>
			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
 8002a0c:	3b80      	subs	r3, #128	; 0x80
 8002a0e:	496e      	ldr	r1, [pc, #440]	; (8002bc8 <follow_path+0x310>)
 8002a10:	5ccb      	ldrb	r3, [r1, r3]
	while (*str && *str != chr) str++;
 8002a12:	2b22      	cmp	r3, #34	; 0x22
 8002a14:	d088      	beq.n	8002928 <follow_path+0x70>
 8002a16:	4e6d      	ldr	r6, [pc, #436]	; (8002bcc <follow_path+0x314>)
 8002a18:	212a      	movs	r1, #42	; 0x2a
 8002a1a:	428b      	cmp	r3, r1
 8002a1c:	d084      	beq.n	8002928 <follow_path+0x70>
 8002a1e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8002a22:	2900      	cmp	r1, #0
 8002a24:	d1f9      	bne.n	8002a1a <follow_path+0x162>
			if (IsLower(c)) c -= 0x20;	/* To upper */
 8002a26:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
 8002a2a:	2919      	cmp	r1, #25
 8002a2c:	d801      	bhi.n	8002a32 <follow_path+0x17a>
 8002a2e:	3b20      	subs	r3, #32
 8002a30:	b2db      	uxtb	r3, r3
			sfn[i++] = c;
 8002a32:	9903      	ldr	r1, [sp, #12]
 8002a34:	540b      	strb	r3, [r1, r0]
 8002a36:	3001      	adds	r0, #1
 8002a38:	e766      	b.n	8002908 <follow_path+0x50>
 8002a3a:	444a      	add	r2, r9
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 8002a3c:	4691      	mov	r9, r2
 8002a3e:	f812 1b01 	ldrb.w	r1, [r2], #1
 8002a42:	292f      	cmp	r1, #47	; 0x2f
 8002a44:	d0fa      	beq.n	8002a3c <follow_path+0x184>
 8002a46:	295c      	cmp	r1, #92	; 0x5c
 8002a48:	d0f8      	beq.n	8002a3c <follow_path+0x184>
 8002a4a:	e780      	b.n	800294e <follow_path+0x96>
			fs->winsect = sector;
 8002a4c:	f8ca 502c 	str.w	r5, [sl, #44]	; 0x2c
		c = dp->dir[DIR_Name];
 8002a50:	6a23      	ldr	r3, [r4, #32]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8002a52:	781a      	ldrb	r2, [r3, #0]
 8002a54:	2a00      	cmp	r2, #0
 8002a56:	d058      	beq.n	8002b0a <follow_path+0x252>
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
 8002a58:	7ada      	ldrb	r2, [r3, #11]
 8002a5a:	f002 013f 	and.w	r1, r2, #63	; 0x3f
 8002a5e:	71a1      	strb	r1, [r4, #6]
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 8002a60:	7ad9      	ldrb	r1, [r3, #11]
 8002a62:	070e      	lsls	r6, r1, #28
 8002a64:	d436      	bmi.n	8002ad4 <follow_path+0x21c>
	} while (--cnt && r == 0);
 8002a66:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
 8002a6a:	7819      	ldrb	r1, [r3, #0]
 8002a6c:	4288      	cmp	r0, r1
 8002a6e:	d131      	bne.n	8002ad4 <follow_path+0x21c>
 8002a70:	7858      	ldrb	r0, [r3, #1]
 8002a72:	f894 1025 	ldrb.w	r1, [r4, #37]	; 0x25
 8002a76:	4288      	cmp	r0, r1
 8002a78:	d12c      	bne.n	8002ad4 <follow_path+0x21c>
 8002a7a:	7898      	ldrb	r0, [r3, #2]
 8002a7c:	f894 1026 	ldrb.w	r1, [r4, #38]	; 0x26
 8002a80:	4288      	cmp	r0, r1
 8002a82:	d127      	bne.n	8002ad4 <follow_path+0x21c>
 8002a84:	f894 0027 	ldrb.w	r0, [r4, #39]	; 0x27
 8002a88:	78d9      	ldrb	r1, [r3, #3]
 8002a8a:	4288      	cmp	r0, r1
 8002a8c:	d122      	bne.n	8002ad4 <follow_path+0x21c>
 8002a8e:	7918      	ldrb	r0, [r3, #4]
 8002a90:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 8002a94:	4288      	cmp	r0, r1
 8002a96:	d11d      	bne.n	8002ad4 <follow_path+0x21c>
 8002a98:	7958      	ldrb	r0, [r3, #5]
 8002a9a:	f894 1029 	ldrb.w	r1, [r4, #41]	; 0x29
 8002a9e:	4288      	cmp	r0, r1
 8002aa0:	d118      	bne.n	8002ad4 <follow_path+0x21c>
 8002aa2:	7998      	ldrb	r0, [r3, #6]
 8002aa4:	f894 102a 	ldrb.w	r1, [r4, #42]	; 0x2a
 8002aa8:	4288      	cmp	r0, r1
 8002aaa:	d113      	bne.n	8002ad4 <follow_path+0x21c>
 8002aac:	79d8      	ldrb	r0, [r3, #7]
 8002aae:	f894 102b 	ldrb.w	r1, [r4, #43]	; 0x2b
 8002ab2:	4288      	cmp	r0, r1
 8002ab4:	d10e      	bne.n	8002ad4 <follow_path+0x21c>
 8002ab6:	7a18      	ldrb	r0, [r3, #8]
 8002ab8:	f894 102c 	ldrb.w	r1, [r4, #44]	; 0x2c
 8002abc:	4288      	cmp	r0, r1
 8002abe:	d109      	bne.n	8002ad4 <follow_path+0x21c>
 8002ac0:	7a58      	ldrb	r0, [r3, #9]
 8002ac2:	f894 102d 	ldrb.w	r1, [r4, #45]	; 0x2d
 8002ac6:	4288      	cmp	r0, r1
 8002ac8:	d104      	bne.n	8002ad4 <follow_path+0x21c>
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 8002aca:	7a99      	ldrb	r1, [r3, #10]
 8002acc:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
 8002ad0:	4299      	cmp	r1, r3
 8002ad2:	d021      	beq.n	8002b18 <follow_path+0x260>
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8002ad4:	69e5      	ldr	r5, [r4, #28]
 8002ad6:	b1c5      	cbz	r5, 8002b0a <follow_path+0x252>
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8002ad8:	6966      	ldr	r6, [r4, #20]
 8002ada:	3620      	adds	r6, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8002adc:	4546      	cmp	r6, r8
 8002ade:	d814      	bhi.n	8002b0a <follow_path+0x252>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8002ae0:	f3c6 0308 	ubfx	r3, r6, #0, #9
	FATFS *fs = dp->obj.fs;
 8002ae4:	6827      	ldr	r7, [r4, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8002ae6:	b943      	cbnz	r3, 8002afa <follow_path+0x242>
		if (!dp->clust) {		/* Static table */
 8002ae8:	69a1      	ldr	r1, [r4, #24]
		dp->sect++;				/* Next sector */
 8002aea:	3501      	adds	r5, #1
 8002aec:	61e5      	str	r5, [r4, #28]
		if (!dp->clust) {		/* Static table */
 8002aee:	2900      	cmp	r1, #0
 8002af0:	d132      	bne.n	8002b58 <follow_path+0x2a0>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 8002af2:	893a      	ldrh	r2, [r7, #8]
 8002af4:	ebb2 1f56 	cmp.w	r2, r6, lsr #5
 8002af8:	d945      	bls.n	8002b86 <follow_path+0x2ce>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8002afa:	3730      	adds	r7, #48	; 0x30
 8002afc:	441f      	add	r7, r3
 8002afe:	6227      	str	r7, [r4, #32]
	dp->dptr = ofs;						/* Current entry */
 8002b00:	6166      	str	r6, [r4, #20]
 8002b02:	e741      	b.n	8002988 <follow_path+0xd0>
				if (res == FR_NO_FILE) {	/* Object is not found */
 8002b04:	2804      	cmp	r0, #4
 8002b06:	f47f af11 	bne.w	800292c <follow_path+0x74>
			ns = dp->fn[NSFLAG];
 8002b0a:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8002b0e:	0759      	lsls	r1, r3, #29
 8002b10:	d456      	bmi.n	8002bc0 <follow_path+0x308>
 8002b12:	2305      	movs	r3, #5
 8002b14:	9301      	str	r3, [sp, #4]
 8002b16:	e709      	b.n	800292c <follow_path+0x74>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8002b18:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8002b1c:	075b      	lsls	r3, r3, #29
 8002b1e:	f53f af05 	bmi.w	800292c <follow_path+0x74>
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 8002b22:	06d2      	lsls	r2, r2, #27
 8002b24:	d5f5      	bpl.n	8002b12 <follow_path+0x25a>
	if (fs->fs_type == FS_FAT32) {
 8002b26:	9802      	ldr	r0, [sp, #8]
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8002b28:	6963      	ldr	r3, [r4, #20]
	if (fs->fs_type == FS_FAT32) {
 8002b2a:	7801      	ldrb	r1, [r0, #0]
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8002b2c:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8002b30:	f100 0330 	add.w	r3, r0, #48	; 0x30
 8002b34:	4413      	add	r3, r2
	if (fs->fs_type == FS_FAT32) {
 8002b36:	2903      	cmp	r1, #3
	rv = rv << 8 | ptr[0];
 8002b38:	7ed8      	ldrb	r0, [r3, #27]
 8002b3a:	7e9a      	ldrb	r2, [r3, #26]
	cl = ld_word(dir + DIR_FstClusLO);
 8002b3c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8002b40:	d105      	bne.n	8002b4e <follow_path+0x296>
	rv = rv << 8 | ptr[0];
 8002b42:	7d59      	ldrb	r1, [r3, #21]
 8002b44:	7d1b      	ldrb	r3, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8002b46:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8002b4a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8002b4e:	60a2      	str	r2, [r4, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 8002b50:	e6ca      	b.n	80028e8 <follow_path+0x30>
			res = FR_DISK_ERR;
 8002b52:	2301      	movs	r3, #1
 8002b54:	9301      	str	r3, [sp, #4]
 8002b56:	e6e9      	b.n	800292c <follow_path+0x74>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 8002b58:	897a      	ldrh	r2, [r7, #10]
 8002b5a:	3a01      	subs	r2, #1
 8002b5c:	ea12 2256 	ands.w	r2, r2, r6, lsr #9
 8002b60:	d1cb      	bne.n	8002afa <follow_path+0x242>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 8002b62:	4638      	mov	r0, r7
 8002b64:	e9cd 3204 	strd	r3, r2, [sp, #16]
 8002b68:	f7ff fa18 	bl	8001f9c <get_fat.isra.10>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8002b6c:	2801      	cmp	r0, #1
 8002b6e:	d924      	bls.n	8002bba <follow_path+0x302>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 8002b70:	1c45      	adds	r5, r0, #1
 8002b72:	d0ee      	beq.n	8002b52 <follow_path+0x29a>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 8002b74:	6979      	ldr	r1, [r7, #20]
 8002b76:	9b04      	ldr	r3, [sp, #16]
 8002b78:	4288      	cmp	r0, r1
 8002b7a:	d311      	bcc.n	8002ba0 <follow_path+0x2e8>
 8002b7c:	9a05      	ldr	r2, [sp, #20]
						dp->sect = 0; return FR_NO_FILE;
 8002b7e:	61e2      	str	r2, [r4, #28]
			ns = dp->fn[NSFLAG];
 8002b80:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8002b84:	e7c3      	b.n	8002b0e <follow_path+0x256>
				dp->sect = 0; return FR_NO_FILE;
 8002b86:	61e1      	str	r1, [r4, #28]
			ns = dp->fn[NSFLAG];
 8002b88:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8002b8c:	e7bf      	b.n	8002b0e <follow_path+0x256>
		dp->fn[NSFLAG] = NS_NONAME;
 8002b8e:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
 8002b90:	4620      	mov	r0, r4
		dp->fn[NSFLAG] = NS_NONAME;
 8002b92:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
}
 8002b96:	b007      	add	sp, #28
 8002b98:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
 8002b9c:	f7ff b888 	b.w	8001cb0 <dir_sdi.constprop.14>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8002ba0:	3902      	subs	r1, #2
	clst -= 2;
 8002ba2:	1e82      	subs	r2, r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8002ba4:	428a      	cmp	r2, r1
	return clst * fs->csize + fs->database;
 8002ba6:	bf3c      	itt	cc
 8002ba8:	897d      	ldrhcc	r5, [r7, #10]
 8002baa:	6ab9      	ldrcc	r1, [r7, #40]	; 0x28
				dp->clust = clst;		/* Initialize data for new cluster */
 8002bac:	61a0      	str	r0, [r4, #24]
	return clst * fs->csize + fs->database;
 8002bae:	bf34      	ite	cc
 8002bb0:	fb02 1505 	mlacc	r5, r2, r5, r1
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8002bb4:	461d      	movcs	r5, r3
				dp->sect = clust2sect(fs, clst);
 8002bb6:	61e5      	str	r5, [r4, #28]
 8002bb8:	e79f      	b.n	8002afa <follow_path+0x242>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8002bba:	2302      	movs	r3, #2
 8002bbc:	9301      	str	r3, [sp, #4]
	return res;
 8002bbe:	e6b5      	b.n	800292c <follow_path+0x74>
			res = dir_find(dp);				/* Find an object with the segment name */
 8002bc0:	2304      	movs	r3, #4
 8002bc2:	9301      	str	r3, [sp, #4]
 8002bc4:	e6b2      	b.n	800292c <follow_path+0x74>
 8002bc6:	bf00      	nop
 8002bc8:	08007d98 	.word	0x08007d98
 8002bcc:	08007e19 	.word	0x08007e19
 8002bd0:	001fffff 	.word	0x001fffff

08002bd4 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	BYTE mode			/* !=0: Check write protection for write access */
)
{
 8002bd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (*path) {	/* If the pointer is not a null */
 8002bd8:	6807      	ldr	r7, [r0, #0]
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 8002bda:	2600      	movs	r6, #0
{
 8002bdc:	b084      	sub	sp, #16
	*rfs = 0;
 8002bde:	600e      	str	r6, [r1, #0]
	if (*path) {	/* If the pointer is not a null */
 8002be0:	2f00      	cmp	r7, #0
 8002be2:	f000 81d6 	beq.w	8002f92 <find_volume+0x3be>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8002be6:	f897 c000 	ldrb.w	ip, [r7]
 8002bea:	f1bc 0f20 	cmp.w	ip, #32
 8002bee:	d90f      	bls.n	8002c10 <find_volume+0x3c>
 8002bf0:	f1bc 0f3a 	cmp.w	ip, #58	; 0x3a
 8002bf4:	f000 81cd 	beq.w	8002f92 <find_volume+0x3be>
 8002bf8:	463b      	mov	r3, r7
 8002bfa:	e003      	b.n	8002c04 <find_volume+0x30>
 8002bfc:	2c3a      	cmp	r4, #58	; 0x3a
 8002bfe:	f000 8114 	beq.w	8002e2a <find_volume+0x256>
 8002c02:	462b      	mov	r3, r5
 8002c04:	785c      	ldrb	r4, [r3, #1]
 8002c06:	2c20      	cmp	r4, #32
 8002c08:	f103 0501 	add.w	r5, r3, #1
 8002c0c:	d8f6      	bhi.n	8002bfc <find_volume+0x28>
		vol = 0;		/* Drive 0 */
 8002c0e:	2600      	movs	r6, #0
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8002c10:	4bbe      	ldr	r3, [pc, #760]	; (8002f0c <find_volume+0x338>)
 8002c12:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8002c16:	2c00      	cmp	r4, #0
 8002c18:	f000 8119 	beq.w	8002e4e <find_volume+0x27a>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 8002c1c:	600c      	str	r4, [r1, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
	if (fs->fs_type) {					/* If the volume has been mounted */
 8002c1e:	7823      	ldrb	r3, [r4, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 8002c20:	f002 05fe 	and.w	r5, r2, #254	; 0xfe
	if (fs->fs_type) {					/* If the volume has been mounted */
 8002c24:	b173      	cbz	r3, 8002c44 <find_volume+0x70>
		stat = disk_status(fs->drv);
 8002c26:	7860      	ldrb	r0, [r4, #1]
 8002c28:	f7fe fb34 	bl	8001294 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8002c2c:	07c7      	lsls	r7, r0, #31
 8002c2e:	d409      	bmi.n	8002c44 <find_volume+0x70>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 8002c30:	2d00      	cmp	r5, #0
 8002c32:	f000 81b2 	beq.w	8002f9a <find_volume+0x3c6>
 8002c36:	f010 0004 	ands.w	r0, r0, #4
 8002c3a:	f040 8115 	bne.w	8002e68 <find_volume+0x294>
#endif
#if _FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
}
 8002c3e:	b004      	add	sp, #16
 8002c40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8002c44:	b2f0      	uxtb	r0, r6
	fs->fs_type = 0;					/* Clear the file system object */
 8002c46:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8002c48:	7060      	strb	r0, [r4, #1]
	fs->fs_type = 0;					/* Clear the file system object */
 8002c4a:	7023      	strb	r3, [r4, #0]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8002c4c:	f7fe fb2c 	bl	80012a8 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 8002c50:	07c6      	lsls	r6, r0, #31
 8002c52:	f100 8100 	bmi.w	8002e56 <find_volume+0x282>
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 8002c56:	b115      	cbz	r5, 8002c5e <find_volume+0x8a>
 8002c58:	0745      	lsls	r5, r0, #29
 8002c5a:	f100 8105 	bmi.w	8002e68 <find_volume+0x294>
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8002c5e:	2200      	movs	r2, #0
 8002c60:	f04f 35ff 	mov.w	r5, #4294967295
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002c64:	f104 0630 	add.w	r6, r4, #48	; 0x30
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8002c68:	70e2      	strb	r2, [r4, #3]
 8002c6a:	62e5      	str	r5, [r4, #44]	; 0x2c
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002c6c:	4631      	mov	r1, r6
 8002c6e:	2301      	movs	r3, #1
 8002c70:	7860      	ldrb	r0, [r4, #1]
 8002c72:	f7fe fb29 	bl	80012c8 <disk_read>
 8002c76:	2800      	cmp	r0, #0
 8002c78:	f040 80f1 	bne.w	8002e5e <find_volume+0x28a>
	rv = rv << 8 | ptr[0];
 8002c7c:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 8002c80:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
			fs->winsect = sector;
 8002c84:	62e0      	str	r0, [r4, #44]	; 0x2c
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8002c86:	f64a 2155 	movw	r1, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 8002c8a:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8002c8e:	4288      	cmp	r0, r1
 8002c90:	f040 817b 	bne.w	8002f8a <find_volume+0x3b6>
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 8002c94:	f894 7030 	ldrb.w	r7, [r4, #48]	; 0x30
 8002c98:	2fe9      	cmp	r7, #233	; 0xe9
 8002c9a:	d006      	beq.n	8002caa <find_volume+0xd6>
 8002c9c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8002c9e:	489c      	ldr	r0, [pc, #624]	; (8002f10 <find_volume+0x33c>)
 8002ca0:	f001 11ff 	and.w	r1, r1, #16711935	; 0xff00ff
 8002ca4:	4281      	cmp	r1, r0
 8002ca6:	f040 80e3 	bne.w	8002e70 <find_volume+0x29c>
	rv = rv << 8 | ptr[2];
 8002caa:	f8b4 5068 	ldrh.w	r5, [r4, #104]	; 0x68
	rv = rv << 8 | ptr[1];
 8002cae:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
	rv = rv << 8 | ptr[0];
 8002cb2:	f894 1066 	ldrb.w	r1, [r4, #102]	; 0x66
	rv = rv << 8 | ptr[1];
 8002cb6:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
	rv = rv << 8 | ptr[0];
 8002cba:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8002cbe:	4895      	ldr	r0, [pc, #596]	; (8002f14 <find_volume+0x340>)
 8002cc0:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8002cc4:	4281      	cmp	r1, r0
 8002cc6:	d00d      	beq.n	8002ce4 <find_volume+0x110>
	rv = rv << 8 | ptr[2];
 8002cc8:	f8b4 5084 	ldrh.w	r5, [r4, #132]	; 0x84
	rv = rv << 8 | ptr[1];
 8002ccc:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
	rv = rv << 8 | ptr[0];
 8002cd0:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
	rv = rv << 8 | ptr[1];
 8002cd4:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8002cd8:	4d8f      	ldr	r5, [pc, #572]	; (8002f18 <find_volume+0x344>)
	rv = rv << 8 | ptr[0];
 8002cda:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8002cde:	42a9      	cmp	r1, r5
 8002ce0:	f040 80c6 	bne.w	8002e70 <find_volume+0x29c>
	bsect = 0;
 8002ce4:	2500      	movs	r5, #0
	rv = rv << 8 | ptr[0];
 8002ce6:	f894 003c 	ldrb.w	r0, [r4, #60]	; 0x3c
 8002cea:	f894 103b 	ldrb.w	r1, [r4, #59]	; 0x3b
 8002cee:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8002cf2:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8002cf6:	f040 8148 	bne.w	8002f8a <find_volume+0x3b6>
	rv = rv << 8 | ptr[0];
 8002cfa:	f894 0047 	ldrb.w	r0, [r4, #71]	; 0x47
 8002cfe:	f894 1046 	ldrb.w	r1, [r4, #70]	; 0x46
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 8002d02:	ea51 2100 	orrs.w	r1, r1, r0, lsl #8
 8002d06:	d109      	bne.n	8002d1c <find_volume+0x148>
	rv = rv << 8 | ptr[2];
 8002d08:	f8b4 6056 	ldrh.w	r6, [r4, #86]	; 0x56
	rv = rv << 8 | ptr[1];
 8002d0c:	f894 1055 	ldrb.w	r1, [r4, #85]	; 0x55
	rv = rv << 8 | ptr[0];
 8002d10:	f894 0054 	ldrb.w	r0, [r4, #84]	; 0x54
	rv = rv << 8 | ptr[1];
 8002d14:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
	rv = rv << 8 | ptr[0];
 8002d18:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8002d1c:	f894 6040 	ldrb.w	r6, [r4, #64]	; 0x40
		fs->fsize = fasize;
 8002d20:	61a1      	str	r1, [r4, #24]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8002d22:	1e70      	subs	r0, r6, #1
 8002d24:	2801      	cmp	r0, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8002d26:	70a6      	strb	r6, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8002d28:	f200 812f 	bhi.w	8002f8a <find_volume+0x3b6>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 8002d2c:	f894 c03d 	ldrb.w	ip, [r4, #61]	; 0x3d
 8002d30:	fa1f f08c 	uxth.w	r0, ip
 8002d34:	8160      	strh	r0, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8002d36:	2800      	cmp	r0, #0
 8002d38:	f000 8127 	beq.w	8002f8a <find_volume+0x3b6>
 8002d3c:	f10c 30ff 	add.w	r0, ip, #4294967295
 8002d40:	ea10 0f0c 	tst.w	r0, ip
 8002d44:	f040 8121 	bne.w	8002f8a <find_volume+0x3b6>
	rv = rv << 8 | ptr[0];
 8002d48:	f894 0042 	ldrb.w	r0, [r4, #66]	; 0x42
 8002d4c:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
 8002d50:	ea47 2700 	orr.w	r7, r7, r0, lsl #8
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8002d54:	0738      	lsls	r0, r7, #28
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 8002d56:	8127      	strh	r7, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8002d58:	f040 8117 	bne.w	8002f8a <find_volume+0x3b6>
	rv = rv << 8 | ptr[0];
 8002d5c:	f894 e044 	ldrb.w	lr, [r4, #68]	; 0x44
 8002d60:	f894 0043 	ldrb.w	r0, [r4, #67]	; 0x43
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 8002d64:	ea50 200e 	orrs.w	r0, r0, lr, lsl #8
 8002d68:	d109      	bne.n	8002d7e <find_volume+0x1aa>
	rv = rv << 8 | ptr[2];
 8002d6a:	f8b4 8052 	ldrh.w	r8, [r4, #82]	; 0x52
	rv = rv << 8 | ptr[1];
 8002d6e:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
	rv = rv << 8 | ptr[0];
 8002d72:	f894 e050 	ldrb.w	lr, [r4, #80]	; 0x50
	rv = rv << 8 | ptr[1];
 8002d76:	ea40 2008 	orr.w	r0, r0, r8, lsl #8
	rv = rv << 8 | ptr[0];
 8002d7a:	ea4e 2000 	orr.w	r0, lr, r0, lsl #8
	rv = rv << 8 | ptr[0];
 8002d7e:	f894 e03f 	ldrb.w	lr, [r4, #63]	; 0x3f
 8002d82:	f894 803e 	ldrb.w	r8, [r4, #62]	; 0x3e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 8002d86:	ea58 280e 	orrs.w	r8, r8, lr, lsl #8
 8002d8a:	f000 80fe 	beq.w	8002f8a <find_volume+0x3b6>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 8002d8e:	fb01 fe06 	mul.w	lr, r1, r6
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 8002d92:	eb08 1617 	add.w	r6, r8, r7, lsr #4
 8002d96:	4476      	add	r6, lr
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8002d98:	42b0      	cmp	r0, r6
 8002d9a:	f0c0 80f6 	bcc.w	8002f8a <find_volume+0x3b6>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8002d9e:	1b80      	subs	r0, r0, r6
 8002da0:	fbb0 f0fc 	udiv	r0, r0, ip
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8002da4:	2800      	cmp	r0, #0
 8002da6:	f000 80f0 	beq.w	8002f8a <find_volume+0x3b6>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 8002daa:	f64f 7cf5 	movw	ip, #65525	; 0xfff5
 8002dae:	4560      	cmp	r0, ip
 8002db0:	f200 81da 	bhi.w	8003168 <find_volume+0x594>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8002db4:	f640 7cf5 	movw	ip, #4085	; 0xff5
 8002db8:	4560      	cmp	r0, ip
 8002dba:	eb08 0205 	add.w	r2, r8, r5
 8002dbe:	442e      	add	r6, r5
 8002dc0:	f100 0302 	add.w	r3, r0, #2
 8002dc4:	f200 8205 	bhi.w	80031d2 <find_volume+0x5fe>
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8002dc8:	6163      	str	r3, [r4, #20]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8002dca:	e9c4 5207 	strd	r5, r2, [r4, #28]
		fs->database = bsect + sysect;					/* Data start sector */
 8002dce:	62a6      	str	r6, [r4, #40]	; 0x28
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 8002dd0:	2f00      	cmp	r7, #0
 8002dd2:	f000 80da 	beq.w	8002f8a <find_volume+0x3b6>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8002dd6:	4472      	add	r2, lr
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8002dd8:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 8002ddc:	f003 0301 	and.w	r3, r3, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8002de0:	6262      	str	r2, [r4, #36]	; 0x24
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8002de2:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 8002de6:	2201      	movs	r2, #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8002de8:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 8002dec:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
 8002df0:	f0c0 80cb 	bcc.w	8002f8a <find_volume+0x3b6>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8002df4:	f04f 33ff 	mov.w	r3, #4294967295
 8002df8:	e9c4 3303 	strd	r3, r3, [r4, #12]
		fs->fsi_flag = 0x80;
 8002dfc:	2180      	movs	r1, #128	; 0x80
 8002dfe:	7121      	strb	r1, [r4, #4]
	fs->id = ++Fsid;		/* File system mount ID */
 8002e00:	4846      	ldr	r0, [pc, #280]	; (8002f1c <find_volume+0x348>)
		if (Files[i].fs == fs) Files[i].fs = 0;
 8002e02:	4947      	ldr	r1, [pc, #284]	; (8002f20 <find_volume+0x34c>)
	fs->id = ++Fsid;		/* File system mount ID */
 8002e04:	8803      	ldrh	r3, [r0, #0]
		if (Files[i].fs == fs) Files[i].fs = 0;
 8002e06:	680d      	ldr	r5, [r1, #0]
	fs->fs_type = fmt;		/* FAT sub-type */
 8002e08:	7022      	strb	r2, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8002e0a:	3301      	adds	r3, #1
 8002e0c:	b29b      	uxth	r3, r3
		if (Files[i].fs == fs) Files[i].fs = 0;
 8002e0e:	42a5      	cmp	r5, r4
	fs->id = ++Fsid;		/* File system mount ID */
 8002e10:	8003      	strh	r3, [r0, #0]
 8002e12:	80e3      	strh	r3, [r4, #6]
		if (Files[i].fs == fs) Files[i].fs = 0;
 8002e14:	bf04      	itt	eq
 8002e16:	2300      	moveq	r3, #0
 8002e18:	600b      	streq	r3, [r1, #0]
 8002e1a:	690b      	ldr	r3, [r1, #16]
 8002e1c:	429c      	cmp	r4, r3
 8002e1e:	f04f 0000 	mov.w	r0, #0
 8002e22:	f47f af0c 	bne.w	8002c3e <find_volume+0x6a>
 8002e26:	6108      	str	r0, [r1, #16]
 8002e28:	e709      	b.n	8002c3e <find_volume+0x6a>
			i = *tp++ - '0';
 8002e2a:	3701      	adds	r7, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8002e2c:	42bd      	cmp	r5, r7
			i = *tp++ - '0';
 8002e2e:	f1ac 0630 	sub.w	r6, ip, #48	; 0x30
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8002e32:	f040 80ae 	bne.w	8002f92 <find_volume+0x3be>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 8002e36:	f1bc 0f30 	cmp.w	ip, #48	; 0x30
 8002e3a:	f040 80aa 	bne.w	8002f92 <find_volume+0x3be>
					*path = ++tt;
 8002e3e:	3302      	adds	r3, #2
 8002e40:	6003      	str	r3, [r0, #0]
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8002e42:	4b32      	ldr	r3, [pc, #200]	; (8002f0c <find_volume+0x338>)
 8002e44:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8002e48:	2c00      	cmp	r4, #0
 8002e4a:	f47f aee7 	bne.w	8002c1c <find_volume+0x48>
 8002e4e:	200c      	movs	r0, #12
}
 8002e50:	b004      	add	sp, #16
 8002e52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8002e56:	2003      	movs	r0, #3
}
 8002e58:	b004      	add	sp, #16
 8002e5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8002e5e:	2001      	movs	r0, #1
			fs->winsect = sector;
 8002e60:	62e5      	str	r5, [r4, #44]	; 0x2c
}
 8002e62:	b004      	add	sp, #16
 8002e64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				return FR_WRITE_PROTECTED;
 8002e68:	200a      	movs	r0, #10
}
 8002e6a:	b004      	add	sp, #16
 8002e6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8002e70:	f894 51f2 	ldrb.w	r5, [r4, #498]	; 0x1f2
 8002e74:	b14d      	cbz	r5, 8002e8a <find_volume+0x2b6>
	rv = rv << 8 | ptr[2];
 8002e76:	f8b4 01f8 	ldrh.w	r0, [r4, #504]	; 0x1f8
	rv = rv << 8 | ptr[1];
 8002e7a:	f894 11f7 	ldrb.w	r1, [r4, #503]	; 0x1f7
	rv = rv << 8 | ptr[0];
 8002e7e:	f894 51f6 	ldrb.w	r5, [r4, #502]	; 0x1f6
	rv = rv << 8 | ptr[1];
 8002e82:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
	rv = rv << 8 | ptr[0];
 8002e86:	ea45 2501 	orr.w	r5, r5, r1, lsl #8
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8002e8a:	f894 0202 	ldrb.w	r0, [r4, #514]	; 0x202
 8002e8e:	b148      	cbz	r0, 8002ea4 <find_volume+0x2d0>
	rv = rv << 8 | ptr[2];
 8002e90:	f8b4 c208 	ldrh.w	ip, [r4, #520]	; 0x208
	rv = rv << 8 | ptr[1];
 8002e94:	f894 0207 	ldrb.w	r0, [r4, #519]	; 0x207
	rv = rv << 8 | ptr[0];
 8002e98:	f894 1206 	ldrb.w	r1, [r4, #518]	; 0x206
	rv = rv << 8 | ptr[1];
 8002e9c:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
	rv = rv << 8 | ptr[0];
 8002ea0:	ea41 2000 	orr.w	r0, r1, r0, lsl #8
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8002ea4:	f894 1212 	ldrb.w	r1, [r4, #530]	; 0x212
 8002ea8:	9001      	str	r0, [sp, #4]
 8002eaa:	2900      	cmp	r1, #0
 8002eac:	d177      	bne.n	8002f9e <find_volume+0x3ca>
 8002eae:	4608      	mov	r0, r1
 8002eb0:	f894 1222 	ldrb.w	r1, [r4, #546]	; 0x222
 8002eb4:	9002      	str	r0, [sp, #8]
 8002eb6:	b149      	cbz	r1, 8002ecc <find_volume+0x2f8>
	rv = rv << 8 | ptr[2];
 8002eb8:	f8b4 c228 	ldrh.w	ip, [r4, #552]	; 0x228
	rv = rv << 8 | ptr[1];
 8002ebc:	f894 0227 	ldrb.w	r0, [r4, #551]	; 0x227
	rv = rv << 8 | ptr[0];
 8002ec0:	f894 1226 	ldrb.w	r1, [r4, #550]	; 0x226
	rv = rv << 8 | ptr[1];
 8002ec4:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
	rv = rv << 8 | ptr[0];
 8002ec8:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8002ecc:	9103      	str	r1, [sp, #12]
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8002ece:	2d00      	cmp	r5, #0
 8002ed0:	d170      	bne.n	8002fb4 <find_volume+0x3e0>
			bsect = br[i];
 8002ed2:	9d01      	ldr	r5, [sp, #4]
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8002ed4:	2d00      	cmp	r5, #0
 8002ed6:	f040 8082 	bne.w	8002fde <find_volume+0x40a>
			bsect = br[i];
 8002eda:	9d02      	ldr	r5, [sp, #8]
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8002edc:	2d00      	cmp	r5, #0
 8002ede:	f040 80c4 	bne.w	800306a <find_volume+0x496>
			bsect = br[i];
 8002ee2:	9d03      	ldr	r5, [sp, #12]
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8002ee4:	2d00      	cmp	r5, #0
 8002ee6:	d050      	beq.n	8002f8a <find_volume+0x3b6>
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8002ee8:	f04f 37ff 	mov.w	r7, #4294967295
 8002eec:	2300      	movs	r3, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002eee:	42bd      	cmp	r5, r7
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8002ef0:	70e3      	strb	r3, [r4, #3]
 8002ef2:	62e7      	str	r7, [r4, #44]	; 0x2c
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002ef4:	d017      	beq.n	8002f26 <find_volume+0x352>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002ef6:	4631      	mov	r1, r6
 8002ef8:	2301      	movs	r3, #1
 8002efa:	462a      	mov	r2, r5
 8002efc:	7860      	ldrb	r0, [r4, #1]
 8002efe:	f7fe f9e3 	bl	80012c8 <disk_read>
 8002f02:	b178      	cbz	r0, 8002f24 <find_volume+0x350>
			fs->winsect = sector;
 8002f04:	62e7      	str	r7, [r4, #44]	; 0x2c
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8002f06:	2001      	movs	r0, #1
 8002f08:	e699      	b.n	8002c3e <find_volume+0x6a>
 8002f0a:	bf00      	nop
 8002f0c:	200000ac 	.word	0x200000ac
 8002f10:	009000eb 	.word	0x009000eb
 8002f14:	00544146 	.word	0x00544146
 8002f18:	33544146 	.word	0x33544146
 8002f1c:	200000d0 	.word	0x200000d0
 8002f20:	200000b0 	.word	0x200000b0
			fs->winsect = sector;
 8002f24:	62e5      	str	r5, [r4, #44]	; 0x2c
	rv = rv << 8 | ptr[0];
 8002f26:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 8002f2a:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8002f2e:	f64a 2155 	movw	r1, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 8002f32:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8002f36:	4288      	cmp	r0, r1
 8002f38:	d127      	bne.n	8002f8a <find_volume+0x3b6>
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 8002f3a:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
 8002f3e:	29e9      	cmp	r1, #233	; 0xe9
 8002f40:	d005      	beq.n	8002f4e <find_volume+0x37a>
 8002f42:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8002f44:	48ce      	ldr	r0, [pc, #824]	; (8003280 <find_volume+0x6ac>)
 8002f46:	f001 11ff 	and.w	r1, r1, #16711935	; 0xff00ff
 8002f4a:	4281      	cmp	r1, r0
 8002f4c:	d11d      	bne.n	8002f8a <find_volume+0x3b6>
	rv = rv << 8 | ptr[2];
 8002f4e:	f8b4 6068 	ldrh.w	r6, [r4, #104]	; 0x68
	rv = rv << 8 | ptr[1];
 8002f52:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
	rv = rv << 8 | ptr[0];
 8002f56:	f894 1066 	ldrb.w	r1, [r4, #102]	; 0x66
	rv = rv << 8 | ptr[1];
 8002f5a:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
	rv = rv << 8 | ptr[0];
 8002f5e:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8002f62:	48c8      	ldr	r0, [pc, #800]	; (8003284 <find_volume+0x6b0>)
 8002f64:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8002f68:	4281      	cmp	r1, r0
 8002f6a:	f43f aebc 	beq.w	8002ce6 <find_volume+0x112>
	rv = rv << 8 | ptr[2];
 8002f6e:	f8b4 6084 	ldrh.w	r6, [r4, #132]	; 0x84
	rv = rv << 8 | ptr[1];
 8002f72:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
	rv = rv << 8 | ptr[0];
 8002f76:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
	rv = rv << 8 | ptr[1];
 8002f7a:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8002f7e:	4ec2      	ldr	r6, [pc, #776]	; (8003288 <find_volume+0x6b4>)
	rv = rv << 8 | ptr[0];
 8002f80:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8002f84:	42b1      	cmp	r1, r6
 8002f86:	f43f aeae 	beq.w	8002ce6 <find_volume+0x112>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8002f8a:	200d      	movs	r0, #13
}
 8002f8c:	b004      	add	sp, #16
 8002f8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 8002f92:	200b      	movs	r0, #11
}
 8002f94:	b004      	add	sp, #16
 8002f96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return FR_OK;				/* The file system object is valid */
 8002f9a:	4628      	mov	r0, r5
 8002f9c:	e64f      	b.n	8002c3e <find_volume+0x6a>
	rv = rv << 8 | ptr[2];
 8002f9e:	f8b4 c218 	ldrh.w	ip, [r4, #536]	; 0x218
	rv = rv << 8 | ptr[1];
 8002fa2:	f894 0217 	ldrb.w	r0, [r4, #535]	; 0x217
	rv = rv << 8 | ptr[0];
 8002fa6:	f894 1216 	ldrb.w	r1, [r4, #534]	; 0x216
	rv = rv << 8 | ptr[1];
 8002faa:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
	rv = rv << 8 | ptr[0];
 8002fae:	ea41 2000 	orr.w	r0, r1, r0, lsl #8
 8002fb2:	e77d      	b.n	8002eb0 <find_volume+0x2dc>
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8002fb4:	f04f 38ff 	mov.w	r8, #4294967295
 8002fb8:	2100      	movs	r1, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002fba:	4545      	cmp	r5, r8
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8002fbc:	70e1      	strb	r1, [r4, #3]
 8002fbe:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002fc2:	f000 80a5 	beq.w	8003110 <find_volume+0x53c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002fc6:	2301      	movs	r3, #1
 8002fc8:	462a      	mov	r2, r5
 8002fca:	4631      	mov	r1, r6
 8002fcc:	7860      	ldrb	r0, [r4, #1]
 8002fce:	f7fe f97b 	bl	80012c8 <disk_read>
 8002fd2:	2800      	cmp	r0, #0
 8002fd4:	f000 808e 	beq.w	80030f4 <find_volume+0x520>
			fs->winsect = sector;
 8002fd8:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
 8002fdc:	e779      	b.n	8002ed2 <find_volume+0x2fe>
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8002fde:	f04f 37ff 	mov.w	r7, #4294967295
 8002fe2:	2300      	movs	r3, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002fe4:	42bd      	cmp	r5, r7
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8002fe6:	70e3      	strb	r3, [r4, #3]
 8002fe8:	62e7      	str	r7, [r4, #44]	; 0x2c
	if (sector != fs->winsect) {	/* Window offset changed? */
 8002fea:	d009      	beq.n	8003000 <find_volume+0x42c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8002fec:	2301      	movs	r3, #1
 8002fee:	462a      	mov	r2, r5
 8002ff0:	4631      	mov	r1, r6
 8002ff2:	7860      	ldrb	r0, [r4, #1]
 8002ff4:	f7fe f968 	bl	80012c8 <disk_read>
 8002ff8:	2800      	cmp	r0, #0
 8002ffa:	f040 80b3 	bne.w	8003164 <find_volume+0x590>
			fs->winsect = sector;
 8002ffe:	62e5      	str	r5, [r4, #44]	; 0x2c
	rv = rv << 8 | ptr[0];
 8003000:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 8003004:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8003008:	f64a 2155 	movw	r1, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 800300c:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8003010:	4288      	cmp	r0, r1
 8003012:	f47f af62 	bne.w	8002eda <find_volume+0x306>
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 8003016:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
 800301a:	29e9      	cmp	r1, #233	; 0xe9
 800301c:	d006      	beq.n	800302c <find_volume+0x458>
 800301e:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8003020:	4897      	ldr	r0, [pc, #604]	; (8003280 <find_volume+0x6ac>)
 8003022:	f001 11ff 	and.w	r1, r1, #16711935	; 0xff00ff
 8003026:	4281      	cmp	r1, r0
 8003028:	f47f af57 	bne.w	8002eda <find_volume+0x306>
	rv = rv << 8 | ptr[2];
 800302c:	f8b4 7068 	ldrh.w	r7, [r4, #104]	; 0x68
	rv = rv << 8 | ptr[1];
 8003030:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
	rv = rv << 8 | ptr[0];
 8003034:	f894 1066 	ldrb.w	r1, [r4, #102]	; 0x66
	rv = rv << 8 | ptr[1];
 8003038:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
	rv = rv << 8 | ptr[0];
 800303c:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8003040:	4890      	ldr	r0, [pc, #576]	; (8003284 <find_volume+0x6b0>)
 8003042:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8003046:	4281      	cmp	r1, r0
 8003048:	f43f ae4d 	beq.w	8002ce6 <find_volume+0x112>
	rv = rv << 8 | ptr[2];
 800304c:	f8b4 7084 	ldrh.w	r7, [r4, #132]	; 0x84
	rv = rv << 8 | ptr[1];
 8003050:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
	rv = rv << 8 | ptr[0];
 8003054:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
	rv = rv << 8 | ptr[1];
 8003058:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 800305c:	4f8a      	ldr	r7, [pc, #552]	; (8003288 <find_volume+0x6b4>)
	rv = rv << 8 | ptr[0];
 800305e:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8003062:	42b9      	cmp	r1, r7
 8003064:	f43f ae3f 	beq.w	8002ce6 <find_volume+0x112>
 8003068:	e737      	b.n	8002eda <find_volume+0x306>
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800306a:	f04f 37ff 	mov.w	r7, #4294967295
 800306e:	2300      	movs	r3, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003070:	42bd      	cmp	r5, r7
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8003072:	70e3      	strb	r3, [r4, #3]
 8003074:	62e7      	str	r7, [r4, #44]	; 0x2c
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003076:	d008      	beq.n	800308a <find_volume+0x4b6>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8003078:	2301      	movs	r3, #1
 800307a:	462a      	mov	r2, r5
 800307c:	4631      	mov	r1, r6
 800307e:	7860      	ldrb	r0, [r4, #1]
 8003080:	f7fe f922 	bl	80012c8 <disk_read>
 8003084:	2800      	cmp	r0, #0
 8003086:	d16b      	bne.n	8003160 <find_volume+0x58c>
			fs->winsect = sector;
 8003088:	62e5      	str	r5, [r4, #44]	; 0x2c
	rv = rv << 8 | ptr[0];
 800308a:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 800308e:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8003092:	f64a 2155 	movw	r1, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 8003096:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800309a:	4288      	cmp	r0, r1
 800309c:	f47f af21 	bne.w	8002ee2 <find_volume+0x30e>
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 80030a0:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
 80030a4:	29e9      	cmp	r1, #233	; 0xe9
 80030a6:	d006      	beq.n	80030b6 <find_volume+0x4e2>
 80030a8:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80030aa:	4875      	ldr	r0, [pc, #468]	; (8003280 <find_volume+0x6ac>)
 80030ac:	f001 11ff 	and.w	r1, r1, #16711935	; 0xff00ff
 80030b0:	4281      	cmp	r1, r0
 80030b2:	f47f af16 	bne.w	8002ee2 <find_volume+0x30e>
	rv = rv << 8 | ptr[2];
 80030b6:	f8b4 7068 	ldrh.w	r7, [r4, #104]	; 0x68
	rv = rv << 8 | ptr[1];
 80030ba:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
	rv = rv << 8 | ptr[0];
 80030be:	f894 1066 	ldrb.w	r1, [r4, #102]	; 0x66
	rv = rv << 8 | ptr[1];
 80030c2:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
	rv = rv << 8 | ptr[0];
 80030c6:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 80030ca:	486e      	ldr	r0, [pc, #440]	; (8003284 <find_volume+0x6b0>)
 80030cc:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80030d0:	4281      	cmp	r1, r0
 80030d2:	f43f ae08 	beq.w	8002ce6 <find_volume+0x112>
	rv = rv << 8 | ptr[2];
 80030d6:	f8b4 7084 	ldrh.w	r7, [r4, #132]	; 0x84
	rv = rv << 8 | ptr[1];
 80030da:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
	rv = rv << 8 | ptr[0];
 80030de:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
	rv = rv << 8 | ptr[1];
 80030e2:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 80030e6:	4f68      	ldr	r7, [pc, #416]	; (8003288 <find_volume+0x6b4>)
	rv = rv << 8 | ptr[0];
 80030e8:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 80030ec:	42b9      	cmp	r1, r7
 80030ee:	f43f adfa 	beq.w	8002ce6 <find_volume+0x112>
 80030f2:	e6f6      	b.n	8002ee2 <find_volume+0x30e>
	rv = rv << 8 | ptr[0];
 80030f4:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 80030f8:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
			fs->winsect = sector;
 80030fc:	62e5      	str	r5, [r4, #44]	; 0x2c
	rv = rv << 8 | ptr[0];
 80030fe:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8003102:	f64a 2155 	movw	r1, #43605	; 0xaa55
 8003106:	4288      	cmp	r0, r1
 8003108:	f47f aee3 	bne.w	8002ed2 <find_volume+0x2fe>
 800310c:	f894 7030 	ldrb.w	r7, [r4, #48]	; 0x30
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 8003110:	2fe9      	cmp	r7, #233	; 0xe9
 8003112:	d006      	beq.n	8003122 <find_volume+0x54e>
 8003114:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8003116:	485a      	ldr	r0, [pc, #360]	; (8003280 <find_volume+0x6ac>)
 8003118:	f001 11ff 	and.w	r1, r1, #16711935	; 0xff00ff
 800311c:	4281      	cmp	r1, r0
 800311e:	f47f aed8 	bne.w	8002ed2 <find_volume+0x2fe>
	rv = rv << 8 | ptr[2];
 8003122:	f8b4 7068 	ldrh.w	r7, [r4, #104]	; 0x68
	rv = rv << 8 | ptr[1];
 8003126:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
	rv = rv << 8 | ptr[0];
 800312a:	f894 1066 	ldrb.w	r1, [r4, #102]	; 0x66
	rv = rv << 8 | ptr[1];
 800312e:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
	rv = rv << 8 | ptr[0];
 8003132:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8003136:	4853      	ldr	r0, [pc, #332]	; (8003284 <find_volume+0x6b0>)
 8003138:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 800313c:	4281      	cmp	r1, r0
 800313e:	f43f add2 	beq.w	8002ce6 <find_volume+0x112>
	rv = rv << 8 | ptr[2];
 8003142:	f8b4 7084 	ldrh.w	r7, [r4, #132]	; 0x84
	rv = rv << 8 | ptr[1];
 8003146:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
	rv = rv << 8 | ptr[0];
 800314a:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
	rv = rv << 8 | ptr[1];
 800314e:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8003152:	4f4d      	ldr	r7, [pc, #308]	; (8003288 <find_volume+0x6b4>)
	rv = rv << 8 | ptr[0];
 8003154:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8003158:	42b9      	cmp	r1, r7
 800315a:	f43f adc4 	beq.w	8002ce6 <find_volume+0x112>
 800315e:	e6b8      	b.n	8002ed2 <find_volume+0x2fe>
			fs->winsect = sector;
 8003160:	62e7      	str	r7, [r4, #44]	; 0x2c
 8003162:	e6be      	b.n	8002ee2 <find_volume+0x30e>
 8003164:	62e7      	str	r7, [r4, #44]	; 0x2c
 8003166:	e6b8      	b.n	8002eda <find_volume+0x306>
	rv = rv << 8 | ptr[0];
 8003168:	f894 e05b 	ldrb.w	lr, [r4, #91]	; 0x5b
 800316c:	f894 c05a 	ldrb.w	ip, [r4, #90]	; 0x5a
		fs->volbase = bsect;							/* Volume start sector */
 8003170:	61e5      	str	r5, [r4, #28]
		fs->database = bsect + sysect;					/* Data start sector */
 8003172:	442e      	add	r6, r5
 8003174:	3002      	adds	r0, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8003176:	44a8      	add	r8, r5
		fs->database = bsect + sysect;					/* Data start sector */
 8003178:	62a6      	str	r6, [r4, #40]	; 0x28
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 800317a:	ea5c 260e 	orrs.w	r6, ip, lr, lsl #8
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800317e:	6160      	str	r0, [r4, #20]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8003180:	f8c4 8020 	str.w	r8, [r4, #32]
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 8003184:	f47f af01 	bne.w	8002f8a <find_volume+0x3b6>
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 8003188:	2f00      	cmp	r7, #0
 800318a:	f47f aefe 	bne.w	8002f8a <find_volume+0x3b6>
	rv = rv << 8 | ptr[2];
 800318e:	f8b4 c05e 	ldrh.w	ip, [r4, #94]	; 0x5e
	rv = rv << 8 | ptr[1];
 8003192:	f894 705d 	ldrb.w	r7, [r4, #93]	; 0x5d
	rv = rv << 8 | ptr[0];
 8003196:	f894 605c 	ldrb.w	r6, [r4, #92]	; 0x5c
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800319a:	0080      	lsls	r0, r0, #2
	rv = rv << 8 | ptr[1];
 800319c:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 80031a0:	f200 10ff 	addw	r0, r0, #511	; 0x1ff
	rv = rv << 8 | ptr[0];
 80031a4:	ea46 2607 	orr.w	r6, r6, r7, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 80031a8:	ebb1 2f50 	cmp.w	r1, r0, lsr #9
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 80031ac:	6266      	str	r6, [r4, #36]	; 0x24
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 80031ae:	f4ff aeec 	bcc.w	8002f8a <find_volume+0x3b6>
	rv = rv << 8 | ptr[0];
 80031b2:	f894 0061 	ldrb.w	r0, [r4, #97]	; 0x61
 80031b6:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
 80031ba:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
		fs->fsi_flag = 0x80;
 80031be:	2680      	movs	r6, #128	; 0x80
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 80031c0:	f04f 30ff 	mov.w	r0, #4294967295
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 80031c4:	2901      	cmp	r1, #1
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 80031c6:	e9c4 0003 	strd	r0, r0, [r4, #12]
		fs->fsi_flag = 0x80;
 80031ca:	7126      	strb	r6, [r4, #4]
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 80031cc:	d00d      	beq.n	80031ea <find_volume+0x616>
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 80031ce:	2203      	movs	r2, #3
 80031d0:	e616      	b.n	8002e00 <find_volume+0x22c>
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 80031d2:	6163      	str	r3, [r4, #20]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 80031d4:	e9c4 5207 	strd	r5, r2, [r4, #28]
		fs->database = bsect + sysect;					/* Data start sector */
 80031d8:	62a6      	str	r6, [r4, #40]	; 0x28
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 80031da:	2f00      	cmp	r7, #0
 80031dc:	f43f aed5 	beq.w	8002f8a <find_volume+0x3b6>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 80031e0:	4472      	add	r2, lr
 80031e2:	6262      	str	r2, [r4, #36]	; 0x24
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 80031e4:	005b      	lsls	r3, r3, #1
 80031e6:	2202      	movs	r2, #2
 80031e8:	e5fe      	b.n	8002de8 <find_volume+0x214>
	if (sector != fs->winsect) {	/* Window offset changed? */
 80031ea:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
			&& move_window(fs, bsect + 1) == FR_OK)
 80031ec:	1c69      	adds	r1, r5, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 80031ee:	4281      	cmp	r1, r0
 80031f0:	d13b      	bne.n	800326a <find_volume+0x696>
	rv = rv << 8 | ptr[0];
 80031f2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 80031f6:	f64a 2255 	movw	r2, #43605	; 0xaa55
			fs->fsi_flag = 0;
 80031fa:	2100      	movs	r1, #0
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 80031fc:	4293      	cmp	r3, r2
			fs->fsi_flag = 0;
 80031fe:	7121      	strb	r1, [r4, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8003200:	d1e5      	bne.n	80031ce <find_volume+0x5fa>
	rv = rv << 8 | ptr[2];
 8003202:	8e60      	ldrh	r0, [r4, #50]	; 0x32
	rv = rv << 8 | ptr[1];
 8003204:	f894 2031 	ldrb.w	r2, [r4, #49]	; 0x31
	rv = rv << 8 | ptr[0];
 8003208:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 800320c:	491f      	ldr	r1, [pc, #124]	; (800328c <find_volume+0x6b8>)
	rv = rv << 8 | ptr[1];
 800320e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 8003212:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 8003216:	428b      	cmp	r3, r1
 8003218:	d1d9      	bne.n	80031ce <find_volume+0x5fa>
	rv = rv << 8 | ptr[2];
 800321a:	f8b4 0216 	ldrh.w	r0, [r4, #534]	; 0x216
	rv = rv << 8 | ptr[1];
 800321e:	f894 2215 	ldrb.w	r2, [r4, #533]	; 0x215
	rv = rv << 8 | ptr[0];
 8003222:	f894 3214 	ldrb.w	r3, [r4, #532]	; 0x214
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 8003226:	f101 51ff 	add.w	r1, r1, #534773760	; 0x1fe00000
 800322a:	f501 5100 	add.w	r1, r1, #8192	; 0x2000
	rv = rv << 8 | ptr[1];
 800322e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 8003232:	3120      	adds	r1, #32
	rv = rv << 8 | ptr[0];
 8003234:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 8003238:	428b      	cmp	r3, r1
 800323a:	d1c8      	bne.n	80031ce <find_volume+0x5fa>
	rv = rv << 8 | ptr[2];
 800323c:	f8b4 621a 	ldrh.w	r6, [r4, #538]	; 0x21a
	rv = rv << 8 | ptr[1];
 8003240:	f894 0219 	ldrb.w	r0, [r4, #537]	; 0x219
	rv = rv << 8 | ptr[2];
 8003244:	f8b4 521e 	ldrh.w	r5, [r4, #542]	; 0x21e
	rv = rv << 8 | ptr[1];
 8003248:	f894 121d 	ldrb.w	r1, [r4, #541]	; 0x21d
	rv = rv << 8 | ptr[0];
 800324c:	f894 2218 	ldrb.w	r2, [r4, #536]	; 0x218
 8003250:	f894 321c 	ldrb.w	r3, [r4, #540]	; 0x21c
	rv = rv << 8 | ptr[1];
 8003254:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
 8003258:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
	rv = rv << 8 | ptr[0];
 800325c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8003260:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 8003264:	e9c4 3203 	strd	r3, r2, [r4, #12]
 8003268:	e7b1      	b.n	80031ce <find_volume+0x5fa>
 800326a:	4620      	mov	r0, r4
 800326c:	f7fe f856 	bl	800131c <move_window.part.7>
			&& move_window(fs, bsect + 1) == FR_OK)
 8003270:	2800      	cmp	r0, #0
 8003272:	d1ac      	bne.n	80031ce <find_volume+0x5fa>
 8003274:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 8003278:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
 800327c:	e7b9      	b.n	80031f2 <find_volume+0x61e>
 800327e:	bf00      	nop
 8003280:	009000eb 	.word	0x009000eb
 8003284:	00544146 	.word	0x00544146
 8003288:	33544146 	.word	0x33544146
 800328c:	41615252 	.word	0x41615252

08003290 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8003290:	b530      	push	{r4, r5, lr}
 8003292:	b083      	sub	sp, #12
 8003294:	e9cd 1000 	strd	r1, r0, [sp]
	if (*path) {	/* If the pointer is not a null */
 8003298:	b379      	cbz	r1, 80032fa <f_mount+0x6a>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 800329a:	780c      	ldrb	r4, [r1, #0]
 800329c:	2c20      	cmp	r4, #32
 800329e:	d909      	bls.n	80032b4 <f_mount+0x24>
 80032a0:	2c3a      	cmp	r4, #58	; 0x3a
 80032a2:	d02a      	beq.n	80032fa <f_mount+0x6a>
 80032a4:	4608      	mov	r0, r1
 80032a6:	e001      	b.n	80032ac <f_mount+0x1c>
 80032a8:	2b3a      	cmp	r3, #58	; 0x3a
 80032aa:	d01f      	beq.n	80032ec <f_mount+0x5c>
 80032ac:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80032b0:	2b20      	cmp	r3, #32
 80032b2:	d8f9      	bhi.n	80032a8 <f_mount+0x18>
		vol = 0;		/* Drive 0 */
 80032b4:	2500      	movs	r5, #0


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
	cfs = FatFs[vol];					/* Pointer to fs object */
 80032b6:	4918      	ldr	r1, [pc, #96]	; (8003318 <f_mount+0x88>)
 80032b8:	f851 3025 	ldr.w	r3, [r1, r5, lsl #2]

	if (cfs) {
 80032bc:	b163      	cbz	r3, 80032d8 <f_mount+0x48>
		if (Files[i].fs == fs) Files[i].fs = 0;
 80032be:	4817      	ldr	r0, [pc, #92]	; (800331c <f_mount+0x8c>)
 80032c0:	6804      	ldr	r4, [r0, #0]
 80032c2:	42a3      	cmp	r3, r4
 80032c4:	bf04      	itt	eq
 80032c6:	2400      	moveq	r4, #0
 80032c8:	6004      	streq	r4, [r0, #0]
 80032ca:	6904      	ldr	r4, [r0, #16]
 80032cc:	429c      	cmp	r4, r3
 80032ce:	bf04      	itt	eq
 80032d0:	2400      	moveq	r4, #0
 80032d2:	6104      	streq	r4, [r0, #16]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 80032d4:	2000      	movs	r0, #0
 80032d6:	7018      	strb	r0, [r3, #0]
	}

	if (fs) {
 80032d8:	9b01      	ldr	r3, [sp, #4]
 80032da:	b18b      	cbz	r3, 8003300 <f_mount+0x70>
		fs->fs_type = 0;				/* Clear new fs object */
 80032dc:	2000      	movs	r0, #0
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80032de:	2a01      	cmp	r2, #1
		fs->fs_type = 0;				/* Clear new fs object */
 80032e0:	7018      	strb	r0, [r3, #0]
	FatFs[vol] = fs;					/* Register new fs object */
 80032e2:	f841 3025 	str.w	r3, [r1, r5, lsl #2]
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80032e6:	d010      	beq.n	800330a <f_mount+0x7a>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 80032e8:	b003      	add	sp, #12
 80032ea:	bd30      	pop	{r4, r5, pc}
			i = *tp++ - '0';
 80032ec:	3101      	adds	r1, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 80032ee:	4288      	cmp	r0, r1
			i = *tp++ - '0';
 80032f0:	f1a4 0530 	sub.w	r5, r4, #48	; 0x30
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 80032f4:	d101      	bne.n	80032fa <f_mount+0x6a>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 80032f6:	2c30      	cmp	r4, #48	; 0x30
 80032f8:	d0dd      	beq.n	80032b6 <f_mount+0x26>
	if (vol < 0) return FR_INVALID_DRIVE;
 80032fa:	200b      	movs	r0, #11
}
 80032fc:	b003      	add	sp, #12
 80032fe:	bd30      	pop	{r4, r5, pc}
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8003300:	4618      	mov	r0, r3
	FatFs[vol] = fs;					/* Register new fs object */
 8003302:	f841 3025 	str.w	r3, [r1, r5, lsl #2]
}
 8003306:	b003      	add	sp, #12
 8003308:	bd30      	pop	{r4, r5, pc}
	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 800330a:	4602      	mov	r2, r0
 800330c:	a901      	add	r1, sp, #4
 800330e:	4668      	mov	r0, sp
 8003310:	f7ff fc60 	bl	8002bd4 <find_volume>
}
 8003314:	b003      	add	sp, #12
 8003316:	bd30      	pop	{r4, r5, pc}
 8003318:	200000ac 	.word	0x200000ac
 800331c:	200000b0 	.word	0x200000b0

08003320 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8003320:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003324:	b091      	sub	sp, #68	; 0x44
 8003326:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 8003328:	2800      	cmp	r0, #0
 800332a:	d03b      	beq.n	80033a4 <f_open+0x84>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 800332c:	f002 073f 	and.w	r7, r2, #63	; 0x3f
 8003330:	4604      	mov	r4, r0
 8003332:	4615      	mov	r5, r2
	res = find_volume(&path, &fs, mode);
 8003334:	a903      	add	r1, sp, #12
 8003336:	463a      	mov	r2, r7
 8003338:	a801      	add	r0, sp, #4
 800333a:	f7ff fc4b 	bl	8002bd4 <find_volume>
	if (res == FR_OK) {
 800333e:	4606      	mov	r6, r0
 8003340:	b128      	cbz	r0, 800334e <f_open+0x2e>
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8003342:	2300      	movs	r3, #0
 8003344:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 8003346:	4630      	mov	r0, r6
 8003348:	b011      	add	sp, #68	; 0x44
 800334a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dj.obj.fs = fs;
 800334e:	9b03      	ldr	r3, [sp, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 8003350:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 8003352:	9304      	str	r3, [sp, #16]
		res = follow_path(&dj, path);	/* Follow the file path */
 8003354:	a804      	add	r0, sp, #16
 8003356:	f7ff faaf 	bl	80028b8 <follow_path>
 800335a:	f005 0c1c 	and.w	ip, r5, #28
 800335e:	4603      	mov	r3, r0
		if (res == FR_OK) {
 8003360:	bb28      	cbnz	r0, 80033ae <f_open+0x8e>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 8003362:	f99d 303f 	ldrsb.w	r3, [sp, #63]	; 0x3f
 8003366:	2b00      	cmp	r3, #0
 8003368:	f2c0 80fc 	blt.w	8003564 <f_open+0x244>
		if (Files[i].fs) {	/* Existing entry */
 800336c:	f8df 8394 	ldr.w	r8, [pc, #916]	; 8003704 <f_open+0x3e4>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8003370:	9b04      	ldr	r3, [sp, #16]
		if (Files[i].fs) {	/* Existing entry */
 8003372:	f8d8 1000 	ldr.w	r1, [r8]
				Files[i].clu == dp->obj.sclust &&
 8003376:	f8dd b018 	ldr.w	fp, [sp, #24]
				Files[i].ofs == dp->dptr) break;
 800337a:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800337e:	f027 0201 	bic.w	r2, r7, #1
		if (Files[i].fs) {	/* Existing entry */
 8003382:	2900      	cmp	r1, #0
 8003384:	f000 8108 	beq.w	8003598 <f_open+0x278>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8003388:	428b      	cmp	r3, r1
 800338a:	d030      	beq.n	80033ee <f_open+0xce>
		if (Files[i].fs) {	/* Existing entry */
 800338c:	f8d8 1010 	ldr.w	r1, [r8, #16]
 8003390:	2900      	cmp	r1, #0
 8003392:	d046      	beq.n	8003422 <f_open+0x102>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8003394:	428b      	cmp	r3, r1
 8003396:	d034      	beq.n	8003402 <f_open+0xe2>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8003398:	f1bc 0f00 	cmp.w	ip, #0
 800339c:	d018      	beq.n	80033d0 <f_open+0xb0>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 800339e:	2312      	movs	r3, #18
 80033a0:	461e      	mov	r6, r3
 80033a2:	e7ce      	b.n	8003342 <f_open+0x22>
	if (!fp) return FR_INVALID_OBJECT;
 80033a4:	2609      	movs	r6, #9
}
 80033a6:	4630      	mov	r0, r6
 80033a8:	b011      	add	sp, #68	; 0x44
 80033aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 80033ae:	f1bc 0f00 	cmp.w	ip, #0
 80033b2:	d01a      	beq.n	80033ea <f_open+0xca>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 80033b4:	2804      	cmp	r0, #4
 80033b6:	d1f3      	bne.n	80033a0 <f_open+0x80>
	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80033b8:	f8df 8348 	ldr.w	r8, [pc, #840]	; 8003704 <f_open+0x3e4>
 80033bc:	f8d8 3000 	ldr.w	r3, [r8]
 80033c0:	2b00      	cmp	r3, #0
 80033c2:	f000 8101 	beq.w	80035c8 <f_open+0x2a8>
 80033c6:	f8d8 3010 	ldr.w	r3, [r8, #16]
 80033ca:	2b00      	cmp	r3, #0
 80033cc:	f000 80fc 	beq.w	80035c8 <f_open+0x2a8>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 80033d0:	2612      	movs	r6, #18
 80033d2:	e7b6      	b.n	8003342 <f_open+0x22>
 80033d4:	4648      	mov	r0, r9
 80033d6:	4651      	mov	r1, sl
 80033d8:	f7fd ffa0 	bl	800131c <move_window.part.7>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 80033dc:	f8dd 900c 	ldr.w	r9, [sp, #12]
 80033e0:	f8c9 500c 	str.w	r5, [r9, #12]
		if (res == FR_OK) {
 80033e4:	2800      	cmp	r0, #0
 80033e6:	f000 8139 	beq.w	800365c <f_open+0x33c>
 80033ea:	4606      	mov	r6, r0
 80033ec:	e7a9      	b.n	8003342 <f_open+0x22>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 80033ee:	f8d8 1004 	ldr.w	r1, [r8, #4]
 80033f2:	458b      	cmp	fp, r1
 80033f4:	f000 8162 	beq.w	80036bc <f_open+0x39c>
		if (Files[i].fs) {	/* Existing entry */
 80033f8:	f8d8 1010 	ldr.w	r1, [r8, #16]
 80033fc:	b189      	cbz	r1, 8003422 <f_open+0x102>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 80033fe:	4299      	cmp	r1, r3
 8003400:	d1ca      	bne.n	8003398 <f_open+0x78>
 8003402:	f8d8 1014 	ldr.w	r1, [r8, #20]
 8003406:	4559      	cmp	r1, fp
 8003408:	d1c6      	bne.n	8003398 <f_open+0x78>
				Files[i].clu == dp->obj.sclust &&
 800340a:	f8d8 1018 	ldr.w	r1, [r8, #24]
 800340e:	4571      	cmp	r1, lr
 8003410:	d1c2      	bne.n	8003398 <f_open+0x78>
 8003412:	2101      	movs	r1, #1
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8003414:	b992      	cbnz	r2, 800343c <f_open+0x11c>
 8003416:	eb08 1101 	add.w	r1, r8, r1, lsl #4
 800341a:	8989      	ldrh	r1, [r1, #12]
 800341c:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8003420:	d00c      	beq.n	800343c <f_open+0x11c>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8003422:	f1bc 0f00 	cmp.w	ip, #0
 8003426:	d00f      	beq.n	8003448 <f_open+0x128>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8003428:	f89d 1016 	ldrb.w	r1, [sp, #22]
 800342c:	f011 0f11 	tst.w	r1, #17
 8003430:	d113      	bne.n	800345a <f_open+0x13a>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 8003432:	0769      	lsls	r1, r5, #29
 8003434:	f140 80ab 	bpl.w	800358e <f_open+0x26e>
 8003438:	2608      	movs	r6, #8
 800343a:	e782      	b.n	8003342 <f_open+0x22>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800343c:	f1bc 0f00 	cmp.w	ip, #0
 8003440:	f040 80bf 	bne.w	80035c2 <f_open+0x2a2>
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8003444:	2610      	movs	r6, #16
 8003446:	e77c      	b.n	8003342 <f_open+0x22>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 8003448:	f89d 1016 	ldrb.w	r1, [sp, #22]
 800344c:	06c8      	lsls	r0, r1, #27
 800344e:	f100 80b6 	bmi.w	80035be <f_open+0x29e>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 8003452:	07a8      	lsls	r0, r5, #30
 8003454:	d503      	bpl.n	800345e <f_open+0x13e>
 8003456:	07c8      	lsls	r0, r1, #31
 8003458:	d501      	bpl.n	800345e <f_open+0x13e>
						res = FR_DENIED;
 800345a:	2607      	movs	r6, #7
 800345c:	e771      	b.n	8003342 <f_open+0x22>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 800345e:	0729      	lsls	r1, r5, #28
 8003460:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8003464:	d503      	bpl.n	800346e <f_open+0x14e>
				mode |= FA_MODIFIED;
 8003466:	f047 0740 	orr.w	r7, r7, #64	; 0x40
 800346a:	f027 0201 	bic.w	r2, r7, #1
		if (Files[i].fs == dp->obj.fs &&
 800346e:	f8d8 1000 	ldr.w	r1, [r8]
			fp->dir_ptr = dj.dir;
 8003472:	9d0c      	ldr	r5, [sp, #48]	; 0x30
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 8003474:	f8d9 002c 	ldr.w	r0, [r9, #44]	; 0x2c
		if (Files[i].fs == dp->obj.fs &&
 8003478:	428b      	cmp	r3, r1
			fp->dir_ptr = dj.dir;
 800347a:	e9c4 0509 	strd	r0, r5, [r4, #36]	; 0x24
		if (Files[i].fs == dp->obj.fs &&
 800347e:	d07a      	beq.n	8003576 <f_open+0x256>
 8003480:	f8d8 a010 	ldr.w	sl, [r8, #16]
 8003484:	459a      	cmp	sl, r3
 8003486:	d00a      	beq.n	800349e <f_open+0x17e>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8003488:	2900      	cmp	r1, #0
 800348a:	f000 8102 	beq.w	8003692 <f_open+0x372>
 800348e:	f1ba 0f00 	cmp.w	sl, #0
 8003492:	f000 8124 	beq.w	80036de <f_open+0x3be>
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 8003496:	2300      	movs	r3, #0
 8003498:	6123      	str	r3, [r4, #16]
 800349a:	2602      	movs	r6, #2
 800349c:	e751      	b.n	8003342 <f_open+0x22>
		if (Files[i].fs == dp->obj.fs &&
 800349e:	f8d8 0014 	ldr.w	r0, [r8, #20]
 80034a2:	4558      	cmp	r0, fp
 80034a4:	d1f0      	bne.n	8003488 <f_open+0x168>
			Files[i].clu == dp->obj.sclust &&
 80034a6:	f8d8 0018 	ldr.w	r0, [r8, #24]
 80034aa:	4570      	cmp	r0, lr
 80034ac:	d1ec      	bne.n	8003488 <f_open+0x168>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 80034ae:	f04f 0c01 	mov.w	ip, #1
 80034b2:	ea4f 110c 	mov.w	r1, ip, lsl #4
 80034b6:	eb08 0301 	add.w	r3, r8, r1
 80034ba:	899b      	ldrh	r3, [r3, #12]
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 80034bc:	2a00      	cmp	r2, #0
 80034be:	d153      	bne.n	8003568 <f_open+0x248>
 80034c0:	3301      	adds	r3, #1
 80034c2:	b29b      	uxth	r3, r3
 80034c4:	f10c 0a01 	add.w	sl, ip, #1
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 80034c8:	f8c4 a010 	str.w	sl, [r4, #16]
	if (fs->fs_type == FS_FAT32) {
 80034cc:	f899 2000 	ldrb.w	r2, [r9]
	rv = rv << 8 | ptr[0];
 80034d0:	7ee8      	ldrb	r0, [r5, #27]
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80034d2:	4441      	add	r1, r8
	rv = rv << 8 | ptr[0];
 80034d4:	f895 801a 	ldrb.w	r8, [r5, #26]
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80034d8:	818b      	strh	r3, [r1, #12]
	if (fs->fs_type == FS_FAT32) {
 80034da:	2a03      	cmp	r2, #3
	cl = ld_word(dir + DIR_FstClusLO);
 80034dc:	ea48 2800 	orr.w	r8, r8, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 80034e0:	d105      	bne.n	80034ee <f_open+0x1ce>
	rv = rv << 8 | ptr[0];
 80034e2:	7d6a      	ldrb	r2, [r5, #21]
 80034e4:	7d2b      	ldrb	r3, [r5, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 80034e6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80034ea:	ea48 4803 	orr.w	r8, r8, r3, lsl #16
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 80034ee:	f8c4 8008 	str.w	r8, [r4, #8]
	rv = rv << 8 | ptr[2];
 80034f2:	8be9      	ldrh	r1, [r5, #30]
	rv = rv << 8 | ptr[1];
 80034f4:	7f6b      	ldrb	r3, [r5, #29]
	rv = rv << 8 | ptr[0];
 80034f6:	7f2d      	ldrb	r5, [r5, #28]
			fp->obj.id = fs->id;
 80034f8:	f8b9 2006 	ldrh.w	r2, [r9, #6]
 80034fc:	80a2      	strh	r2, [r4, #4]
	rv = rv << 8 | ptr[1];
 80034fe:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 8003502:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
			fp->cltbl = 0;			/* Disable fast seek mode */
 8003506:	2100      	movs	r1, #0
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 8003508:	f104 0a30 	add.w	sl, r4, #48	; 0x30
			fp->flag = mode;		/* Set file access mode */
 800350c:	7527      	strb	r7, [r4, #20]
			fp->obj.fs = fs;	 	/* Validate the file object */
 800350e:	f8c4 9000 	str.w	r9, [r4]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 8003512:	60e5      	str	r5, [r4, #12]
			fp->cltbl = 0;			/* Disable fast seek mode */
 8003514:	62e1      	str	r1, [r4, #44]	; 0x2c
			fp->err = 0;			/* Clear error flag */
 8003516:	7561      	strb	r1, [r4, #21]
			fp->sect = 0;			/* Invalidate current data sector */
 8003518:	6221      	str	r1, [r4, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
 800351a:	61a1      	str	r1, [r4, #24]
 800351c:	4650      	mov	r0, sl
 800351e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003522:	f003 ffb5 	bl	8007490 <memset>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 8003526:	06bf      	lsls	r7, r7, #26
 8003528:	f57f af0d 	bpl.w	8003346 <f_open+0x26>
 800352c:	2d00      	cmp	r5, #0
 800352e:	f43f af0a 	beq.w	8003346 <f_open+0x26>
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8003532:	f8b9 700a 	ldrh.w	r7, [r9, #10]
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 8003536:	61a5      	str	r5, [r4, #24]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8003538:	027f      	lsls	r7, r7, #9
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800353a:	42af      	cmp	r7, r5
 800353c:	f080 8094 	bcs.w	8003668 <f_open+0x348>
					clst = get_fat(&fp->obj, clst);
 8003540:	4641      	mov	r1, r8
 8003542:	6820      	ldr	r0, [r4, #0]
 8003544:	f7fe fd2a 	bl	8001f9c <get_fat.isra.10>
					if (clst <= 1) res = FR_INT_ERR;
 8003548:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
 800354a:	4680      	mov	r8, r0
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800354c:	eba5 0507 	sub.w	r5, r5, r7
					if (clst <= 1) res = FR_INT_ERR;
 8003550:	d906      	bls.n	8003560 <f_open+0x240>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 8003552:	f1b0 3fff 	cmp.w	r0, #4294967295
 8003556:	d1f0      	bne.n	800353a <f_open+0x21a>
 8003558:	2601      	movs	r6, #1
				fp->clust = clst;
 800355a:	f8c4 801c 	str.w	r8, [r4, #28]
 800355e:	e6f0      	b.n	8003342 <f_open+0x22>
					if (clst <= 1) res = FR_INT_ERR;
 8003560:	2602      	movs	r6, #2
 8003562:	e7fa      	b.n	800355a <f_open+0x23a>
				res = FR_INVALID_NAME;
 8003564:	2606      	movs	r6, #6
 8003566:	e6ec      	b.n	8003342 <f_open+0x22>
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8003568:	2b00      	cmp	r3, #0
 800356a:	d194      	bne.n	8003496 <f_open+0x176>
 800356c:	f10c 0a01 	add.w	sl, ip, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8003570:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003574:	e7a8      	b.n	80034c8 <f_open+0x1a8>
		if (Files[i].fs == dp->obj.fs &&
 8003576:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800357a:	4583      	cmp	fp, r0
 800357c:	d180      	bne.n	8003480 <f_open+0x160>
			Files[i].clu == dp->obj.sclust &&
 800357e:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8003582:	4586      	cmp	lr, r0
 8003584:	f47f af7c 	bne.w	8003480 <f_open+0x160>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8003588:	f04f 0c00 	mov.w	ip, #0
 800358c:	e791      	b.n	80034b2 <f_open+0x192>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 800358e:	072d      	lsls	r5, r5, #28
 8003590:	d422      	bmi.n	80035d8 <f_open+0x2b8>
 8003592:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8003596:	e76a      	b.n	800346e <f_open+0x14e>
		if (Files[i].fs) {	/* Existing entry */
 8003598:	f8d8 1010 	ldr.w	r1, [r8, #16]
 800359c:	2900      	cmp	r1, #0
 800359e:	f43f af40 	beq.w	8003422 <f_open+0x102>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 80035a2:	4299      	cmp	r1, r3
 80035a4:	f47f af3d 	bne.w	8003422 <f_open+0x102>
 80035a8:	f8d8 1014 	ldr.w	r1, [r8, #20]
 80035ac:	4559      	cmp	r1, fp
 80035ae:	f47f af38 	bne.w	8003422 <f_open+0x102>
				Files[i].clu == dp->obj.sclust &&
 80035b2:	f8d8 1018 	ldr.w	r1, [r8, #24]
 80035b6:	458e      	cmp	lr, r1
 80035b8:	f47f af33 	bne.w	8003422 <f_open+0x102>
 80035bc:	e729      	b.n	8003412 <f_open+0xf2>
					res = FR_NO_FILE;
 80035be:	2604      	movs	r6, #4
 80035c0:	e6bf      	b.n	8003342 <f_open+0x22>
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 80035c2:	2310      	movs	r3, #16
 80035c4:	461e      	mov	r6, r3
 80035c6:	e6bc      	b.n	8003342 <f_open+0x22>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 80035c8:	a804      	add	r0, sp, #16
 80035ca:	f7fe ffc3 	bl	8002554 <dir_register>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80035ce:	f047 0708 	orr.w	r7, r7, #8
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 80035d2:	2800      	cmp	r0, #0
 80035d4:	f47f af09 	bne.w	80033ea <f_open+0xca>
				dw = GET_FATTIME();
 80035d8:	f002 f822 	bl	8005620 <get_fattime>
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
 80035dc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 80035de:	f8dd 900c 	ldr.w	r9, [sp, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 80035e2:	b2c5      	uxtb	r5, r0
	*ptr++ = (BYTE)val; val >>= 8;
 80035e4:	f3c0 2107 	ubfx	r1, r0, #8, #8
	*ptr++ = (BYTE)val; val >>= 8;
 80035e8:	f3c0 4207 	ubfx	r2, r0, #16, #8
	*ptr++ = (BYTE)val;
 80035ec:	0e00      	lsrs	r0, r0, #24
	*ptr++ = (BYTE)val; val >>= 8;
 80035ee:	739d      	strb	r5, [r3, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 80035f0:	73d9      	strb	r1, [r3, #15]
	*ptr++ = (BYTE)val; val >>= 8;
 80035f2:	741a      	strb	r2, [r3, #16]
	*ptr++ = (BYTE)val;
 80035f4:	7458      	strb	r0, [r3, #17]
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
 80035f6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 80035f8:	759d      	strb	r5, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 80035fa:	75d9      	strb	r1, [r3, #23]
	*ptr++ = (BYTE)val; val >>= 8;
 80035fc:	761a      	strb	r2, [r3, #24]
	*ptr++ = (BYTE)val;
 80035fe:	7658      	strb	r0, [r3, #25]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 8003600:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003602:	2220      	movs	r2, #32
 8003604:	72da      	strb	r2, [r3, #11]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 8003606:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	if (fs->fs_type == FS_FAT32) {
 8003608:	f899 2000 	ldrb.w	r2, [r9]
	rv = rv << 8 | ptr[0];
 800360c:	7ed9      	ldrb	r1, [r3, #27]
 800360e:	7e9d      	ldrb	r5, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 8003610:	2a03      	cmp	r2, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8003612:	ea45 2501 	orr.w	r5, r5, r1, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8003616:	d05b      	beq.n	80036d0 <f_open+0x3b0>
	*ptr++ = (BYTE)val; val >>= 8;
 8003618:	2200      	movs	r2, #0
 800361a:	769a      	strb	r2, [r3, #26]
	*ptr++ = (BYTE)val;
 800361c:	76da      	strb	r2, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 800361e:	f899 1000 	ldrb.w	r1, [r9]
 8003622:	2903      	cmp	r1, #3
 8003624:	d051      	beq.n	80036ca <f_open+0x3aa>
					st_dword(dj.dir + DIR_FileSize, 0);
 8003626:	990c      	ldr	r1, [sp, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 8003628:	2200      	movs	r2, #0
					fs->wflag = 1;
 800362a:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val; val >>= 8;
 800362c:	61ca      	str	r2, [r1, #28]
					fs->wflag = 1;
 800362e:	f889 3003 	strb.w	r3, [r9, #3]
					if (cl) {							/* Remove the cluster chain if exist */
 8003632:	b19d      	cbz	r5, 800365c <f_open+0x33c>
						res = remove_chain(&dj.obj, cl, 0);
 8003634:	a804      	add	r0, sp, #16
 8003636:	4629      	mov	r1, r5
						dw = fs->winsect;
 8003638:	f8d9 a02c 	ldr.w	sl, [r9, #44]	; 0x2c
						res = remove_chain(&dj.obj, cl, 0);
 800363c:	f7fe f87e 	bl	800173c <remove_chain>
						if (res == FR_OK) {
 8003640:	2800      	cmp	r0, #0
 8003642:	f47f aed2 	bne.w	80033ea <f_open+0xca>
							res = move_window(fs, dw);
 8003646:	f8dd 900c 	ldr.w	r9, [sp, #12]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800364a:	f8d9 302c 	ldr.w	r3, [r9, #44]	; 0x2c
 800364e:	459a      	cmp	sl, r3
 8003650:	f105 35ff 	add.w	r5, r5, #4294967295
 8003654:	f47f aebe 	bne.w	80033d4 <f_open+0xb4>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8003658:	f8c9 500c 	str.w	r5, [r9, #12]
 800365c:	9b04      	ldr	r3, [sp, #16]
 800365e:	f8dd b018 	ldr.w	fp, [sp, #24]
 8003662:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
 8003666:	e6fe      	b.n	8003466 <f_open+0x146>
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8003668:	f3c5 0308 	ubfx	r3, r5, #0, #9
				fp->clust = clst;
 800366c:	f8c4 801c 	str.w	r8, [r4, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8003670:	2b00      	cmp	r3, #0
 8003672:	f43f ae68 	beq.w	8003346 <f_open+0x26>
					if ((sc = clust2sect(fs, clst)) == 0) {
 8003676:	9b03      	ldr	r3, [sp, #12]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8003678:	695a      	ldr	r2, [r3, #20]
	clst -= 2;
 800367a:	f1a8 0802 	sub.w	r8, r8, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800367e:	3a02      	subs	r2, #2
 8003680:	4590      	cmp	r8, r2
 8003682:	d204      	bcs.n	800368e <f_open+0x36e>
	return clst * fs->csize + fs->database;
 8003684:	895a      	ldrh	r2, [r3, #10]
 8003686:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8003688:	fb08 1202 	mla	r2, r8, r2, r1
					if ((sc = clust2sect(fs, clst)) == 0) {
 800368c:	bb62      	cbnz	r2, 80036e8 <f_open+0x3c8>
 800368e:	2602      	movs	r6, #2
 8003690:	e657      	b.n	8003342 <f_open+0x22>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8003692:	468c      	mov	ip, r1
 8003694:	f04f 0a01 	mov.w	sl, #1
		Files[i].fs = dp->obj.fs;
 8003698:	ea4f 110c 	mov.w	r1, ip, lsl #4
 800369c:	eb08 0c01 	add.w	ip, r8, r1
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 80036a0:	2a00      	cmp	r2, #0
		Files[i].ctr = 0;
 80036a2:	f04f 0200 	mov.w	r2, #0
		Files[i].fs = dp->obj.fs;
 80036a6:	f848 3001 	str.w	r3, [r8, r1]
		Files[i].ofs = dp->dptr;
 80036aa:	e9cc be01 	strd	fp, lr, [ip, #4]
		Files[i].ctr = 0;
 80036ae:	f8ac 200c 	strh.w	r2, [ip, #12]
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 80036b2:	bf14      	ite	ne
 80036b4:	f44f 7380 	movne.w	r3, #256	; 0x100
 80036b8:	2301      	moveq	r3, #1
 80036ba:	e705      	b.n	80034c8 <f_open+0x1a8>
				Files[i].clu == dp->obj.sclust &&
 80036bc:	f8d8 1008 	ldr.w	r1, [r8, #8]
 80036c0:	458e      	cmp	lr, r1
 80036c2:	f47f ae99 	bne.w	80033f8 <f_open+0xd8>
	for (i = be = 0; i < _FS_LOCK; i++) {
 80036c6:	4631      	mov	r1, r6
 80036c8:	e6a4      	b.n	8003414 <f_open+0xf4>
	*ptr++ = (BYTE)val; val >>= 8;
 80036ca:	751a      	strb	r2, [r3, #20]
	*ptr++ = (BYTE)val;
 80036cc:	755a      	strb	r2, [r3, #21]
 80036ce:	e7aa      	b.n	8003626 <f_open+0x306>
	rv = rv << 8 | ptr[0];
 80036d0:	7d59      	ldrb	r1, [r3, #21]
 80036d2:	7d1a      	ldrb	r2, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 80036d4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80036d8:	ea45 4502 	orr.w	r5, r5, r2, lsl #16
 80036dc:	e79c      	b.n	8003618 <f_open+0x2f8>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80036de:	f04f 0a02 	mov.w	sl, #2
 80036e2:	f04f 0c01 	mov.w	ip, #1
 80036e6:	e7d7      	b.n	8003698 <f_open+0x378>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 80036e8:	eb02 2255 	add.w	r2, r2, r5, lsr #9
 80036ec:	6222      	str	r2, [r4, #32]
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 80036ee:	7858      	ldrb	r0, [r3, #1]
 80036f0:	4651      	mov	r1, sl
 80036f2:	2301      	movs	r3, #1
 80036f4:	f7fd fde8 	bl	80012c8 <disk_read>
 80036f8:	2800      	cmp	r0, #0
 80036fa:	f43f ae24 	beq.w	8003346 <f_open+0x26>
 80036fe:	2601      	movs	r6, #1
 8003700:	e61f      	b.n	8003342 <f_open+0x22>
 8003702:	bf00      	nop
 8003704:	200000b0 	.word	0x200000b0

08003708 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 8003708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800370c:	469a      	mov	sl, r3
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 800370e:	2300      	movs	r3, #0
{
 8003710:	b08b      	sub	sp, #44	; 0x2c
	*br = 0;	/* Clear read byte counter */
 8003712:	f8ca 3000 	str.w	r3, [sl]
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8003716:	b148      	cbz	r0, 800372c <f_read+0x24>
 8003718:	6803      	ldr	r3, [r0, #0]
 800371a:	4680      	mov	r8, r0
 800371c:	b133      	cbz	r3, 800372c <f_read+0x24>
 800371e:	4689      	mov	r9, r1
 8003720:	7819      	ldrb	r1, [r3, #0]
 8003722:	b119      	cbz	r1, 800372c <f_read+0x24>
 8003724:	8880      	ldrh	r0, [r0, #4]
 8003726:	88d9      	ldrh	r1, [r3, #6]
 8003728:	4288      	cmp	r0, r1
 800372a:	d005      	beq.n	8003738 <f_read+0x30>
	FRESULT res = FR_INVALID_OBJECT;
 800372c:	2309      	movs	r3, #9
 800372e:	9300      	str	r3, [sp, #0]
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 8003730:	9800      	ldr	r0, [sp, #0]
 8003732:	b00b      	add	sp, #44	; 0x2c
 8003734:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8003738:	7858      	ldrb	r0, [r3, #1]
 800373a:	9201      	str	r2, [sp, #4]
 800373c:	f7fd fdaa 	bl	8001294 <disk_status>
 8003740:	07c1      	lsls	r1, r0, #31
 8003742:	d4f3      	bmi.n	800372c <f_read+0x24>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8003744:	f898 3015 	ldrb.w	r3, [r8, #21]
 8003748:	9300      	str	r3, [sp, #0]
 800374a:	2b00      	cmp	r3, #0
 800374c:	d1f0      	bne.n	8003730 <f_read+0x28>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800374e:	f898 3014 	ldrb.w	r3, [r8, #20]
 8003752:	07da      	lsls	r2, r3, #31
 8003754:	f140 8115 	bpl.w	8003982 <f_read+0x27a>
	remain = fp->obj.objsize - fp->fptr;
 8003758:	f8d8 1018 	ldr.w	r1, [r8, #24]
 800375c:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8003760:	9a01      	ldr	r2, [sp, #4]
 8003762:	1a5b      	subs	r3, r3, r1
 8003764:	4293      	cmp	r3, r2
 8003766:	bf28      	it	cs
 8003768:	4613      	movcs	r3, r2
 800376a:	469b      	mov	fp, r3
	for ( ;  btr;								/* Repeat until all data read */
 800376c:	2b00      	cmp	r3, #0
 800376e:	d0df      	beq.n	8003730 <f_read+0x28>
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8003770:	4643      	mov	r3, r8
 8003772:	f108 0234 	add.w	r2, r8, #52	; 0x34
 8003776:	f853 0b30 	ldr.w	r0, [r3], #48
 800377a:	9301      	str	r3, [sp, #4]
 800377c:	425b      	negs	r3, r3
 800377e:	f003 0303 	and.w	r3, r3, #3
 8003782:	9205      	str	r2, [sp, #20]
 8003784:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
 8003788:	0894      	lsrs	r4, r2, #2
 800378a:	9304      	str	r3, [sp, #16]
 800378c:	9208      	str	r2, [sp, #32]
 800378e:	3330      	adds	r3, #48	; 0x30
 8003790:	f022 0203 	bic.w	r2, r2, #3
 8003794:	f8cd a008 	str.w	sl, [sp, #8]
 8003798:	9407      	str	r4, [sp, #28]
 800379a:	9206      	str	r2, [sp, #24]
 800379c:	9309      	str	r3, [sp, #36]	; 0x24
 800379e:	4682      	mov	sl, r0
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 80037a0:	f3c1 0308 	ubfx	r3, r1, #0, #9
 80037a4:	2b00      	cmp	r3, #0
 80037a6:	d14b      	bne.n	8003840 <f_read+0x138>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 80037a8:	f8ba 600a 	ldrh.w	r6, [sl, #10]
 80037ac:	0a4b      	lsrs	r3, r1, #9
 80037ae:	3e01      	subs	r6, #1
			if (csect == 0) {					/* On the cluster boundary? */
 80037b0:	401e      	ands	r6, r3
 80037b2:	f000 80b7 	beq.w	8003924 <f_read+0x21c>
 80037b6:	f8d8 001c 	ldr.w	r0, [r8, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80037ba:	f8da 3014 	ldr.w	r3, [sl, #20]
	clst -= 2;
 80037be:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80037c0:	3b02      	subs	r3, #2
 80037c2:	4298      	cmp	r0, r3
 80037c4:	f080 80e6 	bcs.w	8003994 <f_read+0x28c>
	return clst * fs->csize + fs->database;
 80037c8:	f8ba 300a 	ldrh.w	r3, [sl, #10]
 80037cc:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
 80037d0:	9203      	str	r2, [sp, #12]
 80037d2:	fb03 f500 	mul.w	r5, r3, r0
			if (!sect) ABORT(fs, FR_INT_ERR);
 80037d6:	18af      	adds	r7, r5, r2
 80037d8:	f000 80dc 	beq.w	8003994 <f_read+0x28c>
			if (cc) {							/* Read maximum contiguous sectors directly */
 80037dc:	ea5f 245b 	movs.w	r4, fp, lsr #9
			sect += csect;
 80037e0:	4437      	add	r7, r6
			if (cc) {							/* Read maximum contiguous sectors directly */
 80037e2:	d015      	beq.n	8003810 <f_read+0x108>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 80037e4:	1932      	adds	r2, r6, r4
 80037e6:	429a      	cmp	r2, r3
					cc = fs->csize - csect;
 80037e8:	bf88      	it	hi
 80037ea:	1b9c      	subhi	r4, r3, r6
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80037ec:	4623      	mov	r3, r4
 80037ee:	463a      	mov	r2, r7
 80037f0:	4649      	mov	r1, r9
 80037f2:	f89a 0001 	ldrb.w	r0, [sl, #1]
 80037f6:	f7fd fd67 	bl	80012c8 <disk_read>
 80037fa:	2800      	cmp	r0, #0
 80037fc:	f000 80c4 	beq.w	8003988 <f_read+0x280>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8003800:	2301      	movs	r3, #1
 8003802:	9300      	str	r3, [sp, #0]
}
 8003804:	9800      	ldr	r0, [sp, #0]
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8003806:	f888 3015 	strb.w	r3, [r8, #21]
}
 800380a:	b00b      	add	sp, #44	; 0x2c
 800380c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 8003810:	f8d8 2020 	ldr.w	r2, [r8, #32]
 8003814:	42ba      	cmp	r2, r7
 8003816:	d00d      	beq.n	8003834 <f_read+0x12c>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8003818:	f998 3014 	ldrsb.w	r3, [r8, #20]
 800381c:	f89a 0001 	ldrb.w	r0, [sl, #1]
 8003820:	2b00      	cmp	r3, #0
 8003822:	f2c0 80bc 	blt.w	800399e <f_read+0x296>
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8003826:	2301      	movs	r3, #1
 8003828:	463a      	mov	r2, r7
 800382a:	9901      	ldr	r1, [sp, #4]
 800382c:	f7fd fd4c 	bl	80012c8 <disk_read>
 8003830:	2800      	cmp	r0, #0
 8003832:	d1e5      	bne.n	8003800 <f_read+0xf8>
 8003834:	f8d8 3018 	ldr.w	r3, [r8, #24]
			fp->sect = sect;
 8003838:	f8c8 7020 	str.w	r7, [r8, #32]
 800383c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003840:	9a01      	ldr	r2, [sp, #4]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8003842:	f5c3 7400 	rsb	r4, r3, #512	; 0x200
 8003846:	1d19      	adds	r1, r3, #4
 8003848:	4411      	add	r1, r2
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 800384a:	18d0      	adds	r0, r2, r3
 800384c:	455c      	cmp	r4, fp
 800384e:	f109 0204 	add.w	r2, r9, #4
 8003852:	bf28      	it	cs
 8003854:	465c      	movcs	r4, fp
 8003856:	4290      	cmp	r0, r2
 8003858:	bf38      	it	cc
 800385a:	4589      	cmpcc	r9, r1
 800385c:	d372      	bcc.n	8003944 <f_read+0x23c>
 800385e:	2c0b      	cmp	r4, #11
 8003860:	d970      	bls.n	8003944 <f_read+0x23c>
 8003862:	4242      	negs	r2, r0
 8003864:	f012 0203 	ands.w	r2, r2, #3
 8003868:	f104 36ff 	add.w	r6, r4, #4294967295
 800386c:	d067      	beq.n	800393e <f_read+0x236>
			*d++ = *s++;
 800386e:	7801      	ldrb	r1, [r0, #0]
 8003870:	f889 1000 	strb.w	r1, [r9]
 8003874:	2a01      	cmp	r2, #1
 8003876:	f100 0101 	add.w	r1, r0, #1
 800387a:	f109 0e01 	add.w	lr, r9, #1
 800387e:	d05c      	beq.n	800393a <f_read+0x232>
 8003880:	7841      	ldrb	r1, [r0, #1]
 8003882:	f889 1001 	strb.w	r1, [r9, #1]
 8003886:	2a03      	cmp	r2, #3
 8003888:	f100 0102 	add.w	r1, r0, #2
 800388c:	f109 0e02 	add.w	lr, r9, #2
		} while (--cnt);
 8003890:	f1a4 0602 	sub.w	r6, r4, #2
 8003894:	d151      	bne.n	800393a <f_read+0x232>
			*d++ = *s++;
 8003896:	7881      	ldrb	r1, [r0, #2]
 8003898:	f889 1002 	strb.w	r1, [r9, #2]
 800389c:	3003      	adds	r0, #3
 800389e:	f109 0e03 	add.w	lr, r9, #3
		} while (--cnt);
 80038a2:	1ee6      	subs	r6, r4, #3
 80038a4:	9901      	ldr	r1, [sp, #4]
 80038a6:	4413      	add	r3, r2
 80038a8:	eba4 0c02 	sub.w	ip, r4, r2
 80038ac:	440b      	add	r3, r1
 80038ae:	444a      	add	r2, r9
 80038b0:	ea4f 079c 	mov.w	r7, ip, lsr #2
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 80038b4:	2100      	movs	r1, #0
 80038b6:	3101      	adds	r1, #1
			*d++ = *s++;
 80038b8:	f853 5b04 	ldr.w	r5, [r3], #4
 80038bc:	f842 5b04 	str.w	r5, [r2], #4
 80038c0:	428f      	cmp	r7, r1
 80038c2:	d8f8      	bhi.n	80038b6 <f_read+0x1ae>
 80038c4:	f02c 0303 	bic.w	r3, ip, #3
 80038c8:	459c      	cmp	ip, r3
 80038ca:	eba6 0603 	sub.w	r6, r6, r3
 80038ce:	eb0e 0203 	add.w	r2, lr, r3
 80038d2:	eb00 0103 	add.w	r1, r0, r3
 80038d6:	d016      	beq.n	8003906 <f_read+0x1fe>
 80038d8:	5cc0      	ldrb	r0, [r0, r3]
 80038da:	f80e 0003 	strb.w	r0, [lr, r3]
		} while (--cnt);
 80038de:	2e01      	cmp	r6, #1
 80038e0:	d011      	beq.n	8003906 <f_read+0x1fe>
			*d++ = *s++;
 80038e2:	784b      	ldrb	r3, [r1, #1]
 80038e4:	7053      	strb	r3, [r2, #1]
		} while (--cnt);
 80038e6:	2e02      	cmp	r6, #2
 80038e8:	d00d      	beq.n	8003906 <f_read+0x1fe>
			*d++ = *s++;
 80038ea:	788b      	ldrb	r3, [r1, #2]
 80038ec:	7093      	strb	r3, [r2, #2]
		} while (--cnt);
 80038ee:	2e03      	cmp	r6, #3
 80038f0:	d009      	beq.n	8003906 <f_read+0x1fe>
			*d++ = *s++;
 80038f2:	78cb      	ldrb	r3, [r1, #3]
 80038f4:	70d3      	strb	r3, [r2, #3]
		} while (--cnt);
 80038f6:	2e04      	cmp	r6, #4
 80038f8:	d005      	beq.n	8003906 <f_read+0x1fe>
			*d++ = *s++;
 80038fa:	790b      	ldrb	r3, [r1, #4]
 80038fc:	7113      	strb	r3, [r2, #4]
		} while (--cnt);
 80038fe:	2e05      	cmp	r6, #5
 8003900:	d001      	beq.n	8003906 <f_read+0x1fe>
			*d++ = *s++;
 8003902:	794b      	ldrb	r3, [r1, #5]
 8003904:	7153      	strb	r3, [r2, #5]
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8003906:	9a02      	ldr	r2, [sp, #8]
 8003908:	f8d8 1018 	ldr.w	r1, [r8, #24]
 800390c:	6813      	ldr	r3, [r2, #0]
 800390e:	4421      	add	r1, r4
 8003910:	4423      	add	r3, r4
	for ( ;  btr;								/* Repeat until all data read */
 8003912:	ebbb 0b04 	subs.w	fp, fp, r4
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8003916:	f8c8 1018 	str.w	r1, [r8, #24]
 800391a:	44a1      	add	r9, r4
 800391c:	6013      	str	r3, [r2, #0]
	for ( ;  btr;								/* Repeat until all data read */
 800391e:	f47f af3f 	bne.w	80037a0 <f_read+0x98>
 8003922:	e705      	b.n	8003730 <f_read+0x28>
				if (fp->fptr == 0) {			/* On the top of the file? */
 8003924:	b9c1      	cbnz	r1, 8003958 <f_read+0x250>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 8003926:	f8d8 0008 	ldr.w	r0, [r8, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800392a:	2801      	cmp	r0, #1
 800392c:	d932      	bls.n	8003994 <f_read+0x28c>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800392e:	1c43      	adds	r3, r0, #1
 8003930:	f43f af66 	beq.w	8003800 <f_read+0xf8>
				fp->clust = clst;				/* Update current cluster */
 8003934:	f8c8 001c 	str.w	r0, [r8, #28]
 8003938:	e73f      	b.n	80037ba <f_read+0xb2>
			*d++ = *s++;
 800393a:	4608      	mov	r0, r1
 800393c:	e7b2      	b.n	80038a4 <f_read+0x19c>
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 800393e:	46ce      	mov	lr, r9
 8003940:	4626      	mov	r6, r4
 8003942:	e7af      	b.n	80038a4 <f_read+0x19c>
 8003944:	f109 33ff 	add.w	r3, r9, #4294967295
 8003948:	1901      	adds	r1, r0, r4
			*d++ = *s++;
 800394a:	f810 2b01 	ldrb.w	r2, [r0], #1
 800394e:	f803 2f01 	strb.w	r2, [r3, #1]!
		} while (--cnt);
 8003952:	4288      	cmp	r0, r1
 8003954:	d1f9      	bne.n	800394a <f_read+0x242>
 8003956:	e7d6      	b.n	8003906 <f_read+0x1fe>
					if (fp->cltbl) {
 8003958:	f8d8 102c 	ldr.w	r1, [r8, #44]	; 0x2c
 800395c:	f8d8 0000 	ldr.w	r0, [r8]
 8003960:	b369      	cbz	r1, 80039be <f_read+0x2b6>
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8003962:	684a      	ldr	r2, [r1, #4]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8003964:	8940      	ldrh	r0, [r0, #10]
 8003966:	fbb3 f3f0 	udiv	r3, r3, r0
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 800396a:	3104      	adds	r1, #4
		if (ncl == 0) return 0;	/* End of table? (error) */
 800396c:	b922      	cbnz	r2, 8003978 <f_read+0x270>
 800396e:	e011      	b.n	8003994 <f_read+0x28c>
		cl -= ncl; tbl++;		/* Next fragment */
 8003970:	1a9b      	subs	r3, r3, r2
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8003972:	f851 2f08 	ldr.w	r2, [r1, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 8003976:	b16a      	cbz	r2, 8003994 <f_read+0x28c>
		if (cl < ncl) break;	/* In this fragment? */
 8003978:	429a      	cmp	r2, r3
 800397a:	d9f9      	bls.n	8003970 <f_read+0x268>
	return cl + *tbl;	/* Return the cluster number */
 800397c:	6848      	ldr	r0, [r1, #4]
 800397e:	4418      	add	r0, r3
 8003980:	e7d3      	b.n	800392a <f_read+0x222>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8003982:	2307      	movs	r3, #7
 8003984:	9300      	str	r3, [sp, #0]
 8003986:	e6d3      	b.n	8003730 <f_read+0x28>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 8003988:	f998 3014 	ldrsb.w	r3, [r8, #20]
 800398c:	2b00      	cmp	r3, #0
 800398e:	db1b      	blt.n	80039c8 <f_read+0x2c0>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 8003990:	0264      	lsls	r4, r4, #9
				continue;
 8003992:	e7b8      	b.n	8003906 <f_read+0x1fe>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8003994:	2302      	movs	r3, #2
 8003996:	f888 3015 	strb.w	r3, [r8, #21]
 800399a:	9300      	str	r3, [sp, #0]
 800399c:	e6c8      	b.n	8003730 <f_read+0x28>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800399e:	2301      	movs	r3, #1
 80039a0:	9901      	ldr	r1, [sp, #4]
 80039a2:	f7fd fc9f 	bl	80012e4 <disk_write>
 80039a6:	2800      	cmp	r0, #0
 80039a8:	f47f af2a 	bne.w	8003800 <f_read+0xf8>
					fp->flag &= (BYTE)~FA_DIRTY;
 80039ac:	f898 3014 	ldrb.w	r3, [r8, #20]
 80039b0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80039b4:	f888 3014 	strb.w	r3, [r8, #20]
 80039b8:	f89a 0001 	ldrb.w	r0, [sl, #1]
 80039bc:	e733      	b.n	8003826 <f_read+0x11e>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 80039be:	f8d8 101c 	ldr.w	r1, [r8, #28]
 80039c2:	f7fe faeb 	bl	8001f9c <get_fat.isra.10>
 80039c6:	e7b0      	b.n	800392a <f_read+0x222>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 80039c8:	f8d8 2020 	ldr.w	r2, [r8, #32]
 80039cc:	1bd7      	subs	r7, r2, r7
 80039ce:	42a7      	cmp	r7, r4
 80039d0:	d2de      	bcs.n	8003990 <f_read+0x288>
 80039d2:	9b03      	ldr	r3, [sp, #12]
 80039d4:	9805      	ldr	r0, [sp, #20]
 80039d6:	1ad2      	subs	r2, r2, r3
 80039d8:	1b92      	subs	r2, r2, r6
 80039da:	1b52      	subs	r2, r2, r5
 80039dc:	0252      	lsls	r2, r2, #9
 80039de:	eb09 0302 	add.w	r3, r9, r2
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 80039e2:	9d01      	ldr	r5, [sp, #4]
 80039e4:	4298      	cmp	r0, r3
 80039e6:	eb09 2747 	add.w	r7, r9, r7, lsl #9
 80039ea:	4629      	mov	r1, r5
 80039ec:	d903      	bls.n	80039f6 <f_read+0x2ee>
 80039ee:	1d13      	adds	r3, r2, #4
 80039f0:	444b      	add	r3, r9
 80039f2:	429d      	cmp	r5, r3
 80039f4:	d348      	bcc.n	8003a88 <f_read+0x380>
 80039f6:	9804      	ldr	r0, [sp, #16]
 80039f8:	2800      	cmp	r0, #0
 80039fa:	d041      	beq.n	8003a80 <f_read+0x378>
			*d++ = *s++;
 80039fc:	f898 3030 	ldrb.w	r3, [r8, #48]	; 0x30
 8003a00:	703b      	strb	r3, [r7, #0]
 8003a02:	2801      	cmp	r0, #1
 8003a04:	f108 0131 	add.w	r1, r8, #49	; 0x31
 8003a08:	f107 0501 	add.w	r5, r7, #1
 8003a0c:	d035      	beq.n	8003a7a <f_read+0x372>
 8003a0e:	f898 3031 	ldrb.w	r3, [r8, #49]	; 0x31
 8003a12:	707b      	strb	r3, [r7, #1]
 8003a14:	2803      	cmp	r0, #3
 8003a16:	f108 0132 	add.w	r1, r8, #50	; 0x32
 8003a1a:	f107 0502 	add.w	r5, r7, #2
 8003a1e:	d13d      	bne.n	8003a9c <f_read+0x394>
 8003a20:	f898 3032 	ldrb.w	r3, [r8, #50]	; 0x32
 8003a24:	70bb      	strb	r3, [r7, #2]
 8003a26:	1cfd      	adds	r5, r7, #3
 8003a28:	f108 0133 	add.w	r1, r8, #51	; 0x33
 8003a2c:	f240 10fd 	movw	r0, #509	; 0x1fd
 8003a30:	9b04      	ldr	r3, [sp, #16]
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 8003a32:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8003a36:	441a      	add	r2, r3
 8003a38:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003a3a:	444a      	add	r2, r9
 8003a3c:	eb08 0603 	add.w	r6, r8, r3
 8003a40:	2300      	movs	r3, #0
 8003a42:	3301      	adds	r3, #1
			*d++ = *s++;
 8003a44:	f856 7b04 	ldr.w	r7, [r6], #4
 8003a48:	f842 7b04 	str.w	r7, [r2], #4
 8003a4c:	459c      	cmp	ip, r3
 8003a4e:	d8f8      	bhi.n	8003a42 <f_read+0x33a>
 8003a50:	9e06      	ldr	r6, [sp, #24]
 8003a52:	9f08      	ldr	r7, [sp, #32]
 8003a54:	42be      	cmp	r6, r7
 8003a56:	eba0 0006 	sub.w	r0, r0, r6
 8003a5a:	eb05 0306 	add.w	r3, r5, r6
 8003a5e:	eb01 0206 	add.w	r2, r1, r6
 8003a62:	d095      	beq.n	8003990 <f_read+0x288>
 8003a64:	5d89      	ldrb	r1, [r1, r6]
 8003a66:	55a9      	strb	r1, [r5, r6]
		} while (--cnt);
 8003a68:	2801      	cmp	r0, #1
 8003a6a:	d091      	beq.n	8003990 <f_read+0x288>
			*d++ = *s++;
 8003a6c:	7851      	ldrb	r1, [r2, #1]
 8003a6e:	7059      	strb	r1, [r3, #1]
		} while (--cnt);
 8003a70:	2802      	cmp	r0, #2
 8003a72:	d08d      	beq.n	8003990 <f_read+0x288>
			*d++ = *s++;
 8003a74:	7892      	ldrb	r2, [r2, #2]
 8003a76:	709a      	strb	r2, [r3, #2]
 8003a78:	e78a      	b.n	8003990 <f_read+0x288>
 8003a7a:	f240 10ff 	movw	r0, #511	; 0x1ff
 8003a7e:	e7d7      	b.n	8003a30 <f_read+0x328>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 8003a80:	463d      	mov	r5, r7
 8003a82:	f44f 7000 	mov.w	r0, #512	; 0x200
 8003a86:	e7d3      	b.n	8003a30 <f_read+0x328>
 8003a88:	3f01      	subs	r7, #1
 8003a8a:	f508 720c 	add.w	r2, r8, #560	; 0x230
			*d++ = *s++;
 8003a8e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8003a92:	f807 3f01 	strb.w	r3, [r7, #1]!
		} while (--cnt);
 8003a96:	428a      	cmp	r2, r1
 8003a98:	d1f9      	bne.n	8003a8e <f_read+0x386>
 8003a9a:	e779      	b.n	8003990 <f_read+0x288>
			*d++ = *s++;
 8003a9c:	f44f 70ff 	mov.w	r0, #510	; 0x1fe
 8003aa0:	e7c6      	b.n	8003a30 <f_read+0x328>
 8003aa2:	bf00      	nop

08003aa4 <f_close>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8003aa4:	b138      	cbz	r0, 8003ab6 <f_close+0x12>
 8003aa6:	6803      	ldr	r3, [r0, #0]
 8003aa8:	b12b      	cbz	r3, 8003ab6 <f_close+0x12>
 8003aaa:	781a      	ldrb	r2, [r3, #0]
 8003aac:	b11a      	cbz	r2, 8003ab6 <f_close+0x12>
 8003aae:	8881      	ldrh	r1, [r0, #4]
 8003ab0:	88da      	ldrh	r2, [r3, #6]
 8003ab2:	4291      	cmp	r1, r2
 8003ab4:	d001      	beq.n	8003aba <f_close+0x16>
	FRESULT res = FR_INVALID_OBJECT;
 8003ab6:	2009      	movs	r0, #9
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 8003ab8:	4770      	bx	lr
{
 8003aba:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003abe:	4604      	mov	r4, r0
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8003ac0:	7858      	ldrb	r0, [r3, #1]
 8003ac2:	f7fd fbe7 	bl	8001294 <disk_status>
 8003ac6:	07c1      	lsls	r1, r0, #31
 8003ac8:	f100 8086 	bmi.w	8003bd8 <f_close+0x134>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 8003acc:	7d23      	ldrb	r3, [r4, #20]
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8003ace:	6825      	ldr	r5, [r4, #0]
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 8003ad0:	065a      	lsls	r2, r3, #25
 8003ad2:	d574      	bpl.n	8003bbe <f_close+0x11a>
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8003ad4:	061b      	lsls	r3, r3, #24
 8003ad6:	f100 8093 	bmi.w	8003c00 <f_close+0x15c>
			tm = GET_FATTIME();				/* Modified time */
 8003ada:	f001 fda1 	bl	8005620 <get_fattime>
				res = move_window(fs, fp->dir_sect);
 8003ade:	f8d4 8024 	ldr.w	r8, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003ae2:	6aef      	ldr	r7, [r5, #44]	; 0x2c
 8003ae4:	45b8      	cmp	r8, r7
			tm = GET_FATTIME();				/* Modified time */
 8003ae6:	4606      	mov	r6, r0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003ae8:	d033      	beq.n	8003b52 <f_close+0xae>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003aea:	78eb      	ldrb	r3, [r5, #3]
 8003aec:	7868      	ldrb	r0, [r5, #1]
 8003aee:	f105 0930 	add.w	r9, r5, #48	; 0x30
 8003af2:	b303      	cbz	r3, 8003b36 <f_close+0x92>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8003af4:	2301      	movs	r3, #1
 8003af6:	463a      	mov	r2, r7
 8003af8:	4649      	mov	r1, r9
 8003afa:	f7fd fbf3 	bl	80012e4 <disk_write>
 8003afe:	bb18      	cbnz	r0, 8003b48 <f_close+0xa4>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003b00:	6a2a      	ldr	r2, [r5, #32]
 8003b02:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8003b04:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003b06:	1aba      	subs	r2, r7, r2
 8003b08:	429a      	cmp	r2, r3
 8003b0a:	7868      	ldrb	r0, [r5, #1]
 8003b0c:	d213      	bcs.n	8003b36 <f_close+0x92>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003b0e:	f895 a002 	ldrb.w	sl, [r5, #2]
 8003b12:	f1ba 0f01 	cmp.w	sl, #1
 8003b16:	d802      	bhi.n	8003b1e <f_close+0x7a>
 8003b18:	e00d      	b.n	8003b36 <f_close+0x92>
 8003b1a:	69ab      	ldr	r3, [r5, #24]
 8003b1c:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8003b1e:	441f      	add	r7, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003b20:	f10a 3aff 	add.w	sl, sl, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8003b24:	463a      	mov	r2, r7
 8003b26:	2301      	movs	r3, #1
 8003b28:	4649      	mov	r1, r9
 8003b2a:	f7fd fbdb 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003b2e:	f1ba 0f01 	cmp.w	sl, #1
 8003b32:	d1f2      	bne.n	8003b1a <f_close+0x76>
 8003b34:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8003b36:	4649      	mov	r1, r9
 8003b38:	2301      	movs	r3, #1
 8003b3a:	4642      	mov	r2, r8
 8003b3c:	f7fd fbc4 	bl	80012c8 <disk_read>
 8003b40:	b128      	cbz	r0, 8003b4e <f_close+0xaa>
			fs->winsect = sector;
 8003b42:	f04f 33ff 	mov.w	r3, #4294967295
 8003b46:	62eb      	str	r3, [r5, #44]	; 0x2c
				res = FR_DISK_ERR;
 8003b48:	2001      	movs	r0, #1
}
 8003b4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			fs->winsect = sector;
 8003b4e:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
					dir = fp->dir_ptr;
 8003b52:	6aa3      	ldr	r3, [r4, #40]	; 0x28
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
 8003b54:	7ada      	ldrb	r2, [r3, #11]
 8003b56:	f042 0220 	orr.w	r2, r2, #32
 8003b5a:	72da      	strb	r2, [r3, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
 8003b5c:	68a2      	ldr	r2, [r4, #8]
 8003b5e:	6821      	ldr	r1, [r4, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8003b60:	769a      	strb	r2, [r3, #26]
 8003b62:	f3c2 2007 	ubfx	r0, r2, #8, #8
	*ptr++ = (BYTE)val;
 8003b66:	76d8      	strb	r0, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 8003b68:	7809      	ldrb	r1, [r1, #0]
 8003b6a:	2903      	cmp	r1, #3
 8003b6c:	d103      	bne.n	8003b76 <f_close+0xd2>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8003b6e:	0c12      	lsrs	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8003b70:	0a11      	lsrs	r1, r2, #8
 8003b72:	751a      	strb	r2, [r3, #20]
	*ptr++ = (BYTE)val;
 8003b74:	7559      	strb	r1, [r3, #21]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 8003b76:	68e2      	ldr	r2, [r4, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 8003b78:	759e      	strb	r6, [r3, #22]
 8003b7a:	2100      	movs	r1, #0
 8003b7c:	0a10      	lsrs	r0, r2, #8
 8003b7e:	f362 0107 	bfi	r1, r2, #0, #8
 8003b82:	f360 210f 	bfi	r1, r0, #8, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8003b86:	0c10      	lsrs	r0, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8003b88:	f360 4117 	bfi	r1, r0, #16, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8003b8c:	0e12      	lsrs	r2, r2, #24
	*ptr++ = (BYTE)val; val >>= 8;
 8003b8e:	f362 611f 	bfi	r1, r2, #24, #8
 8003b92:	61d9      	str	r1, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 8003b94:	0c30      	lsrs	r0, r6, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8003b96:	2200      	movs	r2, #0
	*ptr++ = (BYTE)val; val >>= 8;
 8003b98:	0a37      	lsrs	r7, r6, #8
					fs->wflag = 1;
 8003b9a:	2101      	movs	r1, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8003b9c:	0e36      	lsrs	r6, r6, #24
 8003b9e:	7618      	strb	r0, [r3, #24]
	*ptr++ = (BYTE)val; val >>= 8;
 8003ba0:	75df      	strb	r7, [r3, #23]
	*ptr++ = (BYTE)val;
 8003ba2:	765e      	strb	r6, [r3, #25]
	*ptr++ = (BYTE)val; val >>= 8;
 8003ba4:	749a      	strb	r2, [r3, #18]
	*ptr++ = (BYTE)val;
 8003ba6:	74da      	strb	r2, [r3, #19]
					res = sync_fs(fs);					/* Restore it to the directory */
 8003ba8:	4628      	mov	r0, r5
					fs->wflag = 1;
 8003baa:	70e9      	strb	r1, [r5, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 8003bac:	f7fd fbf0 	bl	8001390 <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 8003bb0:	7d23      	ldrb	r3, [r4, #20]
 8003bb2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003bb6:	7523      	strb	r3, [r4, #20]
	if (res == FR_OK)
 8003bb8:	2800      	cmp	r0, #0
 8003bba:	d1c6      	bne.n	8003b4a <f_close+0xa6>
 8003bbc:	6825      	ldr	r5, [r4, #0]
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8003bbe:	b15d      	cbz	r5, 8003bd8 <f_close+0x134>
 8003bc0:	782b      	ldrb	r3, [r5, #0]
 8003bc2:	b14b      	cbz	r3, 8003bd8 <f_close+0x134>
 8003bc4:	88a2      	ldrh	r2, [r4, #4]
 8003bc6:	88eb      	ldrh	r3, [r5, #6]
 8003bc8:	429a      	cmp	r2, r3
 8003bca:	d105      	bne.n	8003bd8 <f_close+0x134>
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8003bcc:	7868      	ldrb	r0, [r5, #1]
 8003bce:	f7fd fb61 	bl	8001294 <disk_status>
 8003bd2:	f010 0001 	ands.w	r0, r0, #1
 8003bd6:	d002      	beq.n	8003bde <f_close+0x13a>
	FRESULT res = FR_INVALID_OBJECT;
 8003bd8:	2009      	movs	r0, #9
}
 8003bda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8003bde:	6923      	ldr	r3, [r4, #16]
 8003be0:	3b01      	subs	r3, #1
 8003be2:	2b01      	cmp	r3, #1
 8003be4:	d81a      	bhi.n	8003c1c <f_close+0x178>
		n = Files[i].ctr;
 8003be6:	4912      	ldr	r1, [pc, #72]	; (8003c30 <f_close+0x18c>)
 8003be8:	011b      	lsls	r3, r3, #4
 8003bea:	18cd      	adds	r5, r1, r3
 8003bec:	89aa      	ldrh	r2, [r5, #12]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8003bee:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8003bf2:	d01b      	beq.n	8003c2c <f_close+0x188>
		if (n > 0) n--;				/* Decrement read mode open count */
 8003bf4:	b9a2      	cbnz	r2, 8003c20 <f_close+0x17c>
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8003bf6:	2200      	movs	r2, #0
 8003bf8:	50ca      	str	r2, [r1, r3]
				fp->obj.fs = 0;			/* Invalidate file object */
 8003bfa:	2000      	movs	r0, #0
 8003bfc:	6020      	str	r0, [r4, #0]
 8003bfe:	e7a4      	b.n	8003b4a <f_close+0xa6>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8003c00:	2301      	movs	r3, #1
 8003c02:	6a22      	ldr	r2, [r4, #32]
 8003c04:	7868      	ldrb	r0, [r5, #1]
 8003c06:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8003c0a:	f7fd fb6b 	bl	80012e4 <disk_write>
 8003c0e:	2800      	cmp	r0, #0
 8003c10:	d19a      	bne.n	8003b48 <f_close+0xa4>
				fp->flag &= (BYTE)~FA_DIRTY;
 8003c12:	7d23      	ldrb	r3, [r4, #20]
 8003c14:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8003c18:	7523      	strb	r3, [r4, #20]
 8003c1a:	e75e      	b.n	8003ada <f_close+0x36>
		res = FR_INT_ERR;			/* Invalid index nunber */
 8003c1c:	2002      	movs	r0, #2
 8003c1e:	e794      	b.n	8003b4a <f_close+0xa6>
		if (n > 0) n--;				/* Decrement read mode open count */
 8003c20:	3a01      	subs	r2, #1
 8003c22:	b292      	uxth	r2, r2
		Files[i].ctr = n;
 8003c24:	81aa      	strh	r2, [r5, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8003c26:	2a00      	cmp	r2, #0
 8003c28:	d1e7      	bne.n	8003bfa <f_close+0x156>
 8003c2a:	e7e4      	b.n	8003bf6 <f_close+0x152>
		Files[i].ctr = n;
 8003c2c:	81a8      	strh	r0, [r5, #12]
 8003c2e:	e7e2      	b.n	8003bf6 <f_close+0x152>
 8003c30:	200000b0 	.word	0x200000b0

08003c34 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 8003c34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003c38:	b08b      	sub	sp, #44	; 0x2c
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8003c3a:	b148      	cbz	r0, 8003c50 <f_lseek+0x1c>
 8003c3c:	6803      	ldr	r3, [r0, #0]
 8003c3e:	4683      	mov	fp, r0
 8003c40:	b133      	cbz	r3, 8003c50 <f_lseek+0x1c>
 8003c42:	781a      	ldrb	r2, [r3, #0]
 8003c44:	b122      	cbz	r2, 8003c50 <f_lseek+0x1c>
 8003c46:	460c      	mov	r4, r1
 8003c48:	88da      	ldrh	r2, [r3, #6]
 8003c4a:	8881      	ldrh	r1, [r0, #4]
 8003c4c:	4291      	cmp	r1, r2
 8003c4e:	d005      	beq.n	8003c5c <f_lseek+0x28>
	FRESULT res = FR_INVALID_OBJECT;
 8003c50:	f04f 0a09 	mov.w	sl, #9
			fp->sect = nsect;
		}
	}

	LEAVE_FF(fs, res);
}
 8003c54:	4650      	mov	r0, sl
 8003c56:	b00b      	add	sp, #44	; 0x2c
 8003c58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8003c5c:	7858      	ldrb	r0, [r3, #1]
 8003c5e:	f7fd fb19 	bl	8001294 <disk_status>
 8003c62:	07c6      	lsls	r6, r0, #31
 8003c64:	d4f4      	bmi.n	8003c50 <f_lseek+0x1c>
	if (res == FR_OK) res = (FRESULT)fp->err;
 8003c66:	f89b a015 	ldrb.w	sl, [fp, #21]
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8003c6a:	f8db 9000 	ldr.w	r9, [fp]
	if (res != FR_OK) LEAVE_FF(fs, res);
 8003c6e:	f1ba 0f00 	cmp.w	sl, #0
 8003c72:	d1ef      	bne.n	8003c54 <f_lseek+0x20>
	if (fp->cltbl) {	/* Fast seek */
 8003c74:	f8db 202c 	ldr.w	r2, [fp, #44]	; 0x2c
 8003c78:	2a00      	cmp	r2, #0
 8003c7a:	d04f      	beq.n	8003d1c <f_lseek+0xe8>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 8003c7c:	1c65      	adds	r5, r4, #1
 8003c7e:	f000 80a7 	beq.w	8003dd0 <f_lseek+0x19c>
 8003c82:	f8db 300c 	ldr.w	r3, [fp, #12]
 8003c86:	429c      	cmp	r4, r3
 8003c88:	bf28      	it	cs
 8003c8a:	461c      	movcs	r4, r3
			fp->fptr = ofs;				/* Set file pointer */
 8003c8c:	f8cb 4018 	str.w	r4, [fp, #24]
			if (ofs) {
 8003c90:	2c00      	cmp	r4, #0
 8003c92:	d0df      	beq.n	8003c54 <f_lseek+0x20>
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8003c94:	6853      	ldr	r3, [r2, #4]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8003c96:	f8b9 000a 	ldrh.w	r0, [r9, #10]
				fp->clust = clmt_clust(fp, ofs - 1);
 8003c9a:	1e65      	subs	r5, r4, #1
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8003c9c:	0a6d      	lsrs	r5, r5, #9
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8003c9e:	3204      	adds	r2, #4
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8003ca0:	fbb5 f1f0 	udiv	r1, r5, r0
		if (ncl == 0) return 0;	/* End of table? (error) */
 8003ca4:	b153      	cbz	r3, 8003cbc <f_lseek+0x88>
		if (cl < ncl) break;	/* In this fragment? */
 8003ca6:	4299      	cmp	r1, r3
 8003ca8:	d203      	bcs.n	8003cb2 <f_lseek+0x7e>
 8003caa:	e118      	b.n	8003ede <f_lseek+0x2aa>
 8003cac:	428b      	cmp	r3, r1
 8003cae:	f200 8116 	bhi.w	8003ede <f_lseek+0x2aa>
		cl -= ncl; tbl++;		/* Next fragment */
 8003cb2:	1ac9      	subs	r1, r1, r3
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8003cb4:	f852 3f08 	ldr.w	r3, [r2, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 8003cb8:	2b00      	cmp	r3, #0
 8003cba:	d1f7      	bne.n	8003cac <f_lseek+0x78>
 8003cbc:	f06f 0201 	mvn.w	r2, #1
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8003cc0:	f8d9 1014 	ldr.w	r1, [r9, #20]
				fp->clust = clmt_clust(fp, ofs - 1);
 8003cc4:	f8cb 301c 	str.w	r3, [fp, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8003cc8:	1e8b      	subs	r3, r1, #2
 8003cca:	4293      	cmp	r3, r2
 8003ccc:	f240 80a8 	bls.w	8003e20 <f_lseek+0x1ec>
	return clst * fs->csize + fs->database;
 8003cd0:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
 8003cd4:	fb02 3300 	mla	r3, r2, r0, r3
				if (!dsc) ABORT(fs, FR_INT_ERR);
 8003cd8:	2b00      	cmp	r3, #0
 8003cda:	f000 80a1 	beq.w	8003e20 <f_lseek+0x1ec>
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8003cde:	f3c4 0408 	ubfx	r4, r4, #0, #9
 8003ce2:	2c00      	cmp	r4, #0
 8003ce4:	d0b6      	beq.n	8003c54 <f_lseek+0x20>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8003ce6:	1e44      	subs	r4, r0, #1
 8003ce8:	402c      	ands	r4, r5
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8003cea:	f8db 2020 	ldr.w	r2, [fp, #32]
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8003cee:	441c      	add	r4, r3
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8003cf0:	42a2      	cmp	r2, r4
 8003cf2:	d0af      	beq.n	8003c54 <f_lseek+0x20>
					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8003cf4:	f99b 3014 	ldrsb.w	r3, [fp, #20]
 8003cf8:	f899 0001 	ldrb.w	r0, [r9, #1]
 8003cfc:	2b00      	cmp	r3, #0
 8003cfe:	f10b 0530 	add.w	r5, fp, #48	; 0x30
 8003d02:	f2c0 8255 	blt.w	80041b0 <f_lseek+0x57c>
					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
 8003d06:	4629      	mov	r1, r5
 8003d08:	2301      	movs	r3, #1
 8003d0a:	4622      	mov	r2, r4
 8003d0c:	f7fd fadc 	bl	80012c8 <disk_read>
 8003d10:	2800      	cmp	r0, #0
 8003d12:	f040 81d0 	bne.w	80040b6 <f_lseek+0x482>
					fp->sect = dsc;
 8003d16:	f8cb 4020 	str.w	r4, [fp, #32]
 8003d1a:	e79b      	b.n	8003c54 <f_lseek+0x20>
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 8003d1c:	f8db 300c 	ldr.w	r3, [fp, #12]
 8003d20:	42a3      	cmp	r3, r4
 8003d22:	d205      	bcs.n	8003d30 <f_lseek+0xfc>
 8003d24:	f89b 2014 	ldrb.w	r2, [fp, #20]
 8003d28:	f012 0f02 	tst.w	r2, #2
 8003d2c:	bf08      	it	eq
 8003d2e:	461c      	moveq	r4, r3
		fp->fptr = nsect = 0;
 8003d30:	2200      	movs	r2, #0
		ifptr = fp->fptr;
 8003d32:	f8db 3018 	ldr.w	r3, [fp, #24]
		fp->fptr = nsect = 0;
 8003d36:	f8cb 2018 	str.w	r2, [fp, #24]
		if (ofs) {
 8003d3a:	2c00      	cmp	r4, #0
 8003d3c:	d08a      	beq.n	8003c54 <f_lseek+0x20>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 8003d3e:	f8b9 600a 	ldrh.w	r6, [r9, #10]
 8003d42:	0276      	lsls	r6, r6, #9
			if (ifptr > 0 &&
 8003d44:	b3db      	cbz	r3, 8003dbe <f_lseek+0x18a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 8003d46:	3b01      	subs	r3, #1
 8003d48:	1e62      	subs	r2, r4, #1
 8003d4a:	fbb3 f1f6 	udiv	r1, r3, r6
 8003d4e:	fbb2 f2f6 	udiv	r2, r2, r6
			if (ifptr > 0 &&
 8003d52:	428a      	cmp	r2, r1
 8003d54:	d333      	bcc.n	8003dbe <f_lseek+0x18a>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8003d56:	4272      	negs	r2, r6
 8003d58:	4013      	ands	r3, r2
				clst = fp->clust;
 8003d5a:	f8db 501c 	ldr.w	r5, [fp, #28]
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8003d5e:	f8cb 3018 	str.w	r3, [fp, #24]
				ofs -= fp->fptr;
 8003d62:	1ae4      	subs	r4, r4, r3
			if (clst != 0) {
 8003d64:	2d00      	cmp	r5, #0
 8003d66:	f000 81c5 	beq.w	80040f4 <f_lseek+0x4c0>
				while (ofs > bcs) {						/* Cluster following loop */
 8003d6a:	42b4      	cmp	r4, r6
 8003d6c:	d816      	bhi.n	8003d9c <f_lseek+0x168>
 8003d6e:	e1a7      	b.n	80040c0 <f_lseek+0x48c>
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 8003d70:	f7fe fa3a 	bl	80021e8 <create_chain>
						if (clst == 0) {				/* Clip file size in case of disk full */
 8003d74:	4605      	mov	r5, r0
 8003d76:	2800      	cmp	r0, #0
 8003d78:	f000 822a 	beq.w	80041d0 <f_lseek+0x59c>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8003d7c:	1c6b      	adds	r3, r5, #1
 8003d7e:	f000 819a 	beq.w	80040b6 <f_lseek+0x482>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 8003d82:	2d01      	cmp	r5, #1
 8003d84:	d94c      	bls.n	8003e20 <f_lseek+0x1ec>
 8003d86:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8003d8a:	42ab      	cmp	r3, r5
 8003d8c:	d948      	bls.n	8003e20 <f_lseek+0x1ec>
				while (ofs > bcs) {						/* Cluster following loop */
 8003d8e:	42a6      	cmp	r6, r4
					fp->clust = clst;
 8003d90:	f8cb 501c 	str.w	r5, [fp, #28]
 8003d94:	f8db 3018 	ldr.w	r3, [fp, #24]
				while (ofs > bcs) {						/* Cluster following loop */
 8003d98:	f080 8192 	bcs.w	80040c0 <f_lseek+0x48c>
					ofs -= bcs; fp->fptr += bcs;
 8003d9c:	4433      	add	r3, r6
 8003d9e:	f8cb 3018 	str.w	r3, [fp, #24]
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8003da2:	f89b 3014 	ldrb.w	r3, [fp, #20]
 8003da6:	079a      	lsls	r2, r3, #30
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 8003da8:	4629      	mov	r1, r5
 8003daa:	4658      	mov	r0, fp
					ofs -= bcs; fp->fptr += bcs;
 8003dac:	eba4 0406 	sub.w	r4, r4, r6
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8003db0:	d4de      	bmi.n	8003d70 <f_lseek+0x13c>
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 8003db2:	f8db 0000 	ldr.w	r0, [fp]
 8003db6:	f7fe f8f1 	bl	8001f9c <get_fat.isra.10>
 8003dba:	4605      	mov	r5, r0
 8003dbc:	e7de      	b.n	8003d7c <f_lseek+0x148>
				clst = fp->obj.sclust;					/* start from the first cluster */
 8003dbe:	f8db 5008 	ldr.w	r5, [fp, #8]
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 8003dc2:	2d00      	cmp	r5, #0
 8003dc4:	f000 8167 	beq.w	8004096 <f_lseek+0x462>
 8003dc8:	2300      	movs	r3, #0
				fp->clust = clst;
 8003dca:	f8cb 501c 	str.w	r5, [fp, #28]
 8003dce:	e7c9      	b.n	8003d64 <f_lseek+0x130>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8003dd0:	6811      	ldr	r1, [r2, #0]
			cl = fp->obj.sclust;		/* Origin of the chain */
 8003dd2:	f8db 3008 	ldr.w	r3, [fp, #8]
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8003dd6:	9102      	str	r1, [sp, #8]
 8003dd8:	1d11      	adds	r1, r2, #4
			cl = fp->obj.sclust;		/* Origin of the chain */
 8003dda:	9300      	str	r3, [sp, #0]
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8003ddc:	9103      	str	r1, [sp, #12]
			if (cl) {
 8003dde:	2b00      	cmp	r3, #0
 8003de0:	f000 8081 	beq.w	8003ee6 <f_lseek+0x2b2>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8003de4:	2302      	movs	r3, #2
 8003de6:	9301      	str	r3, [sp, #4]
 8003de8:	9b00      	ldr	r3, [sp, #0]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8003dea:	e9cd 9a05 	strd	r9, sl, [sp, #20]
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8003dee:	464d      	mov	r5, r9
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8003df0:	46da      	mov	sl, fp
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8003df2:	461c      	mov	r4, r3
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8003df4:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8003df8:	3b01      	subs	r3, #1
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8003dfa:	f04f 0b00 	mov.w	fp, #0
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8003dfe:	9304      	str	r3, [sp, #16]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8003e00:	2c01      	cmp	r4, #1
						pcl = cl; ncl++;
 8003e02:	f10b 0b01 	add.w	fp, fp, #1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8003e06:	d90a      	bls.n	8003e1e <f_lseek+0x1ea>
 8003e08:	696b      	ldr	r3, [r5, #20]
 8003e0a:	429c      	cmp	r4, r3
 8003e0c:	d207      	bcs.n	8003e1e <f_lseek+0x1ea>
		switch (fs->fs_type) {
 8003e0e:	782b      	ldrb	r3, [r5, #0]
 8003e10:	2b02      	cmp	r3, #2
 8003e12:	f000 809a 	beq.w	8003f4a <f_lseek+0x316>
 8003e16:	2b03      	cmp	r3, #3
 8003e18:	d070      	beq.n	8003efc <f_lseek+0x2c8>
 8003e1a:	2b01      	cmp	r3, #1
 8003e1c:	d008      	beq.n	8003e30 <f_lseek+0x1fc>
 8003e1e:	46d3      	mov	fp, sl
				if (!dsc) ABORT(fs, FR_INT_ERR);
 8003e20:	2302      	movs	r3, #2
 8003e22:	469a      	mov	sl, r3
}
 8003e24:	4650      	mov	r0, sl
				if (!dsc) ABORT(fs, FR_INT_ERR);
 8003e26:	f88b 3015 	strb.w	r3, [fp, #21]
}
 8003e2a:	b00b      	add	sp, #44	; 0x2c
 8003e2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8003e30:	6a2a      	ldr	r2, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003e32:	6aef      	ldr	r7, [r5, #44]	; 0x2c
			bc = (UINT)clst; bc += bc / 2;
 8003e34:	eb04 0654 	add.w	r6, r4, r4, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8003e38:	eb02 2856 	add.w	r8, r2, r6, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003e3c:	45b8      	cmp	r8, r7
 8003e3e:	f040 80c7 	bne.w	8003fd0 <f_lseek+0x39c>
			wc = fs->win[bc++ % SS(fs)];
 8003e42:	f3c6 0308 	ubfx	r3, r6, #0, #9
 8003e46:	3601      	adds	r6, #1
 8003e48:	442b      	add	r3, r5
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8003e4a:	eb02 2856 	add.w	r8, r2, r6, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003e4e:	45b8      	cmp	r8, r7
			wc = fs->win[bc++ % SS(fs)];
 8003e50:	f893 9030 	ldrb.w	r9, [r3, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003e54:	d036      	beq.n	8003ec4 <f_lseek+0x290>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003e56:	78eb      	ldrb	r3, [r5, #3]
 8003e58:	7868      	ldrb	r0, [r5, #1]
 8003e5a:	f105 0230 	add.w	r2, r5, #48	; 0x30
 8003e5e:	4611      	mov	r1, r2
 8003e60:	9207      	str	r2, [sp, #28]
 8003e62:	b32b      	cbz	r3, 8003eb0 <f_lseek+0x27c>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8003e64:	2301      	movs	r3, #1
 8003e66:	463a      	mov	r2, r7
 8003e68:	f7fd fa3c 	bl	80012e4 <disk_write>
 8003e6c:	2800      	cmp	r0, #0
 8003e6e:	f040 8121 	bne.w	80040b4 <f_lseek+0x480>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003e72:	6a2a      	ldr	r2, [r5, #32]
 8003e74:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8003e76:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003e78:	1aba      	subs	r2, r7, r2
 8003e7a:	429a      	cmp	r2, r3
 8003e7c:	7868      	ldrb	r0, [r5, #1]
 8003e7e:	d217      	bcs.n	8003eb0 <f_lseek+0x27c>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003e80:	f895 c002 	ldrb.w	ip, [r5, #2]
 8003e84:	4662      	mov	r2, ip
 8003e86:	2a01      	cmp	r2, #1
 8003e88:	d912      	bls.n	8003eb0 <f_lseek+0x27c>
 8003e8a:	9408      	str	r4, [sp, #32]
 8003e8c:	9609      	str	r6, [sp, #36]	; 0x24
 8003e8e:	4664      	mov	r4, ip
 8003e90:	9e07      	ldr	r6, [sp, #28]
 8003e92:	e001      	b.n	8003e98 <f_lseek+0x264>
 8003e94:	69ab      	ldr	r3, [r5, #24]
 8003e96:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8003e98:	441f      	add	r7, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003e9a:	3c01      	subs	r4, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 8003e9c:	463a      	mov	r2, r7
 8003e9e:	2301      	movs	r3, #1
 8003ea0:	4631      	mov	r1, r6
 8003ea2:	f7fd fa1f 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003ea6:	2c01      	cmp	r4, #1
 8003ea8:	d1f4      	bne.n	8003e94 <f_lseek+0x260>
 8003eaa:	e9dd 4608 	ldrd	r4, r6, [sp, #32]
 8003eae:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8003eb0:	9907      	ldr	r1, [sp, #28]
 8003eb2:	2301      	movs	r3, #1
 8003eb4:	4642      	mov	r2, r8
 8003eb6:	f7fd fa07 	bl	80012c8 <disk_read>
 8003eba:	2800      	cmp	r0, #0
 8003ebc:	f040 8142 	bne.w	8004144 <f_lseek+0x510>
			fs->winsect = sector;
 8003ec0:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
			wc |= fs->win[bc % SS(fs)] << 8;
 8003ec4:	f3c6 0608 	ubfx	r6, r6, #0, #9
 8003ec8:	4435      	add	r5, r6
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8003eca:	07e0      	lsls	r0, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 8003ecc:	f895 7030 	ldrb.w	r7, [r5, #48]	; 0x30
 8003ed0:	ea49 2707 	orr.w	r7, r9, r7, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8003ed4:	bf4c      	ite	mi
 8003ed6:	093f      	lsrmi	r7, r7, #4
 8003ed8:	f3c7 070b 	ubfxpl	r7, r7, #0, #12
 8003edc:	e02a      	b.n	8003f34 <f_lseek+0x300>
	return cl + *tbl;	/* Return the cluster number */
 8003ede:	6853      	ldr	r3, [r2, #4]
 8003ee0:	440b      	add	r3, r1
 8003ee2:	1e9a      	subs	r2, r3, #2
 8003ee4:	e6ec      	b.n	8003cc0 <f_lseek+0x8c>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8003ee6:	2302      	movs	r3, #2
 8003ee8:	9301      	str	r3, [sp, #4]
			*fp->cltbl = ulen;	/* Number of items used */
 8003eea:	6013      	str	r3, [r2, #0]
			if (ulen <= tlen) {
 8003eec:	9a02      	ldr	r2, [sp, #8]
 8003eee:	4293      	cmp	r3, r2
 8003ef0:	f200 80ce 	bhi.w	8004090 <f_lseek+0x45c>
				*tbl = 0;		/* Terminate table */
 8003ef4:	9a03      	ldr	r2, [sp, #12]
 8003ef6:	2300      	movs	r3, #0
 8003ef8:	6013      	str	r3, [r2, #0]
 8003efa:	e6ab      	b.n	8003c54 <f_lseek+0x20>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8003efc:	6a2f      	ldr	r7, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003efe:	f8d5 802c 	ldr.w	r8, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8003f02:	eb07 17d4 	add.w	r7, r7, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003f06:	4547      	cmp	r7, r8
 8003f08:	f105 0630 	add.w	r6, r5, #48	; 0x30
 8003f0c:	f040 8091 	bne.w	8004032 <f_lseek+0x3fe>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8003f10:	9b00      	ldr	r3, [sp, #0]
 8003f12:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8003f16:	3b01      	subs	r3, #1
 8003f18:	445b      	add	r3, fp
 8003f1a:	009b      	lsls	r3, r3, #2
 8003f1c:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 8003f20:	18f2      	adds	r2, r6, r3
	rv = rv << 8 | ptr[0];
 8003f22:	5cf7      	ldrb	r7, [r6, r3]
	rv = rv << 8 | ptr[2];
 8003f24:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 8003f26:	7853      	ldrb	r3, [r2, #1]
 8003f28:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 8003f2c:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8003f30:	f027 4770 	bic.w	r7, r7, #4026531840	; 0xf0000000
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8003f34:	2f01      	cmp	r7, #1
 8003f36:	f67f af72 	bls.w	8003e1e <f_lseek+0x1ea>
					} while (cl == pcl + 1);
 8003f3a:	3401      	adds	r4, #1
 8003f3c:	42bc      	cmp	r4, r7
 8003f3e:	f040 8106 	bne.w	800414e <f_lseek+0x51a>
 8003f42:	463c      	mov	r4, r7
 8003f44:	f8da 5000 	ldr.w	r5, [sl]
 8003f48:	e75a      	b.n	8003e00 <f_lseek+0x1cc>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8003f4a:	6a2f      	ldr	r7, [r5, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003f4c:	f8d5 802c 	ldr.w	r8, [r5, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8003f50:	eb07 2714 	add.w	r7, r7, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8003f54:	4547      	cmp	r7, r8
 8003f56:	f105 0630 	add.w	r6, r5, #48	; 0x30
 8003f5a:	d02e      	beq.n	8003fba <f_lseek+0x386>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003f5c:	78eb      	ldrb	r3, [r5, #3]
 8003f5e:	7868      	ldrb	r0, [r5, #1]
 8003f60:	b313      	cbz	r3, 8003fa8 <f_lseek+0x374>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8003f62:	2301      	movs	r3, #1
 8003f64:	4642      	mov	r2, r8
 8003f66:	4631      	mov	r1, r6
 8003f68:	f7fd f9bc 	bl	80012e4 <disk_write>
 8003f6c:	2800      	cmp	r0, #0
 8003f6e:	f040 80a1 	bne.w	80040b4 <f_lseek+0x480>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003f72:	6a2a      	ldr	r2, [r5, #32]
 8003f74:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8003f76:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003f78:	eba8 0202 	sub.w	r2, r8, r2
 8003f7c:	429a      	cmp	r2, r3
 8003f7e:	d212      	bcs.n	8003fa6 <f_lseek+0x372>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003f80:	f895 9002 	ldrb.w	r9, [r5, #2]
 8003f84:	f1b9 0f01 	cmp.w	r9, #1
 8003f88:	d801      	bhi.n	8003f8e <f_lseek+0x35a>
 8003f8a:	e00c      	b.n	8003fa6 <f_lseek+0x372>
 8003f8c:	69ab      	ldr	r3, [r5, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8003f8e:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8003f90:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003f92:	f109 39ff 	add.w	r9, r9, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8003f96:	4642      	mov	r2, r8
 8003f98:	2301      	movs	r3, #1
 8003f9a:	4631      	mov	r1, r6
 8003f9c:	f7fd f9a2 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003fa0:	f1b9 0f01 	cmp.w	r9, #1
 8003fa4:	d1f2      	bne.n	8003f8c <f_lseek+0x358>
 8003fa6:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8003fa8:	2301      	movs	r3, #1
 8003faa:	463a      	mov	r2, r7
 8003fac:	4631      	mov	r1, r6
 8003fae:	f7fd f98b 	bl	80012c8 <disk_read>
 8003fb2:	2800      	cmp	r0, #0
 8003fb4:	f040 80c6 	bne.w	8004144 <f_lseek+0x510>
			fs->winsect = sector;
 8003fb8:	62ef      	str	r7, [r5, #44]	; 0x2c
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8003fba:	9b04      	ldr	r3, [sp, #16]
 8003fbc:	445b      	add	r3, fp
 8003fbe:	005b      	lsls	r3, r3, #1
 8003fc0:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 8003fc4:	18f2      	adds	r2, r6, r3
	rv = rv << 8 | ptr[0];
 8003fc6:	5cf7      	ldrb	r7, [r6, r3]
 8003fc8:	7853      	ldrb	r3, [r2, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8003fca:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
 8003fce:	e7b1      	b.n	8003f34 <f_lseek+0x300>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003fd0:	78ea      	ldrb	r2, [r5, #3]
 8003fd2:	7868      	ldrb	r0, [r5, #1]
 8003fd4:	f105 0930 	add.w	r9, r5, #48	; 0x30
 8003fd8:	b1f2      	cbz	r2, 8004018 <f_lseek+0x3e4>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8003fda:	463a      	mov	r2, r7
 8003fdc:	4649      	mov	r1, r9
 8003fde:	f7fd f981 	bl	80012e4 <disk_write>
 8003fe2:	2800      	cmp	r0, #0
 8003fe4:	d166      	bne.n	80040b4 <f_lseek+0x480>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003fe6:	6a2a      	ldr	r2, [r5, #32]
 8003fe8:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 8003fea:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003fec:	1aba      	subs	r2, r7, r2
 8003fee:	429a      	cmp	r2, r3
 8003ff0:	d211      	bcs.n	8004016 <f_lseek+0x3e2>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003ff2:	78aa      	ldrb	r2, [r5, #2]
 8003ff4:	2a01      	cmp	r2, #1
 8003ff6:	d90e      	bls.n	8004016 <f_lseek+0x3e2>
 8003ff8:	9407      	str	r4, [sp, #28]
 8003ffa:	4614      	mov	r4, r2
 8003ffc:	e000      	b.n	8004000 <f_lseek+0x3cc>
 8003ffe:	69ab      	ldr	r3, [r5, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 8004000:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8004002:	441f      	add	r7, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004004:	3c01      	subs	r4, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 8004006:	463a      	mov	r2, r7
 8004008:	2301      	movs	r3, #1
 800400a:	4649      	mov	r1, r9
 800400c:	f7fd f96a 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004010:	2c01      	cmp	r4, #1
 8004012:	d1f4      	bne.n	8003ffe <f_lseek+0x3ca>
 8004014:	9c07      	ldr	r4, [sp, #28]
 8004016:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8004018:	4649      	mov	r1, r9
 800401a:	2301      	movs	r3, #1
 800401c:	4642      	mov	r2, r8
 800401e:	f7fd f953 	bl	80012c8 <disk_read>
 8004022:	2800      	cmp	r0, #0
 8004024:	f040 808e 	bne.w	8004144 <f_lseek+0x510>
 8004028:	6a2a      	ldr	r2, [r5, #32]
			fs->winsect = sector;
 800402a:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
 800402e:	4647      	mov	r7, r8
 8004030:	e707      	b.n	8003e42 <f_lseek+0x20e>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8004032:	78eb      	ldrb	r3, [r5, #3]
 8004034:	7868      	ldrb	r0, [r5, #1]
 8004036:	b313      	cbz	r3, 800407e <f_lseek+0x44a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8004038:	2301      	movs	r3, #1
 800403a:	4642      	mov	r2, r8
 800403c:	4631      	mov	r1, r6
 800403e:	f7fd f951 	bl	80012e4 <disk_write>
 8004042:	2800      	cmp	r0, #0
 8004044:	d136      	bne.n	80040b4 <f_lseek+0x480>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8004046:	6a2a      	ldr	r2, [r5, #32]
 8004048:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 800404a:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800404c:	eba8 0202 	sub.w	r2, r8, r2
 8004050:	429a      	cmp	r2, r3
 8004052:	7868      	ldrb	r0, [r5, #1]
 8004054:	d213      	bcs.n	800407e <f_lseek+0x44a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004056:	f895 9002 	ldrb.w	r9, [r5, #2]
 800405a:	f1b9 0f01 	cmp.w	r9, #1
 800405e:	d802      	bhi.n	8004066 <f_lseek+0x432>
 8004060:	e00d      	b.n	800407e <f_lseek+0x44a>
 8004062:	69ab      	ldr	r3, [r5, #24]
 8004064:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 8004066:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004068:	f109 39ff 	add.w	r9, r9, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 800406c:	4642      	mov	r2, r8
 800406e:	2301      	movs	r3, #1
 8004070:	4631      	mov	r1, r6
 8004072:	f7fd f937 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8004076:	f1b9 0f01 	cmp.w	r9, #1
 800407a:	d1f2      	bne.n	8004062 <f_lseek+0x42e>
 800407c:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800407e:	2301      	movs	r3, #1
 8004080:	463a      	mov	r2, r7
 8004082:	4631      	mov	r1, r6
 8004084:	f7fd f920 	bl	80012c8 <disk_read>
 8004088:	2800      	cmp	r0, #0
 800408a:	d15b      	bne.n	8004144 <f_lseek+0x510>
			fs->winsect = sector;
 800408c:	62ef      	str	r7, [r5, #44]	; 0x2c
 800408e:	e73f      	b.n	8003f10 <f_lseek+0x2dc>
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 8004090:	f04f 0a11 	mov.w	sl, #17
 8004094:	e5de      	b.n	8003c54 <f_lseek+0x20>
					clst = create_chain(&fp->obj, 0);
 8004096:	4629      	mov	r1, r5
 8004098:	4658      	mov	r0, fp
 800409a:	f7fe f8a5 	bl	80021e8 <create_chain>
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 800409e:	2801      	cmp	r0, #1
					clst = create_chain(&fp->obj, 0);
 80040a0:	4605      	mov	r5, r0
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 80040a2:	f43f aebd 	beq.w	8003e20 <f_lseek+0x1ec>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80040a6:	1c41      	adds	r1, r0, #1
 80040a8:	d005      	beq.n	80040b6 <f_lseek+0x482>
					fp->obj.sclust = clst;
 80040aa:	f8cb 0008 	str.w	r0, [fp, #8]
 80040ae:	f8db 3018 	ldr.w	r3, [fp, #24]
 80040b2:	e68a      	b.n	8003dca <f_lseek+0x196>
 80040b4:	46d3      	mov	fp, sl
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80040b6:	2301      	movs	r3, #1
 80040b8:	f88b 3015 	strb.w	r3, [fp, #21]
 80040bc:	469a      	mov	sl, r3
 80040be:	e5c9      	b.n	8003c54 <f_lseek+0x20>
				fp->fptr += ofs;
 80040c0:	4423      	add	r3, r4
				if (ofs % SS(fs)) {
 80040c2:	f3c4 0208 	ubfx	r2, r4, #0, #9
				fp->fptr += ofs;
 80040c6:	f8cb 3018 	str.w	r3, [fp, #24]
				if (ofs % SS(fs)) {
 80040ca:	2a00      	cmp	r2, #0
 80040cc:	f000 8083 	beq.w	80041d6 <f_lseek+0x5a2>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80040d0:	f8d9 2014 	ldr.w	r2, [r9, #20]
	clst -= 2;
 80040d4:	1ea9      	subs	r1, r5, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80040d6:	3a02      	subs	r2, #2
 80040d8:	4291      	cmp	r1, r2
 80040da:	f4bf aea1 	bcs.w	8003e20 <f_lseek+0x1ec>
	return clst * fs->csize + fs->database;
 80040de:	f8b9 500a 	ldrh.w	r5, [r9, #10]
 80040e2:	f8d9 2028 	ldr.w	r2, [r9, #40]	; 0x28
 80040e6:	fb01 2505 	mla	r5, r1, r5, r2
					if (!nsect) ABORT(fs, FR_INT_ERR);
 80040ea:	2d00      	cmp	r5, #0
 80040ec:	f43f ae98 	beq.w	8003e20 <f_lseek+0x1ec>
					nsect += (DWORD)(ofs / SS(fs));
 80040f0:	eb05 2554 	add.w	r5, r5, r4, lsr #9
		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
 80040f4:	f8db 200c 	ldr.w	r2, [fp, #12]
 80040f8:	429a      	cmp	r2, r3
 80040fa:	f3c3 0108 	ubfx	r1, r3, #0, #9
 80040fe:	d207      	bcs.n	8004110 <f_lseek+0x4dc>
			fp->flag |= FA_MODIFIED;
 8004100:	f89b 2014 	ldrb.w	r2, [fp, #20]
			fp->obj.objsize = fp->fptr;
 8004104:	f8cb 300c 	str.w	r3, [fp, #12]
			fp->flag |= FA_MODIFIED;
 8004108:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 800410c:	f88b 3014 	strb.w	r3, [fp, #20]
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 8004110:	2900      	cmp	r1, #0
 8004112:	f43f ad9f 	beq.w	8003c54 <f_lseek+0x20>
 8004116:	f8db 2020 	ldr.w	r2, [fp, #32]
 800411a:	42aa      	cmp	r2, r5
 800411c:	f43f ad9a 	beq.w	8003c54 <f_lseek+0x20>
			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
 8004120:	f99b 3014 	ldrsb.w	r3, [fp, #20]
 8004124:	f899 0001 	ldrb.w	r0, [r9, #1]
 8004128:	2b00      	cmp	r3, #0
 800412a:	f10b 0430 	add.w	r4, fp, #48	; 0x30
 800412e:	db25      	blt.n	800417c <f_lseek+0x548>
			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8004130:	4621      	mov	r1, r4
 8004132:	2301      	movs	r3, #1
 8004134:	462a      	mov	r2, r5
 8004136:	f7fd f8c7 	bl	80012c8 <disk_read>
 800413a:	2800      	cmp	r0, #0
 800413c:	d1bb      	bne.n	80040b6 <f_lseek+0x482>
			fp->sect = nsect;
 800413e:	f8cb 5020 	str.w	r5, [fp, #32]
 8004142:	e587      	b.n	8003c54 <f_lseek+0x20>
			fs->winsect = sector;
 8004144:	f04f 33ff 	mov.w	r3, #4294967295
 8004148:	46d3      	mov	fp, sl
 800414a:	62eb      	str	r3, [r5, #44]	; 0x2c
 800414c:	e7b3      	b.n	80040b6 <f_lseek+0x482>
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 800414e:	9b01      	ldr	r3, [sp, #4]
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8004150:	9a02      	ldr	r2, [sp, #8]
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8004152:	3302      	adds	r3, #2
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8004154:	429a      	cmp	r2, r3
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8004156:	9301      	str	r3, [sp, #4]
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8004158:	d31f      	bcc.n	800419a <f_lseek+0x566>
						*tbl++ = ncl; *tbl++ = tcl;
 800415a:	9a03      	ldr	r2, [sp, #12]
 800415c:	4613      	mov	r3, r2
 800415e:	4611      	mov	r1, r2
 8004160:	9a00      	ldr	r2, [sp, #0]
 8004162:	f843 bb08 	str.w	fp, [r3], #8
 8004166:	604a      	str	r2, [r1, #4]
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 8004168:	9a05      	ldr	r2, [sp, #20]
 800416a:	6952      	ldr	r2, [r2, #20]
 800416c:	42ba      	cmp	r2, r7
 800416e:	d934      	bls.n	80041da <f_lseek+0x5a6>
						*tbl++ = ncl; *tbl++ = tcl;
 8004170:	9303      	str	r3, [sp, #12]
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8004172:	9700      	str	r7, [sp, #0]
 8004174:	f8da 5000 	ldr.w	r5, [sl]
 8004178:	463b      	mov	r3, r7
 800417a:	e63a      	b.n	8003df2 <f_lseek+0x1be>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800417c:	2301      	movs	r3, #1
 800417e:	4621      	mov	r1, r4
 8004180:	f7fd f8b0 	bl	80012e4 <disk_write>
 8004184:	2800      	cmp	r0, #0
 8004186:	d196      	bne.n	80040b6 <f_lseek+0x482>
				fp->flag &= (BYTE)~FA_DIRTY;
 8004188:	f89b 3014 	ldrb.w	r3, [fp, #20]
 800418c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004190:	f88b 3014 	strb.w	r3, [fp, #20]
 8004194:	f899 0001 	ldrb.w	r0, [r9, #1]
 8004198:	e7ca      	b.n	8004130 <f_lseek+0x4fc>
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 800419a:	9b05      	ldr	r3, [sp, #20]
 800419c:	695b      	ldr	r3, [r3, #20]
 800419e:	42bb      	cmp	r3, r7
 80041a0:	d8e7      	bhi.n	8004172 <f_lseek+0x53e>
 80041a2:	46d3      	mov	fp, sl
 80041a4:	f8dd a018 	ldr.w	sl, [sp, #24]
 80041a8:	f8db 202c 	ldr.w	r2, [fp, #44]	; 0x2c
 80041ac:	9b01      	ldr	r3, [sp, #4]
 80041ae:	e69c      	b.n	8003eea <f_lseek+0x2b6>
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80041b0:	2301      	movs	r3, #1
 80041b2:	4629      	mov	r1, r5
 80041b4:	f7fd f896 	bl	80012e4 <disk_write>
 80041b8:	2800      	cmp	r0, #0
 80041ba:	f47f af7c 	bne.w	80040b6 <f_lseek+0x482>
						fp->flag &= (BYTE)~FA_DIRTY;
 80041be:	f89b 3014 	ldrb.w	r3, [fp, #20]
 80041c2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80041c6:	f88b 3014 	strb.w	r3, [fp, #20]
 80041ca:	f899 0001 	ldrb.w	r0, [r9, #1]
 80041ce:	e59a      	b.n	8003d06 <f_lseek+0xd2>
 80041d0:	f8db 3018 	ldr.w	r3, [fp, #24]
 80041d4:	e78e      	b.n	80040f4 <f_lseek+0x4c0>
		fp->fptr = nsect = 0;
 80041d6:	4615      	mov	r5, r2
 80041d8:	e78c      	b.n	80040f4 <f_lseek+0x4c0>
 80041da:	46d3      	mov	fp, sl
						*tbl++ = ncl; *tbl++ = tcl;
 80041dc:	9303      	str	r3, [sp, #12]
 80041de:	f8dd a018 	ldr.w	sl, [sp, #24]
 80041e2:	e7e1      	b.n	80041a8 <f_lseek+0x574>

080041e4 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 80041e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80041e6:	b085      	sub	sp, #20
 80041e8:	9101      	str	r1, [sp, #4]
	FATFS *fs;
	_FDID *obj;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 80041ea:	2800      	cmp	r0, #0
 80041ec:	d032      	beq.n	8004254 <f_opendir+0x70>
 80041ee:	4604      	mov	r4, r0

	/* Get logical drive */
	obj = &dp->obj;
	res = find_volume(&path, &fs, 0);
 80041f0:	2200      	movs	r2, #0
 80041f2:	a903      	add	r1, sp, #12
 80041f4:	a801      	add	r0, sp, #4
 80041f6:	f7fe fced 	bl	8002bd4 <find_volume>
	if (res == FR_OK) {
 80041fa:	b118      	cbz	r0, 8004204 <f_opendir+0x20>
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 80041fc:	2300      	movs	r3, #0
 80041fe:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 8004200:	b005      	add	sp, #20
 8004202:	bdf0      	pop	{r4, r5, r6, r7, pc}
		obj->fs = fs;
 8004204:	9b03      	ldr	r3, [sp, #12]
 8004206:	6023      	str	r3, [r4, #0]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8004208:	9901      	ldr	r1, [sp, #4]
 800420a:	4620      	mov	r0, r4
 800420c:	f7fe fb54 	bl	80028b8 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 8004210:	bb18      	cbnz	r0, 800425a <f_opendir+0x76>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 8004212:	f994 302f 	ldrsb.w	r3, [r4, #47]	; 0x2f
 8004216:	2b00      	cmp	r3, #0
 8004218:	db23      	blt.n	8004262 <f_opendir+0x7e>
				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
 800421a:	79a3      	ldrb	r3, [r4, #6]
 800421c:	06db      	lsls	r3, r3, #27
 800421e:	d51e      	bpl.n	800425e <f_opendir+0x7a>
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8004220:	9a03      	ldr	r2, [sp, #12]
 8004222:	6a21      	ldr	r1, [r4, #32]
	if (fs->fs_type == FS_FAT32) {
 8004224:	7810      	ldrb	r0, [r2, #0]
	rv = rv << 8 | ptr[0];
 8004226:	7ecd      	ldrb	r5, [r1, #27]
 8004228:	7e8b      	ldrb	r3, [r1, #26]
	if (fs->fs_type == FS_FAT32) {
 800422a:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 800422c:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8004230:	d105      	bne.n	800423e <f_opendir+0x5a>
	rv = rv << 8 | ptr[0];
 8004232:	7d48      	ldrb	r0, [r1, #21]
 8004234:	7d09      	ldrb	r1, [r1, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8004236:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 800423a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 800423e:	60a3      	str	r3, [r4, #8]
				obj->id = fs->id;
 8004240:	88d3      	ldrh	r3, [r2, #6]
 8004242:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 8004244:	4620      	mov	r0, r4
 8004246:	f7fd fd33 	bl	8001cb0 <dir_sdi.constprop.14>
				if (res == FR_OK) {
 800424a:	b930      	cbnz	r0, 800425a <f_opendir+0x76>
					if (obj->sclust) {
 800424c:	68a3      	ldr	r3, [r4, #8]
 800424e:	b953      	cbnz	r3, 8004266 <f_opendir+0x82>
						obj->lockid = 0;	/* Root directory need not to be locked */
 8004250:	6120      	str	r0, [r4, #16]
 8004252:	e7d5      	b.n	8004200 <f_opendir+0x1c>
	if (!dp) return FR_INVALID_OBJECT;
 8004254:	2009      	movs	r0, #9
}
 8004256:	b005      	add	sp, #20
 8004258:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800425a:	2804      	cmp	r0, #4
 800425c:	d1ce      	bne.n	80041fc <f_opendir+0x18>
					res = FR_NO_PATH;
 800425e:	2005      	movs	r0, #5
 8004260:	e7cc      	b.n	80041fc <f_opendir+0x18>
 8004262:	9a03      	ldr	r2, [sp, #12]
 8004264:	e7ec      	b.n	8004240 <f_opendir+0x5c>
		if (Files[i].fs == dp->obj.fs &&
 8004266:	4a1c      	ldr	r2, [pc, #112]	; (80042d8 <f_opendir+0xf4>)
 8004268:	6821      	ldr	r1, [r4, #0]
 800426a:	6815      	ldr	r5, [r2, #0]
 800426c:	42a9      	cmp	r1, r5
 800426e:	d01e      	beq.n	80042ae <f_opendir+0xca>
 8004270:	f8d2 c010 	ldr.w	ip, [r2, #16]
 8004274:	458c      	cmp	ip, r1
 8004276:	d007      	beq.n	8004288 <f_opendir+0xa4>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8004278:	b31d      	cbz	r5, 80042c2 <f_opendir+0xde>
 800427a:	f1bc 0f00 	cmp.w	ip, #0
 800427e:	d01f      	beq.n	80042c0 <f_opendir+0xdc>
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 8004280:	2300      	movs	r3, #0
 8004282:	6123      	str	r3, [r4, #16]
						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 8004284:	2012      	movs	r0, #18
 8004286:	e7b9      	b.n	80041fc <f_opendir+0x18>
		if (Files[i].fs == dp->obj.fs &&
 8004288:	6957      	ldr	r7, [r2, #20]
 800428a:	42bb      	cmp	r3, r7
 800428c:	d1f4      	bne.n	8004278 <f_opendir+0x94>
			Files[i].clu == dp->obj.sclust &&
 800428e:	6996      	ldr	r6, [r2, #24]
 8004290:	6967      	ldr	r7, [r4, #20]
 8004292:	42be      	cmp	r6, r7
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8004294:	bf08      	it	eq
 8004296:	2501      	moveq	r5, #1
			Files[i].clu == dp->obj.sclust &&
 8004298:	d1ee      	bne.n	8004278 <f_opendir+0x94>
 800429a:	012e      	lsls	r6, r5, #4
 800429c:	1993      	adds	r3, r2, r6
 800429e:	8999      	ldrh	r1, [r3, #12]
 80042a0:	3101      	adds	r1, #1
 80042a2:	b289      	uxth	r1, r1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80042a4:	4432      	add	r2, r6
	return i + 1;
 80042a6:	3501      	adds	r5, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80042a8:	8191      	strh	r1, [r2, #12]
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 80042aa:	6125      	str	r5, [r4, #16]
 80042ac:	e7a8      	b.n	8004200 <f_opendir+0x1c>
		if (Files[i].fs == dp->obj.fs &&
 80042ae:	6856      	ldr	r6, [r2, #4]
 80042b0:	42b3      	cmp	r3, r6
 80042b2:	d1dd      	bne.n	8004270 <f_opendir+0x8c>
			Files[i].clu == dp->obj.sclust &&
 80042b4:	6967      	ldr	r7, [r4, #20]
 80042b6:	6896      	ldr	r6, [r2, #8]
 80042b8:	42b7      	cmp	r7, r6
 80042ba:	d1d9      	bne.n	8004270 <f_opendir+0x8c>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 80042bc:	4605      	mov	r5, r0
 80042be:	e7ec      	b.n	800429a <f_opendir+0xb6>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80042c0:	2501      	movs	r5, #1
		Files[i].fs = dp->obj.fs;
 80042c2:	012e      	lsls	r6, r5, #4
 80042c4:	1997      	adds	r7, r2, r6
 80042c6:	5191      	str	r1, [r2, r6]
		Files[i].clu = dp->obj.sclust;
 80042c8:	607b      	str	r3, [r7, #4]
		Files[i].ofs = dp->dptr;
 80042ca:	6961      	ldr	r1, [r4, #20]
 80042cc:	60b9      	str	r1, [r7, #8]
		Files[i].ctr = 0;
 80042ce:	2300      	movs	r3, #0
 80042d0:	81bb      	strh	r3, [r7, #12]
 80042d2:	2101      	movs	r1, #1
 80042d4:	e7e6      	b.n	80042a4 <f_opendir+0xc0>
 80042d6:	bf00      	nop
 80042d8:	200000b0 	.word	0x200000b0

080042dc <f_closedir>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 80042dc:	b318      	cbz	r0, 8004326 <f_closedir+0x4a>
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 80042de:	b538      	push	{r3, r4, r5, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 80042e0:	6803      	ldr	r3, [r0, #0]
 80042e2:	b12b      	cbz	r3, 80042f0 <f_closedir+0x14>
 80042e4:	781a      	ldrb	r2, [r3, #0]
 80042e6:	b11a      	cbz	r2, 80042f0 <f_closedir+0x14>
 80042e8:	8881      	ldrh	r1, [r0, #4]
 80042ea:	88da      	ldrh	r2, [r3, #6]
 80042ec:	4291      	cmp	r1, r2
 80042ee:	d001      	beq.n	80042f4 <f_closedir+0x18>
	FRESULT res = FR_INVALID_OBJECT;
 80042f0:	2009      	movs	r0, #9
#if _FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
}
 80042f2:	bd38      	pop	{r3, r4, r5, pc}
 80042f4:	4604      	mov	r4, r0
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 80042f6:	7858      	ldrb	r0, [r3, #1]
 80042f8:	f7fc ffcc 	bl	8001294 <disk_status>
 80042fc:	f010 0001 	ands.w	r0, r0, #1
 8004300:	d1f6      	bne.n	80042f0 <f_closedir+0x14>
		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
 8004302:	6923      	ldr	r3, [r4, #16]
 8004304:	b163      	cbz	r3, 8004320 <f_closedir+0x44>
	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8004306:	3b01      	subs	r3, #1
 8004308:	2b01      	cmp	r3, #1
 800430a:	d80e      	bhi.n	800432a <f_closedir+0x4e>
		n = Files[i].ctr;
 800430c:	490c      	ldr	r1, [pc, #48]	; (8004340 <f_closedir+0x64>)
 800430e:	011b      	lsls	r3, r3, #4
 8004310:	18cd      	adds	r5, r1, r3
 8004312:	89aa      	ldrh	r2, [r5, #12]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8004314:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8004318:	d009      	beq.n	800432e <f_closedir+0x52>
		if (n > 0) n--;				/* Decrement read mode open count */
 800431a:	b952      	cbnz	r2, 8004332 <f_closedir+0x56>
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 800431c:	2200      	movs	r2, #0
 800431e:	50ca      	str	r2, [r1, r3]
			dp->obj.fs = 0;			/* Invalidate directory object */
 8004320:	2000      	movs	r0, #0
 8004322:	6020      	str	r0, [r4, #0]
}
 8004324:	bd38      	pop	{r3, r4, r5, pc}
	FRESULT res = FR_INVALID_OBJECT;
 8004326:	2009      	movs	r0, #9
}
 8004328:	4770      	bx	lr
		res = FR_INT_ERR;			/* Invalid index nunber */
 800432a:	2002      	movs	r0, #2
}
 800432c:	bd38      	pop	{r3, r4, r5, pc}
		Files[i].ctr = n;
 800432e:	81a8      	strh	r0, [r5, #12]
 8004330:	e7f4      	b.n	800431c <f_closedir+0x40>
		if (n > 0) n--;				/* Decrement read mode open count */
 8004332:	3a01      	subs	r2, #1
 8004334:	b292      	uxth	r2, r2
		Files[i].ctr = n;
 8004336:	81aa      	strh	r2, [r5, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8004338:	2a00      	cmp	r2, #0
 800433a:	d1f1      	bne.n	8004320 <f_closedir+0x44>
 800433c:	e7ee      	b.n	800431c <f_closedir+0x40>
 800433e:	bf00      	nop
 8004340:	200000b0 	.word	0x200000b0

08004344 <f_readdir>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8004344:	b170      	cbz	r0, 8004364 <f_readdir+0x20>
 8004346:	6803      	ldr	r3, [r0, #0]
 8004348:	b163      	cbz	r3, 8004364 <f_readdir+0x20>
 800434a:	781a      	ldrb	r2, [r3, #0]
 800434c:	b152      	cbz	r2, 8004364 <f_readdir+0x20>

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 800434e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8004352:	88da      	ldrh	r2, [r3, #6]
 8004354:	8884      	ldrh	r4, [r0, #4]
 8004356:	4294      	cmp	r4, r2
{
 8004358:	b083      	sub	sp, #12
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800435a:	d005      	beq.n	8004368 <f_readdir+0x24>
	FRESULT res = FR_INVALID_OBJECT;
 800435c:	2009      	movs	r0, #9
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
}
 800435e:	b003      	add	sp, #12
 8004360:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	FRESULT res = FR_INVALID_OBJECT;
 8004364:	2009      	movs	r0, #9
}
 8004366:	4770      	bx	lr
 8004368:	4604      	mov	r4, r0
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800436a:	7858      	ldrb	r0, [r3, #1]
 800436c:	460e      	mov	r6, r1
 800436e:	f7fc ff91 	bl	8001294 <disk_status>
 8004372:	07c1      	lsls	r1, r0, #31
 8004374:	d4f2      	bmi.n	800435c <f_readdir+0x18>
		if (!fno) {
 8004376:	2e00      	cmp	r6, #0
 8004378:	f000 809a 	beq.w	80044b0 <f_readdir+0x16c>
	while (dp->sect) {
 800437c:	f8d4 901c 	ldr.w	r9, [r4, #28]
	FATFS *fs = dp->obj.fs;
 8004380:	6825      	ldr	r5, [r4, #0]
	while (dp->sect) {
 8004382:	f1b9 0f00 	cmp.w	r9, #0
 8004386:	f000 8086 	beq.w	8004496 <f_readdir+0x152>
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800438a:	f8df 82d8 	ldr.w	r8, [pc, #728]	; 8004664 <f_readdir+0x320>
 800438e:	f105 0730 	add.w	r7, r5, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8004392:	f8d5 a02c 	ldr.w	sl, [r5, #44]	; 0x2c
 8004396:	45ca      	cmp	sl, r9
 8004398:	d036      	beq.n	8004408 <f_readdir+0xc4>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800439a:	78eb      	ldrb	r3, [r5, #3]
 800439c:	7868      	ldrb	r0, [r5, #1]
 800439e:	b313      	cbz	r3, 80043e6 <f_readdir+0xa2>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80043a0:	2301      	movs	r3, #1
 80043a2:	4652      	mov	r2, sl
 80043a4:	4639      	mov	r1, r7
 80043a6:	f7fc ff9d 	bl	80012e4 <disk_write>
 80043aa:	2800      	cmp	r0, #0
 80043ac:	d17c      	bne.n	80044a8 <f_readdir+0x164>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80043ae:	6a2a      	ldr	r2, [r5, #32]
 80043b0:	69ab      	ldr	r3, [r5, #24]
			fs->wflag = 0;
 80043b2:	70e8      	strb	r0, [r5, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80043b4:	ebaa 0202 	sub.w	r2, sl, r2
 80043b8:	429a      	cmp	r2, r3
 80043ba:	7868      	ldrb	r0, [r5, #1]
 80043bc:	d213      	bcs.n	80043e6 <f_readdir+0xa2>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80043be:	f895 b002 	ldrb.w	fp, [r5, #2]
 80043c2:	f1bb 0f01 	cmp.w	fp, #1
 80043c6:	d802      	bhi.n	80043ce <f_readdir+0x8a>
 80043c8:	e00d      	b.n	80043e6 <f_readdir+0xa2>
 80043ca:	69ab      	ldr	r3, [r5, #24]
 80043cc:	7868      	ldrb	r0, [r5, #1]
					wsect += fs->fsize;
 80043ce:	449a      	add	sl, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80043d0:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 80043d4:	4652      	mov	r2, sl
 80043d6:	2301      	movs	r3, #1
 80043d8:	4639      	mov	r1, r7
 80043da:	f7fc ff83 	bl	80012e4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80043de:	f1bb 0f01 	cmp.w	fp, #1
 80043e2:	d1f2      	bne.n	80043ca <f_readdir+0x86>
 80043e4:	7868      	ldrb	r0, [r5, #1]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80043e6:	2301      	movs	r3, #1
 80043e8:	464a      	mov	r2, r9
 80043ea:	4639      	mov	r1, r7
 80043ec:	f7fc ff6c 	bl	80012c8 <disk_read>
 80043f0:	b140      	cbz	r0, 8004404 <f_readdir+0xc0>
			fs->winsect = sector;
 80043f2:	f04f 32ff 	mov.w	r2, #4294967295
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80043f6:	2300      	movs	r3, #0
				res = FR_DISK_ERR;
 80043f8:	2001      	movs	r0, #1
			fs->winsect = sector;
 80043fa:	62ea      	str	r2, [r5, #44]	; 0x2c
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80043fc:	61e3      	str	r3, [r4, #28]
}
 80043fe:	b003      	add	sp, #12
 8004400:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fs->winsect = sector;
 8004404:	f8c5 902c 	str.w	r9, [r5, #44]	; 0x2c
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 8004408:	6a23      	ldr	r3, [r4, #32]
 800440a:	781a      	ldrb	r2, [r3, #0]
		if (c == 0) {
 800440c:	2a00      	cmp	r2, #0
 800440e:	d042      	beq.n	8004496 <f_readdir+0x152>
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 8004410:	7adb      	ldrb	r3, [r3, #11]
			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 8004412:	2ae5      	cmp	r2, #229	; 0xe5
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 8004414:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8004418:	71a3      	strb	r3, [r4, #6]
			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 800441a:	d007      	beq.n	800442c <f_readdir+0xe8>
 800441c:	2a2e      	cmp	r2, #46	; 0x2e
 800441e:	d005      	beq.n	800442c <f_readdir+0xe8>
 8004420:	2b0f      	cmp	r3, #15
 8004422:	d003      	beq.n	800442c <f_readdir+0xe8>
 8004424:	f023 0320 	bic.w	r3, r3, #32
 8004428:	2b08      	cmp	r3, #8
 800442a:	d147      	bne.n	80044bc <f_readdir+0x178>
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800442c:	f8d4 901c 	ldr.w	r9, [r4, #28]
 8004430:	f1b9 0f00 	cmp.w	r9, #0
 8004434:	d02f      	beq.n	8004496 <f_readdir+0x152>
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8004436:	6963      	ldr	r3, [r4, #20]
 8004438:	3320      	adds	r3, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800443a:	4543      	cmp	r3, r8
 800443c:	d82b      	bhi.n	8004496 <f_readdir+0x152>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800443e:	f3c3 0108 	ubfx	r1, r3, #0, #9
	FATFS *fs = dp->obj.fs;
 8004442:	6822      	ldr	r2, [r4, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8004444:	bb59      	cbnz	r1, 800449e <f_readdir+0x15a>
		if (!dp->clust) {		/* Static table */
 8004446:	69a1      	ldr	r1, [r4, #24]
		dp->sect++;				/* Next sector */
 8004448:	f109 0901 	add.w	r9, r9, #1
 800444c:	f8c4 901c 	str.w	r9, [r4, #28]
		if (!dp->clust) {		/* Static table */
 8004450:	b969      	cbnz	r1, 800446e <f_readdir+0x12a>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 8004452:	8911      	ldrh	r1, [r2, #8]
 8004454:	ebb1 1f53 	cmp.w	r1, r3, lsr #5
 8004458:	d91d      	bls.n	8004496 <f_readdir+0x152>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800445a:	3230      	adds	r2, #48	; 0x30
 800445c:	6222      	str	r2, [r4, #32]
	dp->dptr = ofs;						/* Current entry */
 800445e:	6163      	str	r3, [r4, #20]
	while (dp->sect) {
 8004460:	f1b9 0f00 	cmp.w	r9, #0
 8004464:	d195      	bne.n	8004392 <f_readdir+0x4e>
	fno->fname[0] = 0;		/* Invaidate file info */
 8004466:	2300      	movs	r3, #0
 8004468:	7273      	strb	r3, [r6, #9]
	return FR_OK;
 800446a:	2000      	movs	r0, #0
 800446c:	e777      	b.n	800435e <f_readdir+0x1a>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 800446e:	8950      	ldrh	r0, [r2, #10]
 8004470:	3801      	subs	r0, #1
 8004472:	ea10 2a53 	ands.w	sl, r0, r3, lsr #9
 8004476:	d1f0      	bne.n	800445a <f_readdir+0x116>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 8004478:	4610      	mov	r0, r2
 800447a:	9301      	str	r3, [sp, #4]
 800447c:	9200      	str	r2, [sp, #0]
 800447e:	f7fd fd8d 	bl	8001f9c <get_fat.isra.10>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8004482:	2801      	cmp	r0, #1
 8004484:	f240 80e0 	bls.w	8004648 <f_readdir+0x304>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 8004488:	1c42      	adds	r2, r0, #1
 800448a:	d00d      	beq.n	80044a8 <f_readdir+0x164>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800448c:	9a00      	ldr	r2, [sp, #0]
 800448e:	6951      	ldr	r1, [r2, #20]
 8004490:	4288      	cmp	r0, r1
 8004492:	f0c0 80c6 	bcc.w	8004622 <f_readdir+0x2de>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 8004496:	2300      	movs	r3, #0
 8004498:	61e3      	str	r3, [r4, #28]
	fno->fname[0] = 0;		/* Invaidate file info */
 800449a:	7273      	strb	r3, [r6, #9]
 800449c:	e7e5      	b.n	800446a <f_readdir+0x126>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800449e:	3230      	adds	r2, #48	; 0x30
 80044a0:	4411      	add	r1, r2
 80044a2:	6221      	str	r1, [r4, #32]
	dp->dptr = ofs;						/* Current entry */
 80044a4:	6163      	str	r3, [r4, #20]
 80044a6:	e774      	b.n	8004392 <f_readdir+0x4e>
			res = FR_DISK_ERR;
 80044a8:	2001      	movs	r0, #1
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80044aa:	2300      	movs	r3, #0
 80044ac:	61e3      	str	r3, [r4, #28]
	LEAVE_FF(fs, res);
 80044ae:	e756      	b.n	800435e <f_readdir+0x1a>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 80044b0:	4620      	mov	r0, r4
}
 80044b2:	b003      	add	sp, #12
 80044b4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 80044b8:	f7fd bbfa 	b.w	8001cb0 <dir_sdi.constprop.14>
 80044bc:	69e0      	ldr	r0, [r4, #28]
	fno->fname[0] = 0;		/* Invaidate file info */
 80044be:	2300      	movs	r3, #0
 80044c0:	7273      	strb	r3, [r6, #9]
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 80044c2:	2800      	cmp	r0, #0
 80044c4:	d0d1      	beq.n	800446a <f_readdir+0x126>
		c = (TCHAR)dp->dir[i++];
 80044c6:	6a22      	ldr	r2, [r4, #32]
 80044c8:	7811      	ldrb	r1, [r2, #0]
		if (c == ' ') continue;				/* Skip padding spaces */
 80044ca:	2920      	cmp	r1, #32
 80044cc:	d004      	beq.n	80044d8 <f_readdir+0x194>
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 80044ce:	2905      	cmp	r1, #5
 80044d0:	bf08      	it	eq
 80044d2:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 80044d4:	7271      	strb	r1, [r6, #9]
 80044d6:	2301      	movs	r3, #1
		c = (TCHAR)dp->dir[i++];
 80044d8:	7851      	ldrb	r1, [r2, #1]
		if (c == ' ') continue;				/* Skip padding spaces */
 80044da:	2920      	cmp	r1, #32
 80044dc:	d005      	beq.n	80044ea <f_readdir+0x1a6>
		fno->fname[j++] = c;
 80044de:	18f5      	adds	r5, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 80044e0:	2905      	cmp	r1, #5
 80044e2:	bf08      	it	eq
 80044e4:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 80044e6:	7269      	strb	r1, [r5, #9]
 80044e8:	3301      	adds	r3, #1
		c = (TCHAR)dp->dir[i++];
 80044ea:	7891      	ldrb	r1, [r2, #2]
		if (c == ' ') continue;				/* Skip padding spaces */
 80044ec:	2920      	cmp	r1, #32
 80044ee:	d005      	beq.n	80044fc <f_readdir+0x1b8>
		fno->fname[j++] = c;
 80044f0:	18f5      	adds	r5, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 80044f2:	2905      	cmp	r1, #5
 80044f4:	bf08      	it	eq
 80044f6:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 80044f8:	7269      	strb	r1, [r5, #9]
 80044fa:	3301      	adds	r3, #1
		c = (TCHAR)dp->dir[i++];
 80044fc:	78d1      	ldrb	r1, [r2, #3]
		if (c == ' ') continue;				/* Skip padding spaces */
 80044fe:	2920      	cmp	r1, #32
 8004500:	d005      	beq.n	800450e <f_readdir+0x1ca>
		fno->fname[j++] = c;
 8004502:	18f5      	adds	r5, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 8004504:	2905      	cmp	r1, #5
 8004506:	bf08      	it	eq
 8004508:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 800450a:	7269      	strb	r1, [r5, #9]
 800450c:	3301      	adds	r3, #1
		c = (TCHAR)dp->dir[i++];
 800450e:	7911      	ldrb	r1, [r2, #4]
		if (c == ' ') continue;				/* Skip padding spaces */
 8004510:	2920      	cmp	r1, #32
 8004512:	d005      	beq.n	8004520 <f_readdir+0x1dc>
		fno->fname[j++] = c;
 8004514:	18f5      	adds	r5, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 8004516:	2905      	cmp	r1, #5
 8004518:	bf08      	it	eq
 800451a:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 800451c:	7269      	strb	r1, [r5, #9]
 800451e:	3301      	adds	r3, #1
		c = (TCHAR)dp->dir[i++];
 8004520:	7951      	ldrb	r1, [r2, #5]
		if (c == ' ') continue;				/* Skip padding spaces */
 8004522:	2920      	cmp	r1, #32
 8004524:	d005      	beq.n	8004532 <f_readdir+0x1ee>
		fno->fname[j++] = c;
 8004526:	18f5      	adds	r5, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 8004528:	2905      	cmp	r1, #5
 800452a:	bf08      	it	eq
 800452c:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 800452e:	7269      	strb	r1, [r5, #9]
 8004530:	3301      	adds	r3, #1
		c = (TCHAR)dp->dir[i++];
 8004532:	7991      	ldrb	r1, [r2, #6]
		if (c == ' ') continue;				/* Skip padding spaces */
 8004534:	2920      	cmp	r1, #32
 8004536:	d005      	beq.n	8004544 <f_readdir+0x200>
		fno->fname[j++] = c;
 8004538:	18f5      	adds	r5, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 800453a:	2905      	cmp	r1, #5
 800453c:	bf08      	it	eq
 800453e:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 8004540:	7269      	strb	r1, [r5, #9]
 8004542:	3301      	adds	r3, #1
		c = (TCHAR)dp->dir[i++];
 8004544:	79d1      	ldrb	r1, [r2, #7]
		if (c == ' ') continue;				/* Skip padding spaces */
 8004546:	2920      	cmp	r1, #32
 8004548:	d005      	beq.n	8004556 <f_readdir+0x212>
		fno->fname[j++] = c;
 800454a:	18f5      	adds	r5, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 800454c:	2905      	cmp	r1, #5
 800454e:	bf08      	it	eq
 8004550:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 8004552:	7269      	strb	r1, [r5, #9]
 8004554:	3301      	adds	r3, #1
		c = (TCHAR)dp->dir[i++];
 8004556:	7a11      	ldrb	r1, [r2, #8]
		if (c == ' ') continue;				/* Skip padding spaces */
 8004558:	2920      	cmp	r1, #32
 800455a:	d00b      	beq.n	8004574 <f_readdir+0x230>
 800455c:	1c5d      	adds	r5, r3, #1
		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
 800455e:	18f7      	adds	r7, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 8004560:	2905      	cmp	r1, #5
		fno->fname[j++] = c;
 8004562:	4435      	add	r5, r6
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 8004564:	bf08      	it	eq
 8004566:	21e5      	moveq	r1, #229	; 0xe5
		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
 8004568:	f04f 0c2e 	mov.w	ip, #46	; 0x2e
 800456c:	f887 c009 	strb.w	ip, [r7, #9]
 8004570:	3302      	adds	r3, #2
		fno->fname[j++] = c;
 8004572:	7269      	strb	r1, [r5, #9]
		c = (TCHAR)dp->dir[i++];
 8004574:	7a51      	ldrb	r1, [r2, #9]
		if (c == ' ') continue;				/* Skip padding spaces */
 8004576:	2920      	cmp	r1, #32
 8004578:	d005      	beq.n	8004586 <f_readdir+0x242>
		fno->fname[j++] = c;
 800457a:	18f5      	adds	r5, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 800457c:	2905      	cmp	r1, #5
 800457e:	bf08      	it	eq
 8004580:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 8004582:	7269      	strb	r1, [r5, #9]
 8004584:	3301      	adds	r3, #1
		c = (TCHAR)dp->dir[i++];
 8004586:	7a91      	ldrb	r1, [r2, #10]
		if (c == ' ') continue;				/* Skip padding spaces */
 8004588:	2920      	cmp	r1, #32
 800458a:	d005      	beq.n	8004598 <f_readdir+0x254>
		fno->fname[j++] = c;
 800458c:	18f5      	adds	r5, r6, r3
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 800458e:	2905      	cmp	r1, #5
 8004590:	bf08      	it	eq
 8004592:	21e5      	moveq	r1, #229	; 0xe5
		fno->fname[j++] = c;
 8004594:	7269      	strb	r1, [r5, #9]
 8004596:	3301      	adds	r3, #1
	fno->fname[j] = 0;
 8004598:	4433      	add	r3, r6
 800459a:	2100      	movs	r1, #0
 800459c:	7259      	strb	r1, [r3, #9]
	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
 800459e:	7ad3      	ldrb	r3, [r2, #11]
 80045a0:	7233      	strb	r3, [r6, #8]
	rv = rv << 8 | ptr[2];
 80045a2:	8bd5      	ldrh	r5, [r2, #30]
	rv = rv << 8 | ptr[1];
 80045a4:	7f51      	ldrb	r1, [r2, #29]
	rv = rv << 8 | ptr[0];
 80045a6:	7f13      	ldrb	r3, [r2, #28]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 80045a8:	6967      	ldr	r7, [r4, #20]
	rv = rv << 8 | ptr[1];
 80045aa:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
	rv = rv << 8 | ptr[0];
 80045ae:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
 80045b2:	6033      	str	r3, [r6, #0]
	rv = rv << 8 | ptr[2];
 80045b4:	8b15      	ldrh	r5, [r2, #24]
	rv = rv << 8 | ptr[1];
 80045b6:	7dd1      	ldrb	r1, [r2, #23]
	rv = rv << 8 | ptr[0];
 80045b8:	7d93      	ldrb	r3, [r2, #22]
	rv = rv << 8 | ptr[1];
 80045ba:	ea41 2205 	orr.w	r2, r1, r5, lsl #8
	rv = rv << 8 | ptr[0];
 80045be:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 80045c2:	3720      	adds	r7, #32
	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
 80045c4:	0c1a      	lsrs	r2, r3, #16
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 80045c6:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
 80045ca:	80f3      	strh	r3, [r6, #6]
 80045cc:	80b2      	strh	r2, [r6, #4]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 80045ce:	f4bf af4c 	bcs.w	800446a <f_readdir+0x126>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 80045d2:	f3c7 0608 	ubfx	r6, r7, #0, #9
	FATFS *fs = dp->obj.fs;
 80045d6:	6825      	ldr	r5, [r4, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 80045d8:	b9f6      	cbnz	r6, 8004618 <f_readdir+0x2d4>
		if (!dp->clust) {		/* Static table */
 80045da:	69a1      	ldr	r1, [r4, #24]
		dp->sect++;				/* Next sector */
 80045dc:	3001      	adds	r0, #1
 80045de:	61e0      	str	r0, [r4, #28]
		if (!dp->clust) {		/* Static table */
 80045e0:	b359      	cbz	r1, 800463a <f_readdir+0x2f6>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 80045e2:	896b      	ldrh	r3, [r5, #10]
 80045e4:	3b01      	subs	r3, #1
 80045e6:	ea13 2357 	ands.w	r3, r3, r7, lsr #9
 80045ea:	d115      	bne.n	8004618 <f_readdir+0x2d4>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 80045ec:	4628      	mov	r0, r5
 80045ee:	f7fd fcd5 	bl	8001f9c <get_fat.isra.10>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 80045f2:	2801      	cmp	r0, #1
 80045f4:	d934      	bls.n	8004660 <f_readdir+0x31c>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 80045f6:	1c43      	adds	r3, r0, #1
 80045f8:	d030      	beq.n	800465c <f_readdir+0x318>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 80045fa:	696b      	ldr	r3, [r5, #20]
 80045fc:	4298      	cmp	r0, r3
 80045fe:	d220      	bcs.n	8004642 <f_readdir+0x2fe>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8004600:	3b02      	subs	r3, #2
	clst -= 2;
 8004602:	1e82      	subs	r2, r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8004604:	429a      	cmp	r2, r3
	return clst * fs->csize + fs->database;
 8004606:	bf3c      	itt	cc
 8004608:	896b      	ldrhcc	r3, [r5, #10]
 800460a:	6aa9      	ldrcc	r1, [r5, #40]	; 0x28
				dp->clust = clst;		/* Initialize data for new cluster */
 800460c:	61a0      	str	r0, [r4, #24]
	return clst * fs->csize + fs->database;
 800460e:	bf34      	ite	cc
 8004610:	fb02 1303 	mlacc	r3, r2, r3, r1
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8004614:	4633      	movcs	r3, r6
				dp->sect = clust2sect(fs, clst);
 8004616:	61e3      	str	r3, [r4, #28]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8004618:	3530      	adds	r5, #48	; 0x30
 800461a:	4435      	add	r5, r6
 800461c:	6225      	str	r5, [r4, #32]
	dp->dptr = ofs;						/* Current entry */
 800461e:	6167      	str	r7, [r4, #20]
 8004620:	e723      	b.n	800446a <f_readdir+0x126>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8004622:	3902      	subs	r1, #2
	clst -= 2;
 8004624:	f1a0 0c02 	sub.w	ip, r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8004628:	458c      	cmp	ip, r1
				dp->clust = clst;		/* Initialize data for new cluster */
 800462a:	61a0      	str	r0, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800462c:	9b01      	ldr	r3, [sp, #4]
 800462e:	d30d      	bcc.n	800464c <f_readdir+0x308>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8004630:	3230      	adds	r2, #48	; 0x30
				dp->sect = clust2sect(fs, clst);
 8004632:	e9c4 a207 	strd	sl, r2, [r4, #28]
	dp->dptr = ofs;						/* Current entry */
 8004636:	6163      	str	r3, [r4, #20]
 8004638:	e715      	b.n	8004466 <f_readdir+0x122>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800463a:	892b      	ldrh	r3, [r5, #8]
 800463c:	ebb3 1f57 	cmp.w	r3, r7, lsr #5
 8004640:	d8ea      	bhi.n	8004618 <f_readdir+0x2d4>
				dp->sect = 0; return FR_NO_FILE;
 8004642:	2000      	movs	r0, #0
 8004644:	61e0      	str	r0, [r4, #28]
 8004646:	e68a      	b.n	800435e <f_readdir+0x1a>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8004648:	2002      	movs	r0, #2
 800464a:	e72e      	b.n	80044aa <f_readdir+0x166>
	return clst * fs->csize + fs->database;
 800464c:	f8b2 900a 	ldrh.w	r9, [r2, #10]
 8004650:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8004652:	fb0c 1909 	mla	r9, ip, r9, r1
				dp->sect = clust2sect(fs, clst);
 8004656:	f8c4 901c 	str.w	r9, [r4, #28]
 800465a:	e6fe      	b.n	800445a <f_readdir+0x116>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800465c:	2001      	movs	r0, #1
 800465e:	e67e      	b.n	800435e <f_readdir+0x1a>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8004660:	2002      	movs	r0, #2
 8004662:	e67c      	b.n	800435e <f_readdir+0x1a>
 8004664:	001fffff 	.word	0x001fffff

08004668 <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
 8004668:	b4f0      	push	{r4, r5, r6, r7}
  if(disk.nbr < _VOLUMES)
 800466a:	4b10      	ldr	r3, [pc, #64]	; (80046ac <FATFS_LinkDriver+0x44>)
 800466c:	7a5c      	ldrb	r4, [r3, #9]
 800466e:	b114      	cbz	r4, 8004676 <FATFS_LinkDriver+0xe>
  uint8_t ret = 1;
 8004670:	2001      	movs	r0, #1
  return FATFS_LinkDriverEx(drv, path, 0);
}
 8004672:	bcf0      	pop	{r4, r5, r6, r7}
 8004674:	4770      	bx	lr
    disk.is_initialized[disk.nbr] = 0;
 8004676:	7a5f      	ldrb	r7, [r3, #9]
    disk.drv[disk.nbr] = drv;
 8004678:	7a5e      	ldrb	r6, [r3, #9]
    disk.lun[disk.nbr] = lun;
 800467a:	7a5d      	ldrb	r5, [r3, #9]
 800467c:	f004 02ff 	and.w	r2, r4, #255	; 0xff
    DiskNum = disk.nbr++;
 8004680:	7a5c      	ldrb	r4, [r3, #9]
    disk.is_initialized[disk.nbr] = 0;
 8004682:	55da      	strb	r2, [r3, r7]
    disk.drv[disk.nbr] = drv;
 8004684:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    DiskNum = disk.nbr++;
 8004688:	b2e4      	uxtb	r4, r4
    disk.drv[disk.nbr] = drv;
 800468a:	6070      	str	r0, [r6, #4]
    disk.lun[disk.nbr] = lun;
 800468c:	441d      	add	r5, r3
    DiskNum = disk.nbr++;
 800468e:	1c60      	adds	r0, r4, #1
 8004690:	b2c0      	uxtb	r0, r0
 8004692:	7258      	strb	r0, [r3, #9]
    disk.lun[disk.nbr] = lun;
 8004694:	722a      	strb	r2, [r5, #8]
    path[0] = DiskNum + '0';
 8004696:	3430      	adds	r4, #48	; 0x30
    path[1] = ':';
 8004698:	253a      	movs	r5, #58	; 0x3a
    path[2] = '/';
 800469a:	232f      	movs	r3, #47	; 0x2f
    path[0] = DiskNum + '0';
 800469c:	700c      	strb	r4, [r1, #0]
    path[3] = 0;
 800469e:	4610      	mov	r0, r2
    path[1] = ':';
 80046a0:	704d      	strb	r5, [r1, #1]
    path[3] = 0;
 80046a2:	70ca      	strb	r2, [r1, #3]
    path[2] = '/';
 80046a4:	708b      	strb	r3, [r1, #2]
}
 80046a6:	bcf0      	pop	{r4, r5, r6, r7}
 80046a8:	4770      	bx	lr
 80046aa:	bf00      	nop
 80046ac:	200000d4 	.word	0x200000d4

080046b0 <FATFS_UnLinkDriver>:
uint8_t FATFS_UnLinkDriverEx(char *path, uint8_t lun)
{
  uint8_t DiskNum = 0;
  uint8_t ret = 1;

  if(disk.nbr >= 1)
 80046b0:	4b0c      	ldr	r3, [pc, #48]	; (80046e4 <FATFS_UnLinkDriver+0x34>)
 80046b2:	7a5a      	ldrb	r2, [r3, #9]
 80046b4:	b90a      	cbnz	r2, 80046ba <FATFS_UnLinkDriver+0xa>
  uint8_t ret = 1;
 80046b6:	2001      	movs	r0, #1
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_UnLinkDriver(char *path)
{
  return FATFS_UnLinkDriverEx(path, 0);
}
 80046b8:	4770      	bx	lr
{
 80046ba:	b410      	push	{r4}
    DiskNum = path[0] - '0';
 80046bc:	7802      	ldrb	r2, [r0, #0]
 80046be:	3a30      	subs	r2, #48	; 0x30
    if(disk.drv[DiskNum] != 0)
 80046c0:	b2d2      	uxtb	r2, r2
 80046c2:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 80046c6:	6861      	ldr	r1, [r4, #4]
 80046c8:	b151      	cbz	r1, 80046e0 <FATFS_UnLinkDriver+0x30>
      disk.nbr--;
 80046ca:	7a59      	ldrb	r1, [r3, #9]
      disk.lun[DiskNum] = 0;
 80046cc:	441a      	add	r2, r3
      disk.nbr--;
 80046ce:	3901      	subs	r1, #1
      disk.drv[DiskNum] = 0;
 80046d0:	2000      	movs	r0, #0
      disk.nbr--;
 80046d2:	b2c9      	uxtb	r1, r1
      disk.lun[DiskNum] = 0;
 80046d4:	7210      	strb	r0, [r2, #8]
      disk.drv[DiskNum] = 0;
 80046d6:	6060      	str	r0, [r4, #4]
      disk.nbr--;
 80046d8:	7259      	strb	r1, [r3, #9]
}
 80046da:	f85d 4b04 	ldr.w	r4, [sp], #4
 80046de:	4770      	bx	lr
  uint8_t ret = 1;
 80046e0:	2001      	movs	r0, #1
 80046e2:	e7fa      	b.n	80046da <FATFS_UnLinkDriver+0x2a>
 80046e4:	200000d4 	.word	0x200000d4

080046e8 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 80046e8:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 80046ea:	f000 fb0f 	bl	8004d0c <vTaskStartScheduler>
  
  return osOK;
}
 80046ee:	2000      	movs	r0, #0
 80046f0:	bd08      	pop	{r3, pc}
 80046f2:	bf00      	nop

080046f4 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 80046f4:	b570      	push	{r4, r5, r6, lr}
  TaskHandle_t handle;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 80046f6:	6945      	ldr	r5, [r0, #20]
 80046f8:	6902      	ldr	r2, [r0, #16]
 80046fa:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
{
 80046fe:	460b      	mov	r3, r1
 8004700:	b086      	sub	sp, #24
 8004702:	e9d0 1600 	ldrd	r1, r6, [r0]
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 8004706:	b16d      	cbz	r5, 8004724 <osThreadCreate+0x30>
 8004708:	6980      	ldr	r0, [r0, #24]
 800470a:	b158      	cbz	r0, 8004724 <osThreadCreate+0x30>
  if (priority != osPriorityError) {
 800470c:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 800470e:	bf14      	ite	ne
 8004710:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8004712:	2400      	moveq	r4, #0
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8004714:	e9cd 5001 	strd	r5, r0, [sp, #4]
 8004718:	9400      	str	r4, [sp, #0]
 800471a:	4630      	mov	r0, r6
 800471c:	f000 fa16 	bl	8004b4c <xTaskCreateStatic>
    return NULL;
  }     
#endif
  
  return handle;
}
 8004720:	b006      	add	sp, #24
 8004722:	bd70      	pop	{r4, r5, r6, pc}
  if (priority != osPriorityError) {
 8004724:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 8004726:	bf14      	ite	ne
 8004728:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800472a:	2400      	moveq	r4, #0
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800472c:	ad05      	add	r5, sp, #20
 800472e:	b292      	uxth	r2, r2
 8004730:	9400      	str	r4, [sp, #0]
 8004732:	4630      	mov	r0, r6
 8004734:	9501      	str	r5, [sp, #4]
 8004736:	f000 fa41 	bl	8004bbc <xTaskCreate>
 800473a:	2801      	cmp	r0, #1
 800473c:	bf0c      	ite	eq
 800473e:	9805      	ldreq	r0, [sp, #20]
      return NULL;
 8004740:	2000      	movne	r0, #0
}
 8004742:	b006      	add	sp, #24
 8004744:	bd70      	pop	{r4, r5, r6, pc}
 8004746:	bf00      	nop

08004748 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 8004748:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800474a:	2800      	cmp	r0, #0
 800474c:	bf08      	it	eq
 800474e:	2001      	moveq	r0, #1
 8004750:	f000 fc7a 	bl	8005048 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 8004754:	2000      	movs	r0, #0
 8004756:	bd08      	pop	{r3, pc}

08004758 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004758:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800475c:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004760:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004762:	6081      	str	r1, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004764:	6002      	str	r2, [r0, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004766:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004768:	e9c0 3303 	strd	r3, r3, [r0, #12]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800476c:	4770      	bx	lr
 800476e:	bf00      	nop

08004770 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8004770:	2300      	movs	r3, #0
 8004772:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8004774:	4770      	bx	lr
 8004776:	bf00      	nop

08004778 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8004778:	6843      	ldr	r3, [r0, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800477a:	6802      	ldr	r2, [r0, #0]
{
 800477c:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800477e:	689c      	ldr	r4, [r3, #8]
 8004780:	608c      	str	r4, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8004782:	689c      	ldr	r4, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 8004784:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 8004786:	3201      	adds	r2, #1
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8004788:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800478a:	6099      	str	r1, [r3, #8]
}
 800478c:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004790:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8004792:	6002      	str	r2, [r0, #0]
}
 8004794:	4770      	bx	lr
 8004796:	bf00      	nop

08004798 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8004798:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800479a:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800479c:	1c6b      	adds	r3, r5, #1
 800479e:	d011      	beq.n	80047c4 <vListInsert+0x2c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80047a0:	f100 0208 	add.w	r2, r0, #8
 80047a4:	e000      	b.n	80047a8 <vListInsert+0x10>
 80047a6:	461a      	mov	r2, r3
 80047a8:	6853      	ldr	r3, [r2, #4]
 80047aa:	681c      	ldr	r4, [r3, #0]
 80047ac:	42ac      	cmp	r4, r5
 80047ae:	d9fa      	bls.n	80047a6 <vListInsert+0xe>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80047b0:	6804      	ldr	r4, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 80047b2:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 80047b4:	3401      	adds	r4, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80047b6:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80047b8:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80047ba:	6051      	str	r1, [r2, #4]
	pxNewListItem->pvContainer = ( void * ) pxList;
 80047bc:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 80047be:	6004      	str	r4, [r0, #0]
}
 80047c0:	bc30      	pop	{r4, r5}
 80047c2:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 80047c4:	6902      	ldr	r2, [r0, #16]
 80047c6:	6853      	ldr	r3, [r2, #4]
 80047c8:	e7f2      	b.n	80047b0 <vListInsert+0x18>
 80047ca:	bf00      	nop

080047cc <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80047cc:	6842      	ldr	r2, [r0, #4]
 80047ce:	6881      	ldr	r1, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 80047d0:	6903      	ldr	r3, [r0, #16]
{
 80047d2:	b410      	push	{r4}
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80047d4:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80047d6:	6881      	ldr	r1, [r0, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80047d8:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80047da:	604a      	str	r2, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 80047dc:	681a      	ldr	r2, [r3, #0]
	if( pxList->pxIndex == pxItemToRemove )
 80047de:	4284      	cmp	r4, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80047e0:	bf08      	it	eq
 80047e2:	6059      	streq	r1, [r3, #4]
	( pxList->uxNumberOfItems )--;
 80047e4:	3a01      	subs	r2, #1
	pxItemToRemove->pvContainer = NULL;
 80047e6:	2100      	movs	r1, #0
 80047e8:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 80047ea:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 80047ec:	6818      	ldr	r0, [r3, #0]
}
 80047ee:	f85d 4b04 	ldr.w	r4, [sp], #4
 80047f2:	4770      	bx	lr

080047f4 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 80047f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80047f8:	4604      	mov	r4, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 80047fa:	f000 fcf3 	bl	80051e4 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 80047fe:	4a35      	ldr	r2, [pc, #212]	; (80048d4 <prvAddNewTaskToReadyList+0xe0>)
		if( pxCurrentTCB == NULL )
 8004800:	4d35      	ldr	r5, [pc, #212]	; (80048d8 <prvAddNewTaskToReadyList+0xe4>)
		uxCurrentNumberOfTasks++;
 8004802:	6813      	ldr	r3, [r2, #0]
 8004804:	3301      	adds	r3, #1
 8004806:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8004808:	682b      	ldr	r3, [r5, #0]
 800480a:	2b00      	cmp	r3, #0
 800480c:	d034      	beq.n	8004878 <prvAddNewTaskToReadyList+0x84>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 800480e:	4f33      	ldr	r7, [pc, #204]	; (80048dc <prvAddNewTaskToReadyList+0xe8>)
 8004810:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004812:	683b      	ldr	r3, [r7, #0]
 8004814:	b343      	cbz	r3, 8004868 <prvAddNewTaskToReadyList+0x74>
 8004816:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 8004900 <prvAddNewTaskToReadyList+0x10c>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 800481a:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 8004904 <prvAddNewTaskToReadyList+0x110>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 800481e:	4e30      	ldr	r6, [pc, #192]	; (80048e0 <prvAddNewTaskToReadyList+0xec>)
		uxTaskNumber++;
 8004820:	f8dc 2000 	ldr.w	r2, [ip]
		prvAddTaskToReadyList( pxNewTCB );
 8004824:	6831      	ldr	r1, [r6, #0]
 8004826:	2301      	movs	r3, #1
 8004828:	4083      	lsls	r3, r0
 800482a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800482e:	430b      	orrs	r3, r1
		uxTaskNumber++;
 8004830:	3201      	adds	r2, #1
		prvAddTaskToReadyList( pxNewTCB );
 8004832:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8004836:	1d21      	adds	r1, r4, #4
 8004838:	6033      	str	r3, [r6, #0]
		uxTaskNumber++;
 800483a:	f8cc 2000 	str.w	r2, [ip]
		prvAddTaskToReadyList( pxNewTCB );
 800483e:	f7ff ff9b 	bl	8004778 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 8004842:	f000 fcf1 	bl	8005228 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 8004846:	683b      	ldr	r3, [r7, #0]
 8004848:	b163      	cbz	r3, 8004864 <prvAddNewTaskToReadyList+0x70>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800484a:	682a      	ldr	r2, [r5, #0]
 800484c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800484e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8004850:	429a      	cmp	r2, r3
 8004852:	d207      	bcs.n	8004864 <prvAddNewTaskToReadyList+0x70>
		{
			taskYIELD_IF_USING_PREEMPTION();
 8004854:	4b23      	ldr	r3, [pc, #140]	; (80048e4 <prvAddNewTaskToReadyList+0xf0>)
 8004856:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800485a:	601a      	str	r2, [r3, #0]
 800485c:	f3bf 8f4f 	dsb	sy
 8004860:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8004864:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8004868:	682b      	ldr	r3, [r5, #0]
 800486a:	f8df 8094 	ldr.w	r8, [pc, #148]	; 8004900 <prvAddNewTaskToReadyList+0x10c>
 800486e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004870:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
 8004872:	bf98      	it	ls
 8004874:	602c      	strls	r4, [r5, #0]
 8004876:	e7d0      	b.n	800481a <prvAddNewTaskToReadyList+0x26>
			pxCurrentTCB = pxNewTCB;
 8004878:	602c      	str	r4, [r5, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800487a:	6813      	ldr	r3, [r2, #0]
 800487c:	2b01      	cmp	r3, #1
 800487e:	d004      	beq.n	800488a <prvAddNewTaskToReadyList+0x96>
 8004880:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004882:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8004900 <prvAddNewTaskToReadyList+0x10c>
 8004886:	4f15      	ldr	r7, [pc, #84]	; (80048dc <prvAddNewTaskToReadyList+0xe8>)
 8004888:	e7c7      	b.n	800481a <prvAddNewTaskToReadyList+0x26>
 800488a:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8004900 <prvAddNewTaskToReadyList+0x10c>
 800488e:	4646      	mov	r6, r8
 8004890:	f108 078c 	add.w	r7, r8, #140	; 0x8c
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8004894:	4630      	mov	r0, r6
 8004896:	3614      	adds	r6, #20
 8004898:	f7ff ff5e 	bl	8004758 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800489c:	42b7      	cmp	r7, r6
 800489e:	d1f9      	bne.n	8004894 <prvAddNewTaskToReadyList+0xa0>
	}

	vListInitialise( &xDelayedTaskList1 );
 80048a0:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8004908 <prvAddNewTaskToReadyList+0x114>
	vListInitialise( &xDelayedTaskList2 );
 80048a4:	4e10      	ldr	r6, [pc, #64]	; (80048e8 <prvAddNewTaskToReadyList+0xf4>)
 80048a6:	4f0d      	ldr	r7, [pc, #52]	; (80048dc <prvAddNewTaskToReadyList+0xe8>)
	vListInitialise( &xDelayedTaskList1 );
 80048a8:	4648      	mov	r0, r9
 80048aa:	f7ff ff55 	bl	8004758 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 80048ae:	4630      	mov	r0, r6
 80048b0:	f7ff ff52 	bl	8004758 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 80048b4:	480d      	ldr	r0, [pc, #52]	; (80048ec <prvAddNewTaskToReadyList+0xf8>)
 80048b6:	f7ff ff4f 	bl	8004758 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 80048ba:	480d      	ldr	r0, [pc, #52]	; (80048f0 <prvAddNewTaskToReadyList+0xfc>)
 80048bc:	f7ff ff4c 	bl	8004758 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 80048c0:	480c      	ldr	r0, [pc, #48]	; (80048f4 <prvAddNewTaskToReadyList+0x100>)
 80048c2:	f7ff ff49 	bl	8004758 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80048c6:	4a0c      	ldr	r2, [pc, #48]	; (80048f8 <prvAddNewTaskToReadyList+0x104>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80048c8:	4b0c      	ldr	r3, [pc, #48]	; (80048fc <prvAddNewTaskToReadyList+0x108>)
	pxDelayedTaskList = &xDelayedTaskList1;
 80048ca:	f8c2 9000 	str.w	r9, [r2]
 80048ce:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80048d0:	601e      	str	r6, [r3, #0]
 80048d2:	e7a2      	b.n	800481a <prvAddNewTaskToReadyList+0x26>
 80048d4:	20000178 	.word	0x20000178
 80048d8:	200000e0 	.word	0x200000e0
 80048dc:	200001d4 	.word	0x200001d4
 80048e0:	2000018c 	.word	0x2000018c
 80048e4:	e000ed04 	.word	0xe000ed04
 80048e8:	200001a4 	.word	0x200001a4
 80048ec:	200001c0 	.word	0x200001c0
 80048f0:	200001ec 	.word	0x200001ec
 80048f4:	200001d8 	.word	0x200001d8
 80048f8:	200000e4 	.word	0x200000e4
 80048fc:	200000e8 	.word	0x200000e8
 8004900:	200000ec 	.word	0x200000ec
 8004904:	20000188 	.word	0x20000188
 8004908:	20000190 	.word	0x20000190

0800490c <prvInitialiseNewTask.isra.2>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 800490c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004910:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004912:	780d      	ldrb	r5, [r1, #0]
 8004914:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8004918:	6b26      	ldr	r6, [r4, #48]	; 0x30
		if( pcName[ x ] == 0x00 )
 800491a:	f891 c000 	ldrb.w	ip, [r1]
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800491e:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8004922:	3a01      	subs	r2, #1
 8004924:	eb06 0682 	add.w	r6, r6, r2, lsl #2
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8004928:	e9dd 5708 	ldrd	r5, r7, [sp, #32]
 800492c:	4681      	mov	r9, r0
 800492e:	469a      	mov	sl, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8004930:	f026 0607 	bic.w	r6, r6, #7
		if( pcName[ x ] == 0x00 )
 8004934:	f1bc 0f00 	cmp.w	ip, #0
 8004938:	d04d      	beq.n	80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800493a:	784b      	ldrb	r3, [r1, #1]
 800493c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
		if( pcName[ x ] == 0x00 )
 8004940:	784b      	ldrb	r3, [r1, #1]
 8004942:	2b00      	cmp	r3, #0
 8004944:	d047      	beq.n	80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004946:	788b      	ldrb	r3, [r1, #2]
 8004948:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
		if( pcName[ x ] == 0x00 )
 800494c:	788b      	ldrb	r3, [r1, #2]
 800494e:	2b00      	cmp	r3, #0
 8004950:	d041      	beq.n	80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004952:	78cb      	ldrb	r3, [r1, #3]
 8004954:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
		if( pcName[ x ] == 0x00 )
 8004958:	78cb      	ldrb	r3, [r1, #3]
 800495a:	2b00      	cmp	r3, #0
 800495c:	d03b      	beq.n	80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800495e:	790b      	ldrb	r3, [r1, #4]
 8004960:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
		if( pcName[ x ] == 0x00 )
 8004964:	790b      	ldrb	r3, [r1, #4]
 8004966:	2b00      	cmp	r3, #0
 8004968:	d035      	beq.n	80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800496a:	794b      	ldrb	r3, [r1, #5]
 800496c:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
		if( pcName[ x ] == 0x00 )
 8004970:	794b      	ldrb	r3, [r1, #5]
 8004972:	2b00      	cmp	r3, #0
 8004974:	d02f      	beq.n	80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004976:	798b      	ldrb	r3, [r1, #6]
 8004978:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
		if( pcName[ x ] == 0x00 )
 800497c:	798b      	ldrb	r3, [r1, #6]
 800497e:	b353      	cbz	r3, 80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004980:	79cb      	ldrb	r3, [r1, #7]
 8004982:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
		if( pcName[ x ] == 0x00 )
 8004986:	79cb      	ldrb	r3, [r1, #7]
 8004988:	b32b      	cbz	r3, 80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800498a:	7a0b      	ldrb	r3, [r1, #8]
 800498c:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
		if( pcName[ x ] == 0x00 )
 8004990:	7a0b      	ldrb	r3, [r1, #8]
 8004992:	b303      	cbz	r3, 80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004994:	7a4b      	ldrb	r3, [r1, #9]
 8004996:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
		if( pcName[ x ] == 0x00 )
 800499a:	7a4b      	ldrb	r3, [r1, #9]
 800499c:	b1db      	cbz	r3, 80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800499e:	7a8b      	ldrb	r3, [r1, #10]
 80049a0:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
		if( pcName[ x ] == 0x00 )
 80049a4:	7a8b      	ldrb	r3, [r1, #10]
 80049a6:	b1b3      	cbz	r3, 80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80049a8:	7acb      	ldrb	r3, [r1, #11]
 80049aa:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
		if( pcName[ x ] == 0x00 )
 80049ae:	7acb      	ldrb	r3, [r1, #11]
 80049b0:	b18b      	cbz	r3, 80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80049b2:	7b0b      	ldrb	r3, [r1, #12]
 80049b4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		if( pcName[ x ] == 0x00 )
 80049b8:	7b0b      	ldrb	r3, [r1, #12]
 80049ba:	b163      	cbz	r3, 80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80049bc:	7b4b      	ldrb	r3, [r1, #13]
 80049be:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		if( pcName[ x ] == 0x00 )
 80049c2:	7b4b      	ldrb	r3, [r1, #13]
 80049c4:	b13b      	cbz	r3, 80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80049c6:	7b8b      	ldrb	r3, [r1, #14]
 80049c8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
		if( pcName[ x ] == 0x00 )
 80049cc:	7b8b      	ldrb	r3, [r1, #14]
 80049ce:	b113      	cbz	r3, 80049d6 <prvInitialiseNewTask.isra.2+0xca>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80049d0:	7bcb      	ldrb	r3, [r1, #15]
 80049d2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80049d6:	2d06      	cmp	r5, #6
 80049d8:	bf28      	it	cs
 80049da:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80049dc:	f04f 0800 	mov.w	r8, #0
	pxNewTCB->uxPriority = uxPriority;
 80049e0:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 80049e2:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80049e4:	1d20      	adds	r0, r4, #4
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80049e6:	f884 8043 	strb.w	r8, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 80049ea:	f8c4 8048 	str.w	r8, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80049ee:	f7ff febf 	bl	8004770 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80049f2:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80049f6:	f104 0018 	add.w	r0, r4, #24
 80049fa:	f7ff feb9 	bl	8004770 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 80049fe:	f8c4 804c 	str.w	r8, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004a02:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8004a04:	6124      	str	r4, [r4, #16]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8004a06:	f884 8050 	strb.w	r8, [r4, #80]	; 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8004a0a:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004a0c:	4652      	mov	r2, sl
 8004a0e:	4649      	mov	r1, r9
 8004a10:	4630      	mov	r0, r6
 8004a12:	f000 fbb9 	bl	8005188 <pxPortInitialiseStack>
 8004a16:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8004a18:	b107      	cbz	r7, 8004a1c <prvInitialiseNewTask.isra.2+0x110>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8004a1a:	603c      	str	r4, [r7, #0]
}
 8004a1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08004a20 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8004a20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8004a22:	4b1b      	ldr	r3, [pc, #108]	; (8004a90 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004a24:	4e1b      	ldr	r6, [pc, #108]	; (8004a94 <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 8004a26:	681c      	ldr	r4, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004a28:	6833      	ldr	r3, [r6, #0]
{
 8004a2a:	4605      	mov	r5, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004a2c:	1d18      	adds	r0, r3, #4
{
 8004a2e:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004a30:	f7ff fecc 	bl	80047cc <uxListRemove>
 8004a34:	b940      	cbnz	r0, 8004a48 <prvAddCurrentTaskToDelayedList+0x28>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8004a36:	6833      	ldr	r3, [r6, #0]
 8004a38:	4917      	ldr	r1, [pc, #92]	; (8004a98 <prvAddCurrentTaskToDelayedList+0x78>)
 8004a3a:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8004a3c:	680b      	ldr	r3, [r1, #0]
 8004a3e:	2201      	movs	r2, #1
 8004a40:	4082      	lsls	r2, r0
 8004a42:	ea23 0302 	bic.w	r3, r3, r2
 8004a46:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8004a48:	1c6b      	adds	r3, r5, #1
 8004a4a:	d017      	beq.n	8004a7c <prvAddCurrentTaskToDelayedList+0x5c>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8004a4c:	6833      	ldr	r3, [r6, #0]
 8004a4e:	1964      	adds	r4, r4, r5
 8004a50:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8004a52:	d20b      	bcs.n	8004a6c <prvAddCurrentTaskToDelayedList+0x4c>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004a54:	4b11      	ldr	r3, [pc, #68]	; (8004a9c <prvAddCurrentTaskToDelayedList+0x7c>)
 8004a56:	6818      	ldr	r0, [r3, #0]
 8004a58:	6831      	ldr	r1, [r6, #0]
 8004a5a:	3104      	adds	r1, #4
 8004a5c:	f7ff fe9c 	bl	8004798 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 8004a60:	4b0f      	ldr	r3, [pc, #60]	; (8004aa0 <prvAddCurrentTaskToDelayedList+0x80>)
 8004a62:	681a      	ldr	r2, [r3, #0]
 8004a64:	42a2      	cmp	r2, r4
				{
					xNextTaskUnblockTime = xTimeToWake;
 8004a66:	bf88      	it	hi
 8004a68:	601c      	strhi	r4, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8004a6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004a6c:	4b0d      	ldr	r3, [pc, #52]	; (8004aa4 <prvAddCurrentTaskToDelayedList+0x84>)
 8004a6e:	6818      	ldr	r0, [r3, #0]
 8004a70:	6831      	ldr	r1, [r6, #0]
}
 8004a72:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004a76:	3104      	adds	r1, #4
 8004a78:	f7ff be8e 	b.w	8004798 <vListInsert>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8004a7c:	2f00      	cmp	r7, #0
 8004a7e:	d0e5      	beq.n	8004a4c <prvAddCurrentTaskToDelayedList+0x2c>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004a80:	6831      	ldr	r1, [r6, #0]
 8004a82:	4809      	ldr	r0, [pc, #36]	; (8004aa8 <prvAddCurrentTaskToDelayedList+0x88>)
 8004a84:	3104      	adds	r1, #4
}
 8004a86:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004a8a:	f7ff be75 	b.w	8004778 <vListInsertEnd>
 8004a8e:	bf00      	nop
 8004a90:	20000200 	.word	0x20000200
 8004a94:	200000e0 	.word	0x200000e0
 8004a98:	2000018c 	.word	0x2000018c
 8004a9c:	200000e4 	.word	0x200000e4
 8004aa0:	200001b8 	.word	0x200001b8
 8004aa4:	200000e8 	.word	0x200000e8
 8004aa8:	200001d8 	.word	0x200001d8

08004aac <prvIdleTask>:
{
 8004aac:	f8df a090 	ldr.w	sl, [pc, #144]	; 8004b40 <prvIdleTask+0x94>
 8004ab0:	4e21      	ldr	r6, [pc, #132]	; (8004b38 <prvIdleTask+0x8c>)
 8004ab2:	4d22      	ldr	r5, [pc, #136]	; (8004b3c <prvIdleTask+0x90>)
 8004ab4:	f8df 908c 	ldr.w	r9, [pc, #140]	; 8004b44 <prvIdleTask+0x98>
				taskYIELD();
 8004ab8:	f8df 808c 	ldr.w	r8, [pc, #140]	; 8004b48 <prvIdleTask+0x9c>
{
 8004abc:	b580      	push	{r7, lr}
				taskYIELD();
 8004abe:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8004ac2:	682b      	ldr	r3, [r5, #0]
 8004ac4:	b343      	cbz	r3, 8004b18 <prvIdleTask+0x6c>
			taskENTER_CRITICAL();
 8004ac6:	f000 fb8d 	bl	80051e4 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8004aca:	f8da 300c 	ldr.w	r3, [sl, #12]
 8004ace:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004ad0:	1d20      	adds	r0, r4, #4
 8004ad2:	f7ff fe7b 	bl	80047cc <uxListRemove>
				--uxCurrentNumberOfTasks;
 8004ad6:	6833      	ldr	r3, [r6, #0]
 8004ad8:	3b01      	subs	r3, #1
 8004ada:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
 8004adc:	682b      	ldr	r3, [r5, #0]
 8004ade:	3b01      	subs	r3, #1
 8004ae0:	602b      	str	r3, [r5, #0]
			taskEXIT_CRITICAL();
 8004ae2:	f000 fba1 	bl	8005228 <vPortExitCritical>
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8004ae6:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
 8004aea:	b163      	cbz	r3, 8004b06 <prvIdleTask+0x5a>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8004aec:	2b01      	cmp	r3, #1
 8004aee:	d01e      	beq.n	8004b2e <prvIdleTask+0x82>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 8004af0:	2b02      	cmp	r3, #2
 8004af2:	d0e6      	beq.n	8004ac2 <prvIdleTask+0x16>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8004af4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004af8:	f383 8811 	msr	BASEPRI, r3
 8004afc:	f3bf 8f6f 	isb	sy
 8004b00:	f3bf 8f4f 	dsb	sy
 8004b04:	e7fe      	b.n	8004b04 <prvIdleTask+0x58>
				vPortFree( pxTCB->pxStack );
 8004b06:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8004b08:	f000 fd44 	bl	8005594 <vPortFree>
				vPortFree( pxTCB );
 8004b0c:	4620      	mov	r0, r4
 8004b0e:	f000 fd41 	bl	8005594 <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8004b12:	682b      	ldr	r3, [r5, #0]
 8004b14:	2b00      	cmp	r3, #0
 8004b16:	d1d6      	bne.n	8004ac6 <prvIdleTask+0x1a>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8004b18:	f8d9 3000 	ldr.w	r3, [r9]
 8004b1c:	2b01      	cmp	r3, #1
 8004b1e:	d9d0      	bls.n	8004ac2 <prvIdleTask+0x16>
				taskYIELD();
 8004b20:	f8c8 7000 	str.w	r7, [r8]
 8004b24:	f3bf 8f4f 	dsb	sy
 8004b28:	f3bf 8f6f 	isb	sy
 8004b2c:	e7c9      	b.n	8004ac2 <prvIdleTask+0x16>
				vPortFree( pxTCB );
 8004b2e:	4620      	mov	r0, r4
 8004b30:	f000 fd30 	bl	8005594 <vPortFree>
 8004b34:	e7c5      	b.n	8004ac2 <prvIdleTask+0x16>
 8004b36:	bf00      	nop
 8004b38:	20000178 	.word	0x20000178
 8004b3c:	2000017c 	.word	0x2000017c
 8004b40:	200001ec 	.word	0x200001ec
 8004b44:	200000ec 	.word	0x200000ec
 8004b48:	e000ed04 	.word	0xe000ed04

08004b4c <xTaskCreateStatic>:
	{
 8004b4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004b4e:	b087      	sub	sp, #28
 8004b50:	e9dd 650c 	ldrd	r6, r5, [sp, #48]	; 0x30
 8004b54:	9c0e      	ldr	r4, [sp, #56]	; 0x38
		configASSERT( puxStackBuffer != NULL );
 8004b56:	b1bd      	cbz	r5, 8004b88 <xTaskCreateStatic+0x3c>
		configASSERT( pxTaskBuffer != NULL );
 8004b58:	b16c      	cbz	r4, 8004b76 <xTaskCreateStatic+0x2a>
			volatile size_t xSize = sizeof( StaticTask_t );
 8004b5a:	2754      	movs	r7, #84	; 0x54
 8004b5c:	9704      	str	r7, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 8004b5e:	9f04      	ldr	r7, [sp, #16]
 8004b60:	2f54      	cmp	r7, #84	; 0x54
 8004b62:	d01a      	beq.n	8004b9a <xTaskCreateStatic+0x4e>
 8004b64:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b68:	f383 8811 	msr	BASEPRI, r3
 8004b6c:	f3bf 8f6f 	isb	sy
 8004b70:	f3bf 8f4f 	dsb	sy
 8004b74:	e7fe      	b.n	8004b74 <xTaskCreateStatic+0x28>
 8004b76:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b7a:	f383 8811 	msr	BASEPRI, r3
 8004b7e:	f3bf 8f6f 	isb	sy
 8004b82:	f3bf 8f4f 	dsb	sy
 8004b86:	e7fe      	b.n	8004b86 <xTaskCreateStatic+0x3a>
 8004b88:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b8c:	f383 8811 	msr	BASEPRI, r3
 8004b90:	f3bf 8f6f 	isb	sy
 8004b94:	f3bf 8f4f 	dsb	sy
 8004b98:	e7fe      	b.n	8004b98 <xTaskCreateStatic+0x4c>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8004b9a:	6325      	str	r5, [r4, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8004b9c:	2702      	movs	r7, #2
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8004b9e:	ad05      	add	r5, sp, #20
 8004ba0:	9402      	str	r4, [sp, #8]
 8004ba2:	9600      	str	r6, [sp, #0]
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8004ba4:	f884 7051 	strb.w	r7, [r4, #81]	; 0x51
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8004ba8:	9501      	str	r5, [sp, #4]
 8004baa:	f7ff feaf 	bl	800490c <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
 8004bae:	4620      	mov	r0, r4
 8004bb0:	f7ff fe20 	bl	80047f4 <prvAddNewTaskToReadyList>
	}
 8004bb4:	9805      	ldr	r0, [sp, #20]
 8004bb6:	b007      	add	sp, #28
 8004bb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004bba:	bf00      	nop

08004bbc <xTaskCreate>:
	{
 8004bbc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004bc0:	ea4f 0a82 	mov.w	sl, r2, lsl #2
	{
 8004bc4:	4680      	mov	r8, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004bc6:	4650      	mov	r0, sl
	{
 8004bc8:	460d      	mov	r5, r1
 8004bca:	4699      	mov	r9, r3
 8004bcc:	9f09      	ldr	r7, [sp, #36]	; 0x24
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004bce:	f000 fc55 	bl	800547c <pvPortMalloc>
			if( pxStack != NULL )
 8004bd2:	2800      	cmp	r0, #0
 8004bd4:	f000 8096 	beq.w	8004d04 <xTaskCreate+0x148>
 8004bd8:	4606      	mov	r6, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8004bda:	2054      	movs	r0, #84	; 0x54
 8004bdc:	f000 fc4e 	bl	800547c <pvPortMalloc>
				if( pxNewTCB != NULL )
 8004be0:	4604      	mov	r4, r0
 8004be2:	2800      	cmp	r0, #0
 8004be4:	f000 8087 	beq.w	8004cf6 <xTaskCreate+0x13a>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8004be8:	2300      	movs	r3, #0
					pxNewTCB->pxStack = pxStack;
 8004bea:	6306      	str	r6, [r0, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8004bec:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004bf0:	782b      	ldrb	r3, [r5, #0]
 8004bf2:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8004bf6:	f1aa 0a04 	sub.w	sl, sl, #4
		if( pcName[ x ] == 0x00 )
 8004bfa:	782b      	ldrb	r3, [r5, #0]
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8004bfc:	4456      	add	r6, sl
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8004bfe:	f026 0607 	bic.w	r6, r6, #7
		if( pcName[ x ] == 0x00 )
 8004c02:	2b00      	cmp	r3, #0
 8004c04:	d04d      	beq.n	8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c06:	786b      	ldrb	r3, [r5, #1]
 8004c08:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
		if( pcName[ x ] == 0x00 )
 8004c0c:	786b      	ldrb	r3, [r5, #1]
 8004c0e:	2b00      	cmp	r3, #0
 8004c10:	d047      	beq.n	8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c12:	78ab      	ldrb	r3, [r5, #2]
 8004c14:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
		if( pcName[ x ] == 0x00 )
 8004c18:	78ab      	ldrb	r3, [r5, #2]
 8004c1a:	2b00      	cmp	r3, #0
 8004c1c:	d041      	beq.n	8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c1e:	78eb      	ldrb	r3, [r5, #3]
 8004c20:	f880 3037 	strb.w	r3, [r0, #55]	; 0x37
		if( pcName[ x ] == 0x00 )
 8004c24:	78eb      	ldrb	r3, [r5, #3]
 8004c26:	2b00      	cmp	r3, #0
 8004c28:	d03b      	beq.n	8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c2a:	792b      	ldrb	r3, [r5, #4]
 8004c2c:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
		if( pcName[ x ] == 0x00 )
 8004c30:	792b      	ldrb	r3, [r5, #4]
 8004c32:	2b00      	cmp	r3, #0
 8004c34:	d035      	beq.n	8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c36:	796b      	ldrb	r3, [r5, #5]
 8004c38:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
		if( pcName[ x ] == 0x00 )
 8004c3c:	796b      	ldrb	r3, [r5, #5]
 8004c3e:	2b00      	cmp	r3, #0
 8004c40:	d02f      	beq.n	8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c42:	79ab      	ldrb	r3, [r5, #6]
 8004c44:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
		if( pcName[ x ] == 0x00 )
 8004c48:	79ab      	ldrb	r3, [r5, #6]
 8004c4a:	b353      	cbz	r3, 8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c4c:	79eb      	ldrb	r3, [r5, #7]
 8004c4e:	f880 303b 	strb.w	r3, [r0, #59]	; 0x3b
		if( pcName[ x ] == 0x00 )
 8004c52:	79eb      	ldrb	r3, [r5, #7]
 8004c54:	b32b      	cbz	r3, 8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c56:	7a2b      	ldrb	r3, [r5, #8]
 8004c58:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
		if( pcName[ x ] == 0x00 )
 8004c5c:	7a2b      	ldrb	r3, [r5, #8]
 8004c5e:	b303      	cbz	r3, 8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c60:	7a6b      	ldrb	r3, [r5, #9]
 8004c62:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
		if( pcName[ x ] == 0x00 )
 8004c66:	7a6b      	ldrb	r3, [r5, #9]
 8004c68:	b1db      	cbz	r3, 8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c6a:	7aab      	ldrb	r3, [r5, #10]
 8004c6c:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
		if( pcName[ x ] == 0x00 )
 8004c70:	7aab      	ldrb	r3, [r5, #10]
 8004c72:	b1b3      	cbz	r3, 8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c74:	7aeb      	ldrb	r3, [r5, #11]
 8004c76:	f880 303f 	strb.w	r3, [r0, #63]	; 0x3f
		if( pcName[ x ] == 0x00 )
 8004c7a:	7aeb      	ldrb	r3, [r5, #11]
 8004c7c:	b18b      	cbz	r3, 8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c7e:	7b2b      	ldrb	r3, [r5, #12]
 8004c80:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
		if( pcName[ x ] == 0x00 )
 8004c84:	7b2b      	ldrb	r3, [r5, #12]
 8004c86:	b163      	cbz	r3, 8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c88:	7b6b      	ldrb	r3, [r5, #13]
 8004c8a:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
		if( pcName[ x ] == 0x00 )
 8004c8e:	7b6b      	ldrb	r3, [r5, #13]
 8004c90:	b13b      	cbz	r3, 8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c92:	7bab      	ldrb	r3, [r5, #14]
 8004c94:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
		if( pcName[ x ] == 0x00 )
 8004c98:	7bab      	ldrb	r3, [r5, #14]
 8004c9a:	b113      	cbz	r3, 8004ca2 <xTaskCreate+0xe6>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8004c9c:	7beb      	ldrb	r3, [r5, #15]
 8004c9e:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
 8004ca2:	9d08      	ldr	r5, [sp, #32]
 8004ca4:	2d06      	cmp	r5, #6
 8004ca6:	bf28      	it	cs
 8004ca8:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8004caa:	f04f 0a00 	mov.w	sl, #0
	pxNewTCB->uxPriority = uxPriority;
 8004cae:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8004cb0:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8004cb2:	1d20      	adds	r0, r4, #4
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8004cb4:	f884 a043 	strb.w	sl, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 8004cb8:	f8c4 a048 	str.w	sl, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8004cbc:	f7ff fd58 	bl	8004770 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004cc0:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8004cc4:	f104 0018 	add.w	r0, r4, #24
 8004cc8:	f7ff fd52 	bl	8004770 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8004ccc:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004cd0:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8004cd2:	6124      	str	r4, [r4, #16]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8004cd4:	f884 a050 	strb.w	sl, [r4, #80]	; 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8004cd8:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004cda:	464a      	mov	r2, r9
 8004cdc:	4641      	mov	r1, r8
 8004cde:	4630      	mov	r0, r6
 8004ce0:	f000 fa52 	bl	8005188 <pxPortInitialiseStack>
 8004ce4:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8004ce6:	b107      	cbz	r7, 8004cea <xTaskCreate+0x12e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8004ce8:	603c      	str	r4, [r7, #0]
			prvAddNewTaskToReadyList( pxNewTCB );
 8004cea:	4620      	mov	r0, r4
 8004cec:	f7ff fd82 	bl	80047f4 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8004cf0:	2001      	movs	r0, #1
	}
 8004cf2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					vPortFree( pxStack );
 8004cf6:	4630      	mov	r0, r6
 8004cf8:	f000 fc4c 	bl	8005594 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8004cfc:	f04f 30ff 	mov.w	r0, #4294967295
	}
 8004d00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8004d04:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
 8004d08:	e7f3      	b.n	8004cf2 <xTaskCreate+0x136>
 8004d0a:	bf00      	nop

08004d0c <vTaskStartScheduler>:
{
 8004d0c:	b530      	push	{r4, r5, lr}
 8004d0e:	b08b      	sub	sp, #44	; 0x2c
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 8004d10:	2400      	movs	r4, #0
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8004d12:	aa07      	add	r2, sp, #28
 8004d14:	a906      	add	r1, sp, #24
 8004d16:	a805      	add	r0, sp, #20
		StackType_t *pxIdleTaskStackBuffer = NULL;
 8004d18:	e9cd 4405 	strd	r4, r4, [sp, #20]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8004d1c:	f000 fc82 	bl	8005624 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 8004d20:	e9dd 5305 	ldrd	r5, r3, [sp, #20]
		configASSERT( puxStackBuffer != NULL );
 8004d24:	b1c3      	cbz	r3, 8004d58 <vTaskStartScheduler+0x4c>
		configASSERT( pxTaskBuffer != NULL );
 8004d26:	b175      	cbz	r5, 8004d46 <vTaskStartScheduler+0x3a>
			volatile size_t xSize = sizeof( StaticTask_t );
 8004d28:	2254      	movs	r2, #84	; 0x54
 8004d2a:	9208      	str	r2, [sp, #32]
			configASSERT( xSize == sizeof( TCB_t ) );
 8004d2c:	9908      	ldr	r1, [sp, #32]
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 8004d2e:	9a07      	ldr	r2, [sp, #28]
			configASSERT( xSize == sizeof( TCB_t ) );
 8004d30:	2954      	cmp	r1, #84	; 0x54
 8004d32:	d01a      	beq.n	8004d6a <vTaskStartScheduler+0x5e>
 8004d34:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d38:	f383 8811 	msr	BASEPRI, r3
 8004d3c:	f3bf 8f6f 	isb	sy
 8004d40:	f3bf 8f4f 	dsb	sy
 8004d44:	e7fe      	b.n	8004d44 <vTaskStartScheduler+0x38>
 8004d46:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d4a:	f383 8811 	msr	BASEPRI, r3
 8004d4e:	f3bf 8f6f 	isb	sy
 8004d52:	f3bf 8f4f 	dsb	sy
 8004d56:	e7fe      	b.n	8004d56 <vTaskStartScheduler+0x4a>
 8004d58:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d5c:	f383 8811 	msr	BASEPRI, r3
 8004d60:	f3bf 8f6f 	isb	sy
 8004d64:	f3bf 8f4f 	dsb	sy
 8004d68:	e7fe      	b.n	8004d68 <vTaskStartScheduler+0x5c>
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8004d6a:	2002      	movs	r0, #2
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8004d6c:	a909      	add	r1, sp, #36	; 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8004d6e:	632b      	str	r3, [r5, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8004d70:	f885 0051 	strb.w	r0, [r5, #81]	; 0x51
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8004d74:	4623      	mov	r3, r4
 8004d76:	e9cd 4100 	strd	r4, r1, [sp]
 8004d7a:	480f      	ldr	r0, [pc, #60]	; (8004db8 <vTaskStartScheduler+0xac>)
 8004d7c:	490f      	ldr	r1, [pc, #60]	; (8004dbc <vTaskStartScheduler+0xb0>)
 8004d7e:	9502      	str	r5, [sp, #8]
 8004d80:	f7ff fdc4 	bl	800490c <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
 8004d84:	4628      	mov	r0, r5
 8004d86:	f7ff fd35 	bl	80047f4 <prvAddNewTaskToReadyList>
		return xReturn;
 8004d8a:	9b09      	ldr	r3, [sp, #36]	; 0x24
		if( xIdleTaskHandle != NULL )
 8004d8c:	b193      	cbz	r3, 8004db4 <vTaskStartScheduler+0xa8>
 8004d8e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d92:	f383 8811 	msr	BASEPRI, r3
 8004d96:	f3bf 8f6f 	isb	sy
 8004d9a:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8004d9e:	4808      	ldr	r0, [pc, #32]	; (8004dc0 <vTaskStartScheduler+0xb4>)
		xSchedulerRunning = pdTRUE;
 8004da0:	4a08      	ldr	r2, [pc, #32]	; (8004dc4 <vTaskStartScheduler+0xb8>)
		xTickCount = ( TickType_t ) 0U;
 8004da2:	4b09      	ldr	r3, [pc, #36]	; (8004dc8 <vTaskStartScheduler+0xbc>)
		xNextTaskUnblockTime = portMAX_DELAY;
 8004da4:	f04f 35ff 	mov.w	r5, #4294967295
		xSchedulerRunning = pdTRUE;
 8004da8:	2101      	movs	r1, #1
		xNextTaskUnblockTime = portMAX_DELAY;
 8004daa:	6005      	str	r5, [r0, #0]
		xSchedulerRunning = pdTRUE;
 8004dac:	6011      	str	r1, [r2, #0]
		xTickCount = ( TickType_t ) 0U;
 8004dae:	601c      	str	r4, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8004db0:	f000 fab4 	bl	800531c <xPortStartScheduler>
}
 8004db4:	b00b      	add	sp, #44	; 0x2c
 8004db6:	bd30      	pop	{r4, r5, pc}
 8004db8:	08004aad 	.word	0x08004aad
 8004dbc:	08007e28 	.word	0x08007e28
 8004dc0:	200001b8 	.word	0x200001b8
 8004dc4:	200001d4 	.word	0x200001d4
 8004dc8:	20000200 	.word	0x20000200

08004dcc <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8004dcc:	4a02      	ldr	r2, [pc, #8]	; (8004dd8 <vTaskSuspendAll+0xc>)
 8004dce:	6813      	ldr	r3, [r2, #0]
 8004dd0:	3301      	adds	r3, #1
 8004dd2:	6013      	str	r3, [r2, #0]
}
 8004dd4:	4770      	bx	lr
 8004dd6:	bf00      	nop
 8004dd8:	20000184 	.word	0x20000184

08004ddc <xTaskIncrementTick>:
{
 8004ddc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004de0:	4b49      	ldr	r3, [pc, #292]	; (8004f08 <xTaskIncrementTick+0x12c>)
 8004de2:	681b      	ldr	r3, [r3, #0]
 8004de4:	b9cb      	cbnz	r3, 8004e1a <xTaskIncrementTick+0x3e>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8004de6:	4b49      	ldr	r3, [pc, #292]	; (8004f0c <xTaskIncrementTick+0x130>)
 8004de8:	681e      	ldr	r6, [r3, #0]
 8004dea:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
 8004dec:	601e      	str	r6, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8004dee:	b30e      	cbz	r6, 8004e34 <xTaskIncrementTick+0x58>
 8004df0:	f8df b138 	ldr.w	fp, [pc, #312]	; 8004f2c <xTaskIncrementTick+0x150>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8004df4:	f8db 2000 	ldr.w	r2, [fp]
 8004df8:	42b2      	cmp	r2, r6
 8004dfa:	d929      	bls.n	8004e50 <xTaskIncrementTick+0x74>
 8004dfc:	4f44      	ldr	r7, [pc, #272]	; (8004f10 <xTaskIncrementTick+0x134>)
 8004dfe:	f8df 8130 	ldr.w	r8, [pc, #304]	; 8004f30 <xTaskIncrementTick+0x154>
BaseType_t xSwitchRequired = pdFALSE;
 8004e02:	2500      	movs	r5, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8004e04:	f8d8 3000 	ldr.w	r3, [r8]
 8004e08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004e0a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004e0e:	009b      	lsls	r3, r3, #2
 8004e10:	58fb      	ldr	r3, [r7, r3]
				xSwitchRequired = pdTRUE;
 8004e12:	2b02      	cmp	r3, #2
 8004e14:	bf28      	it	cs
 8004e16:	2501      	movcs	r5, #1
 8004e18:	e004      	b.n	8004e24 <xTaskIncrementTick+0x48>
		++uxPendedTicks;
 8004e1a:	4a3e      	ldr	r2, [pc, #248]	; (8004f14 <xTaskIncrementTick+0x138>)
 8004e1c:	6813      	ldr	r3, [r2, #0]
 8004e1e:	3301      	adds	r3, #1
 8004e20:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8004e22:	2500      	movs	r5, #0
		if( xYieldPending != pdFALSE )
 8004e24:	4b3c      	ldr	r3, [pc, #240]	; (8004f18 <xTaskIncrementTick+0x13c>)
 8004e26:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
 8004e28:	2b00      	cmp	r3, #0
}
 8004e2a:	bf0c      	ite	eq
 8004e2c:	4628      	moveq	r0, r5
 8004e2e:	2001      	movne	r0, #1
 8004e30:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
 8004e34:	4c39      	ldr	r4, [pc, #228]	; (8004f1c <xTaskIncrementTick+0x140>)
 8004e36:	6823      	ldr	r3, [r4, #0]
 8004e38:	681b      	ldr	r3, [r3, #0]
 8004e3a:	2b00      	cmp	r3, #0
 8004e3c:	d048      	beq.n	8004ed0 <xTaskIncrementTick+0xf4>
 8004e3e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004e42:	f383 8811 	msr	BASEPRI, r3
 8004e46:	f3bf 8f6f 	isb	sy
 8004e4a:	f3bf 8f4f 	dsb	sy
 8004e4e:	e7fe      	b.n	8004e4e <xTaskIncrementTick+0x72>
 8004e50:	4c32      	ldr	r4, [pc, #200]	; (8004f1c <xTaskIncrementTick+0x140>)
 8004e52:	4f2f      	ldr	r7, [pc, #188]	; (8004f10 <xTaskIncrementTick+0x134>)
 8004e54:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 8004f30 <xTaskIncrementTick+0x154>
BaseType_t xSwitchRequired = pdFALSE;
 8004e58:	2500      	movs	r5, #0
 8004e5a:	e02d      	b.n	8004eb8 <xTaskIncrementTick+0xdc>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004e5c:	6822      	ldr	r2, [r4, #0]
 8004e5e:	68d2      	ldr	r2, [r2, #12]
 8004e60:	f8d2 900c 	ldr.w	r9, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8004e64:	f8d9 1004 	ldr.w	r1, [r9, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004e68:	f109 0a04 	add.w	sl, r9, #4
					if( xConstTickCount < xItemValue )
 8004e6c:	428e      	cmp	r6, r1
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004e6e:	4650      	mov	r0, sl
					if( xConstTickCount < xItemValue )
 8004e70:	d32b      	bcc.n	8004eca <xTaskIncrementTick+0xee>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004e72:	f7ff fcab 	bl	80047cc <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8004e76:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004e7a:	f109 0018 	add.w	r0, r9, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8004e7e:	b109      	cbz	r1, 8004e84 <xTaskIncrementTick+0xa8>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004e80:	f7ff fca4 	bl	80047cc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8004e84:	4a26      	ldr	r2, [pc, #152]	; (8004f20 <xTaskIncrementTick+0x144>)
 8004e86:	f8d9 002c 	ldr.w	r0, [r9, #44]	; 0x2c
 8004e8a:	6813      	ldr	r3, [r2, #0]
 8004e8c:	2101      	movs	r1, #1
 8004e8e:	fa01 fc00 	lsl.w	ip, r1, r0
 8004e92:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8004e96:	4651      	mov	r1, sl
 8004e98:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8004e9c:	ea4c 0c03 	orr.w	ip, ip, r3
 8004ea0:	f8c2 c000 	str.w	ip, [r2]
 8004ea4:	f7ff fc68 	bl	8004778 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004ea8:	f8d8 0000 	ldr.w	r0, [r8]
 8004eac:	f8d9 102c 	ldr.w	r1, [r9, #44]	; 0x2c
 8004eb0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 8004eb2:	4291      	cmp	r1, r2
 8004eb4:	bf28      	it	cs
 8004eb6:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004eb8:	6822      	ldr	r2, [r4, #0]
 8004eba:	6812      	ldr	r2, [r2, #0]
 8004ebc:	2a00      	cmp	r2, #0
 8004ebe:	d1cd      	bne.n	8004e5c <xTaskIncrementTick+0x80>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004ec0:	f04f 32ff 	mov.w	r2, #4294967295
 8004ec4:	f8cb 2000 	str.w	r2, [fp]
					break;
 8004ec8:	e79c      	b.n	8004e04 <xTaskIncrementTick+0x28>
						xNextTaskUnblockTime = xItemValue;
 8004eca:	f8cb 1000 	str.w	r1, [fp]
						break;
 8004ece:	e799      	b.n	8004e04 <xTaskIncrementTick+0x28>
			taskSWITCH_DELAYED_LISTS();
 8004ed0:	4b14      	ldr	r3, [pc, #80]	; (8004f24 <xTaskIncrementTick+0x148>)
 8004ed2:	6821      	ldr	r1, [r4, #0]
 8004ed4:	4a14      	ldr	r2, [pc, #80]	; (8004f28 <xTaskIncrementTick+0x14c>)
 8004ed6:	6818      	ldr	r0, [r3, #0]
 8004ed8:	6020      	str	r0, [r4, #0]
 8004eda:	6019      	str	r1, [r3, #0]
 8004edc:	6813      	ldr	r3, [r2, #0]
 8004ede:	3301      	adds	r3, #1
 8004ee0:	6013      	str	r3, [r2, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004ee2:	6823      	ldr	r3, [r4, #0]
 8004ee4:	681b      	ldr	r3, [r3, #0]
 8004ee6:	b933      	cbnz	r3, 8004ef6 <xTaskIncrementTick+0x11a>
		xNextTaskUnblockTime = portMAX_DELAY;
 8004ee8:	f8df b040 	ldr.w	fp, [pc, #64]	; 8004f2c <xTaskIncrementTick+0x150>
 8004eec:	f04f 32ff 	mov.w	r2, #4294967295
 8004ef0:	f8cb 2000 	str.w	r2, [fp]
 8004ef4:	e77e      	b.n	8004df4 <xTaskIncrementTick+0x18>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004ef6:	6822      	ldr	r2, [r4, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8004ef8:	f8df b030 	ldr.w	fp, [pc, #48]	; 8004f2c <xTaskIncrementTick+0x150>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004efc:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8004efe:	68d2      	ldr	r2, [r2, #12]
 8004f00:	6852      	ldr	r2, [r2, #4]
 8004f02:	f8cb 2000 	str.w	r2, [fp]
 8004f06:	e775      	b.n	8004df4 <xTaskIncrementTick+0x18>
 8004f08:	20000184 	.word	0x20000184
 8004f0c:	20000200 	.word	0x20000200
 8004f10:	200000ec 	.word	0x200000ec
 8004f14:	20000180 	.word	0x20000180
 8004f18:	20000204 	.word	0x20000204
 8004f1c:	200000e4 	.word	0x200000e4
 8004f20:	2000018c 	.word	0x2000018c
 8004f24:	200000e8 	.word	0x200000e8
 8004f28:	200001bc 	.word	0x200001bc
 8004f2c:	200001b8 	.word	0x200001b8
 8004f30:	200000e0 	.word	0x200000e0

08004f34 <xTaskResumeAll>:
{
 8004f34:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	configASSERT( uxSchedulerSuspended );
 8004f38:	4c38      	ldr	r4, [pc, #224]	; (800501c <xTaskResumeAll+0xe8>)
 8004f3a:	6823      	ldr	r3, [r4, #0]
 8004f3c:	b943      	cbnz	r3, 8004f50 <xTaskResumeAll+0x1c>
 8004f3e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f42:	f383 8811 	msr	BASEPRI, r3
 8004f46:	f3bf 8f6f 	isb	sy
 8004f4a:	f3bf 8f4f 	dsb	sy
 8004f4e:	e7fe      	b.n	8004f4e <xTaskResumeAll+0x1a>
	taskENTER_CRITICAL();
 8004f50:	f000 f948 	bl	80051e4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8004f54:	6823      	ldr	r3, [r4, #0]
 8004f56:	3b01      	subs	r3, #1
 8004f58:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004f5a:	6824      	ldr	r4, [r4, #0]
 8004f5c:	bb7c      	cbnz	r4, 8004fbe <xTaskResumeAll+0x8a>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8004f5e:	4b30      	ldr	r3, [pc, #192]	; (8005020 <xTaskResumeAll+0xec>)
 8004f60:	681b      	ldr	r3, [r3, #0]
 8004f62:	b363      	cbz	r3, 8004fbe <xTaskResumeAll+0x8a>
 8004f64:	4d2f      	ldr	r5, [pc, #188]	; (8005024 <xTaskResumeAll+0xf0>)
 8004f66:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 800503c <xTaskResumeAll+0x108>
					prvAddTaskToReadyList( pxTCB );
 8004f6a:	4e2f      	ldr	r6, [pc, #188]	; (8005028 <xTaskResumeAll+0xf4>)
 8004f6c:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8005040 <xTaskResumeAll+0x10c>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004f70:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 8005044 <xTaskResumeAll+0x110>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8004f74:	f8da 3000 	ldr.w	r3, [sl]
					prvAddTaskToReadyList( pxTCB );
 8004f78:	2701      	movs	r7, #1
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8004f7a:	b333      	cbz	r3, 8004fca <xTaskResumeAll+0x96>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8004f7c:	f8da 300c 	ldr.w	r3, [sl, #12]
 8004f80:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004f82:	f104 0804 	add.w	r8, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004f86:	f104 0018 	add.w	r0, r4, #24
 8004f8a:	f7ff fc1f 	bl	80047cc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004f8e:	4640      	mov	r0, r8
 8004f90:	f7ff fc1c 	bl	80047cc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8004f94:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004f96:	6832      	ldr	r2, [r6, #0]
 8004f98:	fa07 f300 	lsl.w	r3, r7, r0
 8004f9c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8004fa0:	4313      	orrs	r3, r2
 8004fa2:	4641      	mov	r1, r8
 8004fa4:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 8004fa8:	6033      	str	r3, [r6, #0]
 8004faa:	f7ff fbe5 	bl	8004778 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004fae:	f8db 3000 	ldr.w	r3, [fp]
 8004fb2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004fb4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004fb6:	429a      	cmp	r2, r3
 8004fb8:	d3dc      	bcc.n	8004f74 <xTaskResumeAll+0x40>
						xYieldPending = pdTRUE;
 8004fba:	602f      	str	r7, [r5, #0]
 8004fbc:	e7da      	b.n	8004f74 <xTaskResumeAll+0x40>
BaseType_t xAlreadyYielded = pdFALSE;
 8004fbe:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8004fc0:	f000 f932 	bl	8005228 <vPortExitCritical>
}
 8004fc4:	4620      	mov	r0, r4
 8004fc6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( pxTCB != NULL )
 8004fca:	b13c      	cbz	r4, 8004fdc <xTaskResumeAll+0xa8>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004fcc:	4b17      	ldr	r3, [pc, #92]	; (800502c <xTaskResumeAll+0xf8>)
 8004fce:	681a      	ldr	r2, [r3, #0]
 8004fd0:	6812      	ldr	r2, [r2, #0]
 8004fd2:	b9da      	cbnz	r2, 800500c <xTaskResumeAll+0xd8>
		xNextTaskUnblockTime = portMAX_DELAY;
 8004fd4:	4b16      	ldr	r3, [pc, #88]	; (8005030 <xTaskResumeAll+0xfc>)
 8004fd6:	f04f 32ff 	mov.w	r2, #4294967295
 8004fda:	601a      	str	r2, [r3, #0]
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8004fdc:	4e15      	ldr	r6, [pc, #84]	; (8005034 <xTaskResumeAll+0x100>)
 8004fde:	6834      	ldr	r4, [r6, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8004fe0:	b13c      	cbz	r4, 8004ff2 <xTaskResumeAll+0xbe>
								xYieldPending = pdTRUE;
 8004fe2:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
 8004fe4:	f7ff fefa 	bl	8004ddc <xTaskIncrementTick>
 8004fe8:	b100      	cbz	r0, 8004fec <xTaskResumeAll+0xb8>
								xYieldPending = pdTRUE;
 8004fea:	602f      	str	r7, [r5, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8004fec:	3c01      	subs	r4, #1
 8004fee:	d1f9      	bne.n	8004fe4 <xTaskResumeAll+0xb0>
						uxPendedTicks = 0;
 8004ff0:	6034      	str	r4, [r6, #0]
				if( xYieldPending != pdFALSE )
 8004ff2:	682b      	ldr	r3, [r5, #0]
 8004ff4:	2b00      	cmp	r3, #0
 8004ff6:	d0e2      	beq.n	8004fbe <xTaskResumeAll+0x8a>
					taskYIELD_IF_USING_PREEMPTION();
 8004ff8:	4b0f      	ldr	r3, [pc, #60]	; (8005038 <xTaskResumeAll+0x104>)
 8004ffa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004ffe:	601a      	str	r2, [r3, #0]
 8005000:	f3bf 8f4f 	dsb	sy
 8005004:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8005008:	2401      	movs	r4, #1
 800500a:	e7d9      	b.n	8004fc0 <xTaskResumeAll+0x8c>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800500c:	681a      	ldr	r2, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800500e:	4b08      	ldr	r3, [pc, #32]	; (8005030 <xTaskResumeAll+0xfc>)
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8005010:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8005012:	68d2      	ldr	r2, [r2, #12]
 8005014:	6852      	ldr	r2, [r2, #4]
 8005016:	601a      	str	r2, [r3, #0]
 8005018:	e7e0      	b.n	8004fdc <xTaskResumeAll+0xa8>
 800501a:	bf00      	nop
 800501c:	20000184 	.word	0x20000184
 8005020:	20000178 	.word	0x20000178
 8005024:	20000204 	.word	0x20000204
 8005028:	2000018c 	.word	0x2000018c
 800502c:	200000e4 	.word	0x200000e4
 8005030:	200001b8 	.word	0x200001b8
 8005034:	20000180 	.word	0x20000180
 8005038:	e000ed04 	.word	0xe000ed04
 800503c:	200001c0 	.word	0x200001c0
 8005040:	200000ec 	.word	0x200000ec
 8005044:	200000e0 	.word	0x200000e0

08005048 <vTaskDelay>:
	{
 8005048:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 800504a:	b198      	cbz	r0, 8005074 <vTaskDelay+0x2c>
			configASSERT( uxSchedulerSuspended == 0 );
 800504c:	4b0e      	ldr	r3, [pc, #56]	; (8005088 <vTaskDelay+0x40>)
 800504e:	6819      	ldr	r1, [r3, #0]
 8005050:	b141      	cbz	r1, 8005064 <vTaskDelay+0x1c>
 8005052:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005056:	f383 8811 	msr	BASEPRI, r3
 800505a:	f3bf 8f6f 	isb	sy
 800505e:	f3bf 8f4f 	dsb	sy
 8005062:	e7fe      	b.n	8005062 <vTaskDelay+0x1a>
	++uxSchedulerSuspended;
 8005064:	681a      	ldr	r2, [r3, #0]
 8005066:	3201      	adds	r2, #1
 8005068:	601a      	str	r2, [r3, #0]
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800506a:	f7ff fcd9 	bl	8004a20 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 800506e:	f7ff ff61 	bl	8004f34 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8005072:	b938      	cbnz	r0, 8005084 <vTaskDelay+0x3c>
			portYIELD_WITHIN_API();
 8005074:	4b05      	ldr	r3, [pc, #20]	; (800508c <vTaskDelay+0x44>)
 8005076:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800507a:	601a      	str	r2, [r3, #0]
 800507c:	f3bf 8f4f 	dsb	sy
 8005080:	f3bf 8f6f 	isb	sy
	}
 8005084:	bd08      	pop	{r3, pc}
 8005086:	bf00      	nop
 8005088:	20000184 	.word	0x20000184
 800508c:	e000ed04 	.word	0xe000ed04

08005090 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8005090:	4b19      	ldr	r3, [pc, #100]	; (80050f8 <vTaskSwitchContext+0x68>)
 8005092:	681b      	ldr	r3, [r3, #0]
 8005094:	b9eb      	cbnz	r3, 80050d2 <vTaskSwitchContext+0x42>
		xYieldPending = pdFALSE;
 8005096:	4919      	ldr	r1, [pc, #100]	; (80050fc <vTaskSwitchContext+0x6c>)
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8005098:	4a19      	ldr	r2, [pc, #100]	; (8005100 <vTaskSwitchContext+0x70>)
{
 800509a:	b410      	push	{r4}
		xYieldPending = pdFALSE;
 800509c:	600b      	str	r3, [r1, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800509e:	6813      	ldr	r3, [r2, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 80050a0:	fab3 f383 	clz	r3, r3
 80050a4:	b2db      	uxtb	r3, r3
 80050a6:	f1c3 031f 	rsb	r3, r3, #31
 80050aa:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80050ae:	0092      	lsls	r2, r2, #2
 80050b0:	4814      	ldr	r0, [pc, #80]	; (8005104 <vTaskSwitchContext+0x74>)
 80050b2:	5881      	ldr	r1, [r0, r2]
 80050b4:	1884      	adds	r4, r0, r2
 80050b6:	b181      	cbz	r1, 80050da <vTaskSwitchContext+0x4a>
 80050b8:	6861      	ldr	r1, [r4, #4]
 80050ba:	3208      	adds	r2, #8
 80050bc:	6849      	ldr	r1, [r1, #4]
 80050be:	6061      	str	r1, [r4, #4]
 80050c0:	4402      	add	r2, r0
 80050c2:	4291      	cmp	r1, r2
 80050c4:	d012      	beq.n	80050ec <vTaskSwitchContext+0x5c>
 80050c6:	4b10      	ldr	r3, [pc, #64]	; (8005108 <vTaskSwitchContext+0x78>)
 80050c8:	68ca      	ldr	r2, [r1, #12]
 80050ca:	601a      	str	r2, [r3, #0]
}
 80050cc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80050d0:	4770      	bx	lr
		xYieldPending = pdTRUE;
 80050d2:	4b0a      	ldr	r3, [pc, #40]	; (80050fc <vTaskSwitchContext+0x6c>)
 80050d4:	2201      	movs	r2, #1
 80050d6:	601a      	str	r2, [r3, #0]
 80050d8:	4770      	bx	lr
	__asm volatile
 80050da:	f04f 0350 	mov.w	r3, #80	; 0x50
 80050de:	f383 8811 	msr	BASEPRI, r3
 80050e2:	f3bf 8f6f 	isb	sy
 80050e6:	f3bf 8f4f 	dsb	sy
 80050ea:	e7fe      	b.n	80050ea <vTaskSwitchContext+0x5a>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80050ec:	2214      	movs	r2, #20
 80050ee:	fb02 0303 	mla	r3, r2, r3, r0
 80050f2:	6849      	ldr	r1, [r1, #4]
 80050f4:	6059      	str	r1, [r3, #4]
 80050f6:	e7e6      	b.n	80050c6 <vTaskSwitchContext+0x36>
 80050f8:	20000184 	.word	0x20000184
 80050fc:	20000204 	.word	0x20000204
 8005100:	2000018c 	.word	0x2000018c
 8005104:	200000ec 	.word	0x200000ec
 8005108:	200000e0 	.word	0x200000e0

0800510c <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800510c:	4b0e      	ldr	r3, [pc, #56]	; (8005148 <prvTaskExitError+0x3c>)
 800510e:	681b      	ldr	r3, [r3, #0]
{
 8005110:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8005112:	2200      	movs	r2, #0
	configASSERT( uxCriticalNesting == ~0UL );
 8005114:	3301      	adds	r3, #1
volatile uint32_t ulDummy = 0;
 8005116:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
 8005118:	d008      	beq.n	800512c <prvTaskExitError+0x20>
 800511a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800511e:	f383 8811 	msr	BASEPRI, r3
 8005122:	f3bf 8f6f 	isb	sy
 8005126:	f3bf 8f4f 	dsb	sy
 800512a:	e7fe      	b.n	800512a <prvTaskExitError+0x1e>
 800512c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005130:	f383 8811 	msr	BASEPRI, r3
 8005134:	f3bf 8f6f 	isb	sy
 8005138:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 800513c:	9b01      	ldr	r3, [sp, #4]
 800513e:	2b00      	cmp	r3, #0
 8005140:	d0fc      	beq.n	800513c <prvTaskExitError+0x30>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8005142:	b002      	add	sp, #8
 8005144:	4770      	bx	lr
 8005146:	bf00      	nop
 8005148:	20000004 	.word	0x20000004

0800514c <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 800514c:	4808      	ldr	r0, [pc, #32]	; (8005170 <prvPortStartFirstTask+0x24>)
 800514e:	6800      	ldr	r0, [r0, #0]
 8005150:	6800      	ldr	r0, [r0, #0]
 8005152:	f380 8808 	msr	MSP, r0
 8005156:	f04f 0000 	mov.w	r0, #0
 800515a:	f380 8814 	msr	CONTROL, r0
 800515e:	b662      	cpsie	i
 8005160:	b661      	cpsie	f
 8005162:	f3bf 8f4f 	dsb	sy
 8005166:	f3bf 8f6f 	isb	sy
 800516a:	df00      	svc	0
 800516c:	bf00      	nop
 800516e:	0000      	.short	0x0000
 8005170:	e000ed08 	.word	0xe000ed08

08005174 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8005174:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8005184 <vPortEnableVFP+0x10>
 8005178:	6801      	ldr	r1, [r0, #0]
 800517a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800517e:	6001      	str	r1, [r0, #0]
 8005180:	4770      	bx	lr
 8005182:	0000      	.short	0x0000
 8005184:	e000ed88 	.word	0xe000ed88

08005188 <pxPortInitialiseStack>:
{
 8005188:	b430      	push	{r4, r5}
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 800518a:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800518e:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8005192:	4c07      	ldr	r4, [pc, #28]	; (80051b0 <pxPortInitialiseStack+0x28>)
 8005194:	f840 4c0c 	str.w	r4, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8005198:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800519c:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80051a0:	e940 1502 	strd	r1, r5, [r0, #-8]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 80051a4:	f840 3c24 	str.w	r3, [r0, #-36]
}
 80051a8:	bc30      	pop	{r4, r5}
 80051aa:	3844      	subs	r0, #68	; 0x44
 80051ac:	4770      	bx	lr
 80051ae:	bf00      	nop
 80051b0:	0800510d 	.word	0x0800510d
	...

080051c0 <SVC_Handler>:
	__asm volatile (
 80051c0:	4b07      	ldr	r3, [pc, #28]	; (80051e0 <pxCurrentTCBConst2>)
 80051c2:	6819      	ldr	r1, [r3, #0]
 80051c4:	6808      	ldr	r0, [r1, #0]
 80051c6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80051ca:	f380 8809 	msr	PSP, r0
 80051ce:	f3bf 8f6f 	isb	sy
 80051d2:	f04f 0000 	mov.w	r0, #0
 80051d6:	f380 8811 	msr	BASEPRI, r0
 80051da:	4770      	bx	lr
 80051dc:	f3af 8000 	nop.w

080051e0 <pxCurrentTCBConst2>:
 80051e0:	200000e0 	.word	0x200000e0

080051e4 <vPortEnterCritical>:
 80051e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80051e8:	f383 8811 	msr	BASEPRI, r3
 80051ec:	f3bf 8f6f 	isb	sy
 80051f0:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 80051f4:	4a0a      	ldr	r2, [pc, #40]	; (8005220 <vPortEnterCritical+0x3c>)
 80051f6:	6813      	ldr	r3, [r2, #0]
 80051f8:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 80051fa:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 80051fc:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 80051fe:	d000      	beq.n	8005202 <vPortEnterCritical+0x1e>
}
 8005200:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8005202:	4b08      	ldr	r3, [pc, #32]	; (8005224 <vPortEnterCritical+0x40>)
 8005204:	681b      	ldr	r3, [r3, #0]
 8005206:	f013 0fff 	tst.w	r3, #255	; 0xff
 800520a:	d0f9      	beq.n	8005200 <vPortEnterCritical+0x1c>
 800520c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005210:	f383 8811 	msr	BASEPRI, r3
 8005214:	f3bf 8f6f 	isb	sy
 8005218:	f3bf 8f4f 	dsb	sy
 800521c:	e7fe      	b.n	800521c <vPortEnterCritical+0x38>
 800521e:	bf00      	nop
 8005220:	20000004 	.word	0x20000004
 8005224:	e000ed04 	.word	0xe000ed04

08005228 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8005228:	4a08      	ldr	r2, [pc, #32]	; (800524c <vPortExitCritical+0x24>)
 800522a:	6813      	ldr	r3, [r2, #0]
 800522c:	b943      	cbnz	r3, 8005240 <vPortExitCritical+0x18>
 800522e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005232:	f383 8811 	msr	BASEPRI, r3
 8005236:	f3bf 8f6f 	isb	sy
 800523a:	f3bf 8f4f 	dsb	sy
 800523e:	e7fe      	b.n	800523e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8005240:	3b01      	subs	r3, #1
 8005242:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8005244:	b90b      	cbnz	r3, 800524a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8005246:	f383 8811 	msr	BASEPRI, r3
}
 800524a:	4770      	bx	lr
 800524c:	20000004 	.word	0x20000004

08005250 <PendSV_Handler>:
	__asm volatile
 8005250:	f3ef 8009 	mrs	r0, PSP
 8005254:	f3bf 8f6f 	isb	sy
 8005258:	4b15      	ldr	r3, [pc, #84]	; (80052b0 <pxCurrentTCBConst>)
 800525a:	681a      	ldr	r2, [r3, #0]
 800525c:	f01e 0f10 	tst.w	lr, #16
 8005260:	bf08      	it	eq
 8005262:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8005266:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800526a:	6010      	str	r0, [r2, #0]
 800526c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8005270:	f04f 0050 	mov.w	r0, #80	; 0x50
 8005274:	f380 8811 	msr	BASEPRI, r0
 8005278:	f3bf 8f4f 	dsb	sy
 800527c:	f3bf 8f6f 	isb	sy
 8005280:	f7ff ff06 	bl	8005090 <vTaskSwitchContext>
 8005284:	f04f 0000 	mov.w	r0, #0
 8005288:	f380 8811 	msr	BASEPRI, r0
 800528c:	bc09      	pop	{r0, r3}
 800528e:	6819      	ldr	r1, [r3, #0]
 8005290:	6808      	ldr	r0, [r1, #0]
 8005292:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005296:	f01e 0f10 	tst.w	lr, #16
 800529a:	bf08      	it	eq
 800529c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80052a0:	f380 8809 	msr	PSP, r0
 80052a4:	f3bf 8f6f 	isb	sy
 80052a8:	4770      	bx	lr
 80052aa:	bf00      	nop
 80052ac:	f3af 8000 	nop.w

080052b0 <pxCurrentTCBConst>:
 80052b0:	200000e0 	.word	0x200000e0

080052b4 <SysTick_Handler>:
{
 80052b4:	b508      	push	{r3, lr}
	__asm volatile
 80052b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80052ba:	f383 8811 	msr	BASEPRI, r3
 80052be:	f3bf 8f6f 	isb	sy
 80052c2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 80052c6:	f7ff fd89 	bl	8004ddc <xTaskIncrementTick>
 80052ca:	b118      	cbz	r0, 80052d4 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80052cc:	4b03      	ldr	r3, [pc, #12]	; (80052dc <SysTick_Handler+0x28>)
 80052ce:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80052d2:	601a      	str	r2, [r3, #0]
	__asm volatile
 80052d4:	2300      	movs	r3, #0
 80052d6:	f383 8811 	msr	BASEPRI, r3
}
 80052da:	bd08      	pop	{r3, pc}
 80052dc:	e000ed04 	.word	0xe000ed04

080052e0 <vPortSetupTimerInterrupt>:
{
 80052e0:	b430      	push	{r4, r5}
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 80052e2:	4a09      	ldr	r2, [pc, #36]	; (8005308 <vPortSetupTimerInterrupt+0x28>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 80052e4:	4d09      	ldr	r5, [pc, #36]	; (800530c <vPortSetupTimerInterrupt+0x2c>)
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80052e6:	4b0a      	ldr	r3, [pc, #40]	; (8005310 <vPortSetupTimerInterrupt+0x30>)
 80052e8:	4c0a      	ldr	r4, [pc, #40]	; (8005314 <vPortSetupTimerInterrupt+0x34>)
 80052ea:	480b      	ldr	r0, [pc, #44]	; (8005318 <vPortSetupTimerInterrupt+0x38>)
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 80052ec:	2100      	movs	r1, #0
 80052ee:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 80052f0:	6029      	str	r1, [r5, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80052f2:	681b      	ldr	r3, [r3, #0]
 80052f4:	fba4 1303 	umull	r1, r3, r4, r3
 80052f8:	099b      	lsrs	r3, r3, #6
 80052fa:	3b01      	subs	r3, #1
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 80052fc:	2107      	movs	r1, #7
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80052fe:	6003      	str	r3, [r0, #0]
}
 8005300:	bc30      	pop	{r4, r5}
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8005302:	6011      	str	r1, [r2, #0]
}
 8005304:	4770      	bx	lr
 8005306:	bf00      	nop
 8005308:	e000e010 	.word	0xe000e010
 800530c:	e000e018 	.word	0xe000e018
 8005310:	20000008 	.word	0x20000008
 8005314:	10624dd3 	.word	0x10624dd3
 8005318:	e000e014 	.word	0xe000e014

0800531c <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 800531c:	4b3a      	ldr	r3, [pc, #232]	; (8005408 <xPortStartScheduler+0xec>)
 800531e:	4a3b      	ldr	r2, [pc, #236]	; (800540c <xPortStartScheduler+0xf0>)
 8005320:	6819      	ldr	r1, [r3, #0]
 8005322:	4291      	cmp	r1, r2
 8005324:	d040      	beq.n	80053a8 <xPortStartScheduler+0x8c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8005326:	681a      	ldr	r2, [r3, #0]
 8005328:	4b39      	ldr	r3, [pc, #228]	; (8005410 <xPortStartScheduler+0xf4>)
 800532a:	429a      	cmp	r2, r3
 800532c:	d033      	beq.n	8005396 <xPortStartScheduler+0x7a>
{
 800532e:	b510      	push	{r4, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8005330:	4b38      	ldr	r3, [pc, #224]	; (8005414 <xPortStartScheduler+0xf8>)
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8005332:	4839      	ldr	r0, [pc, #228]	; (8005418 <xPortStartScheduler+0xfc>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8005334:	781a      	ldrb	r2, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005336:	4c39      	ldr	r4, [pc, #228]	; (800541c <xPortStartScheduler+0x100>)
{
 8005338:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800533a:	b2d2      	uxtb	r2, r2
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800533c:	21ff      	movs	r1, #255	; 0xff
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800533e:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8005340:	7019      	strb	r1, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8005342:	781b      	ldrb	r3, [r3, #0]
 8005344:	b2db      	uxtb	r3, r3
 8005346:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800534a:	f89d 3003 	ldrb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800534e:	f89d 2003 	ldrb.w	r2, [sp, #3]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8005352:	2107      	movs	r1, #7
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005354:	f003 0350 	and.w	r3, r3, #80	; 0x50
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8005358:	6001      	str	r1, [r0, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800535a:	0611      	lsls	r1, r2, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800535c:	7023      	strb	r3, [r4, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800535e:	d511      	bpl.n	8005384 <xPortStartScheduler+0x68>
 8005360:	2306      	movs	r3, #6
 8005362:	e000      	b.n	8005366 <xPortStartScheduler+0x4a>
 8005364:	460b      	mov	r3, r1
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8005366:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800536a:	0052      	lsls	r2, r2, #1
 800536c:	b2d2      	uxtb	r2, r2
 800536e:	f88d 2003 	strb.w	r2, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8005372:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8005376:	0612      	lsls	r2, r2, #24
 8005378:	f103 31ff 	add.w	r1, r3, #4294967295
 800537c:	d4f2      	bmi.n	8005364 <xPortStartScheduler+0x48>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 800537e:	2b03      	cmp	r3, #3
 8005380:	6003      	str	r3, [r0, #0]
 8005382:	d01a      	beq.n	80053ba <xPortStartScheduler+0x9e>
	__asm volatile
 8005384:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005388:	f383 8811 	msr	BASEPRI, r3
 800538c:	f3bf 8f6f 	isb	sy
 8005390:	f3bf 8f4f 	dsb	sy
 8005394:	e7fe      	b.n	8005394 <xPortStartScheduler+0x78>
 8005396:	f04f 0350 	mov.w	r3, #80	; 0x50
 800539a:	f383 8811 	msr	BASEPRI, r3
 800539e:	f3bf 8f6f 	isb	sy
 80053a2:	f3bf 8f4f 	dsb	sy
 80053a6:	e7fe      	b.n	80053a6 <xPortStartScheduler+0x8a>
 80053a8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80053ac:	f383 8811 	msr	BASEPRI, r3
 80053b0:	f3bf 8f6f 	isb	sy
 80053b4:	f3bf 8f4f 	dsb	sy
 80053b8:	e7fe      	b.n	80053b8 <xPortStartScheduler+0x9c>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80053ba:	9901      	ldr	r1, [sp, #4]
 80053bc:	4c15      	ldr	r4, [pc, #84]	; (8005414 <xPortStartScheduler+0xf8>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80053be:	4a18      	ldr	r2, [pc, #96]	; (8005420 <xPortStartScheduler+0x104>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 80053c0:	021b      	lsls	r3, r3, #8
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80053c2:	b2c9      	uxtb	r1, r1
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80053c4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80053c8:	6003      	str	r3, [r0, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80053ca:	7021      	strb	r1, [r4, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80053cc:	6813      	ldr	r3, [r2, #0]
 80053ce:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80053d2:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80053d4:	6813      	ldr	r3, [r2, #0]
 80053d6:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 80053da:	6013      	str	r3, [r2, #0]
	vPortSetupTimerInterrupt();
 80053dc:	f7ff ff80 	bl	80052e0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 80053e0:	4b10      	ldr	r3, [pc, #64]	; (8005424 <xPortStartScheduler+0x108>)
 80053e2:	2400      	movs	r4, #0
 80053e4:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
 80053e6:	f7ff fec5 	bl	8005174 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 80053ea:	4a0f      	ldr	r2, [pc, #60]	; (8005428 <xPortStartScheduler+0x10c>)
 80053ec:	6813      	ldr	r3, [r2, #0]
 80053ee:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 80053f2:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 80053f4:	f7ff feaa 	bl	800514c <prvPortStartFirstTask>
	vTaskSwitchContext();
 80053f8:	f7ff fe4a 	bl	8005090 <vTaskSwitchContext>
	prvTaskExitError();
 80053fc:	f7ff fe86 	bl	800510c <prvTaskExitError>
}
 8005400:	4620      	mov	r0, r4
 8005402:	b002      	add	sp, #8
 8005404:	bd10      	pop	{r4, pc}
 8005406:	bf00      	nop
 8005408:	e000ed00 	.word	0xe000ed00
 800540c:	410fc271 	.word	0x410fc271
 8005410:	410fc270 	.word	0x410fc270
 8005414:	e000e400 	.word	0xe000e400
 8005418:	2000020c 	.word	0x2000020c
 800541c:	20000208 	.word	0x20000208
 8005420:	e000ed20 	.word	0xe000ed20
 8005424:	20000004 	.word	0x20000004
 8005428:	e000ef34 	.word	0xe000ef34

0800542c <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 800542c:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800542e:	4b11      	ldr	r3, [pc, #68]	; (8005474 <prvInsertBlockIntoFreeList+0x48>)
 8005430:	681a      	ldr	r2, [r3, #0]
 8005432:	4282      	cmp	r2, r0
 8005434:	d201      	bcs.n	800543a <prvInsertBlockIntoFreeList+0xe>
 8005436:	4613      	mov	r3, r2
 8005438:	e7fa      	b.n	8005430 <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800543a:	685c      	ldr	r4, [r3, #4]
 800543c:	1919      	adds	r1, r3, r4
 800543e:	4288      	cmp	r0, r1
 8005440:	d103      	bne.n	800544a <prvInsertBlockIntoFreeList+0x1e>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8005442:	6841      	ldr	r1, [r0, #4]
 8005444:	4421      	add	r1, r4
 8005446:	6059      	str	r1, [r3, #4]
 8005448:	4618      	mov	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800544a:	6844      	ldr	r4, [r0, #4]
 800544c:	1901      	adds	r1, r0, r4
 800544e:	428a      	cmp	r2, r1
 8005450:	d109      	bne.n	8005466 <prvInsertBlockIntoFreeList+0x3a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8005452:	4909      	ldr	r1, [pc, #36]	; (8005478 <prvInsertBlockIntoFreeList+0x4c>)
 8005454:	6809      	ldr	r1, [r1, #0]
 8005456:	428a      	cmp	r2, r1
 8005458:	d005      	beq.n	8005466 <prvInsertBlockIntoFreeList+0x3a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800545a:	e9d2 2100 	ldrd	r2, r1, [r2]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800545e:	4421      	add	r1, r4
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8005460:	6002      	str	r2, [r0, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8005462:	6041      	str	r1, [r0, #4]
 8005464:	e000      	b.n	8005468 <prvInsertBlockIntoFreeList+0x3c>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8005466:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8005468:	4298      	cmp	r0, r3
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800546a:	bf18      	it	ne
 800546c:	6018      	strne	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800546e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005472:	4770      	bx	lr
 8005474:	20003e20 	.word	0x20003e20
 8005478:	20000210 	.word	0x20000210

0800547c <pvPortMalloc>:
{
 800547c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxEnd == NULL )
 800547e:	4d3e      	ldr	r5, [pc, #248]	; (8005578 <pvPortMalloc+0xfc>)
{
 8005480:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8005482:	f7ff fca3 	bl	8004dcc <vTaskSuspendAll>
		if( pxEnd == NULL )
 8005486:	682a      	ldr	r2, [r5, #0]
 8005488:	2a00      	cmp	r2, #0
 800548a:	d056      	beq.n	800553a <pvPortMalloc+0xbe>
 800548c:	4b3b      	ldr	r3, [pc, #236]	; (800557c <pvPortMalloc+0x100>)
 800548e:	681d      	ldr	r5, [r3, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8005490:	422c      	tst	r4, r5
 8005492:	d14d      	bne.n	8005530 <pvPortMalloc+0xb4>
			if( xWantedSize > 0 )
 8005494:	2c00      	cmp	r4, #0
 8005496:	d04b      	beq.n	8005530 <pvPortMalloc+0xb4>
				xWantedSize += xHeapStructSize;
 8005498:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800549c:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800549e:	bf1c      	itt	ne
 80054a0:	f023 0307 	bicne.w	r3, r3, #7
 80054a4:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 80054a6:	2b00      	cmp	r3, #0
 80054a8:	d042      	beq.n	8005530 <pvPortMalloc+0xb4>
 80054aa:	4f35      	ldr	r7, [pc, #212]	; (8005580 <pvPortMalloc+0x104>)
 80054ac:	683e      	ldr	r6, [r7, #0]
 80054ae:	429e      	cmp	r6, r3
 80054b0:	d33e      	bcc.n	8005530 <pvPortMalloc+0xb4>
				pxBlock = xStart.pxNextFreeBlock;
 80054b2:	4834      	ldr	r0, [pc, #208]	; (8005584 <pvPortMalloc+0x108>)
 80054b4:	6804      	ldr	r4, [r0, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80054b6:	e006      	b.n	80054c6 <pvPortMalloc+0x4a>
 80054b8:	f8d4 c000 	ldr.w	ip, [r4]
 80054bc:	f1bc 0f00 	cmp.w	ip, #0
 80054c0:	d004      	beq.n	80054cc <pvPortMalloc+0x50>
 80054c2:	4620      	mov	r0, r4
 80054c4:	4664      	mov	r4, ip
 80054c6:	6861      	ldr	r1, [r4, #4]
 80054c8:	4299      	cmp	r1, r3
 80054ca:	d3f5      	bcc.n	80054b8 <pvPortMalloc+0x3c>
				if( pxBlock != pxEnd )
 80054cc:	4294      	cmp	r4, r2
 80054ce:	d02f      	beq.n	8005530 <pvPortMalloc+0xb4>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80054d0:	6822      	ldr	r2, [r4, #0]
 80054d2:	6002      	str	r2, [r0, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80054d4:	1aca      	subs	r2, r1, r3
 80054d6:	2a10      	cmp	r2, #16
 80054d8:	d910      	bls.n	80054fc <pvPortMalloc+0x80>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80054da:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80054dc:	0741      	lsls	r1, r0, #29
 80054de:	d008      	beq.n	80054f2 <pvPortMalloc+0x76>
 80054e0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80054e4:	f383 8811 	msr	BASEPRI, r3
 80054e8:	f3bf 8f6f 	isb	sy
 80054ec:	f3bf 8f4f 	dsb	sy
 80054f0:	e7fe      	b.n	80054f0 <pvPortMalloc+0x74>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80054f2:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 80054f4:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 80054f6:	f7ff ff99 	bl	800542c <prvInsertBlockIntoFreeList>
 80054fa:	6861      	ldr	r1, [r4, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80054fc:	4a22      	ldr	r2, [pc, #136]	; (8005588 <pvPortMalloc+0x10c>)
 80054fe:	6810      	ldr	r0, [r2, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8005500:	1a76      	subs	r6, r6, r1
					pxBlock->pxNextFreeBlock = NULL;
 8005502:	2300      	movs	r3, #0
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8005504:	4329      	orrs	r1, r5
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8005506:	4286      	cmp	r6, r0
					pxBlock->pxNextFreeBlock = NULL;
 8005508:	e9c4 3100 	strd	r3, r1, [r4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800550c:	f104 0408 	add.w	r4, r4, #8
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8005510:	bf38      	it	cc
 8005512:	6016      	strcc	r6, [r2, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8005514:	603e      	str	r6, [r7, #0]
	( void ) xTaskResumeAll();
 8005516:	f7ff fd0d 	bl	8004f34 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800551a:	0763      	lsls	r3, r4, #29
 800551c:	d00b      	beq.n	8005536 <pvPortMalloc+0xba>
 800551e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005522:	f383 8811 	msr	BASEPRI, r3
 8005526:	f3bf 8f6f 	isb	sy
 800552a:	f3bf 8f4f 	dsb	sy
 800552e:	e7fe      	b.n	800552e <pvPortMalloc+0xb2>
	( void ) xTaskResumeAll();
 8005530:	f7ff fd00 	bl	8004f34 <xTaskResumeAll>
 8005534:	2400      	movs	r4, #0
}
 8005536:	4620      	mov	r0, r4
 8005538:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uxAddress = ( size_t ) ucHeap;
 800553a:	4b14      	ldr	r3, [pc, #80]	; (800558c <pvPortMalloc+0x110>)
	uxAddress -= xHeapStructSize;
 800553c:	4a14      	ldr	r2, [pc, #80]	; (8005590 <pvPortMalloc+0x114>)
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800553e:	4911      	ldr	r1, [pc, #68]	; (8005584 <pvPortMalloc+0x108>)
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005540:	4f11      	ldr	r7, [pc, #68]	; (8005588 <pvPortMalloc+0x10c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8005542:	075e      	lsls	r6, r3, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8005544:	bf18      	it	ne
 8005546:	3307      	addne	r3, #7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005548:	f022 0207 	bic.w	r2, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800554c:	bf18      	it	ne
 800554e:	f023 0307 	bicne.w	r3, r3, #7
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005552:	4e0b      	ldr	r6, [pc, #44]	; (8005580 <pvPortMalloc+0x104>)
	pxEnd = ( void * ) uxAddress;
 8005554:	602a      	str	r2, [r5, #0]
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8005556:	4618      	mov	r0, r3
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8005558:	1ad3      	subs	r3, r2, r3
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800555a:	4d08      	ldr	r5, [pc, #32]	; (800557c <pvPortMalloc+0x100>)
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800555c:	6033      	str	r3, [r6, #0]
	xStart.xBlockSize = ( size_t ) 0;
 800555e:	2600      	movs	r6, #0
 8005560:	e9c1 0600 	strd	r0, r6, [r1]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8005564:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
	pxEnd->pxNextFreeBlock = NULL;
 8005568:	e9c2 6600 	strd	r6, r6, [r2]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800556c:	6029      	str	r1, [r5, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800556e:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8005570:	e9c0 2300 	strd	r2, r3, [r0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8005574:	460d      	mov	r5, r1
 8005576:	e78b      	b.n	8005490 <pvPortMalloc+0x14>
 8005578:	20000210 	.word	0x20000210
 800557c:	20003e14 	.word	0x20003e14
 8005580:	20003e18 	.word	0x20003e18
 8005584:	20003e20 	.word	0x20003e20
 8005588:	20003e1c 	.word	0x20003e1c
 800558c:	20000214 	.word	0x20000214
 8005590:	20003e0c 	.word	0x20003e0c

08005594 <vPortFree>:
	if( pv != NULL )
 8005594:	b1d0      	cbz	r0, 80055cc <vPortFree+0x38>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8005596:	4a19      	ldr	r2, [pc, #100]	; (80055fc <vPortFree+0x68>)
 8005598:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800559c:	6812      	ldr	r2, [r2, #0]
 800559e:	4213      	tst	r3, r2
 80055a0:	d108      	bne.n	80055b4 <vPortFree+0x20>
 80055a2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80055a6:	f383 8811 	msr	BASEPRI, r3
 80055aa:	f3bf 8f6f 	isb	sy
 80055ae:	f3bf 8f4f 	dsb	sy
 80055b2:	e7fe      	b.n	80055b2 <vPortFree+0x1e>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 80055b4:	f850 1c08 	ldr.w	r1, [r0, #-8]
 80055b8:	b149      	cbz	r1, 80055ce <vPortFree+0x3a>
 80055ba:	f04f 0350 	mov.w	r3, #80	; 0x50
 80055be:	f383 8811 	msr	BASEPRI, r3
 80055c2:	f3bf 8f6f 	isb	sy
 80055c6:	f3bf 8f4f 	dsb	sy
 80055ca:	e7fe      	b.n	80055ca <vPortFree+0x36>
 80055cc:	4770      	bx	lr
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80055ce:	ea23 0302 	bic.w	r3, r3, r2
{
 80055d2:	b510      	push	{r4, lr}
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80055d4:	f840 3c04 	str.w	r3, [r0, #-4]
 80055d8:	4604      	mov	r4, r0
				vTaskSuspendAll();
 80055da:	f7ff fbf7 	bl	8004dcc <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 80055de:	4a08      	ldr	r2, [pc, #32]	; (8005600 <vPortFree+0x6c>)
 80055e0:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80055e4:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80055e6:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 80055ea:	440b      	add	r3, r1
 80055ec:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80055ee:	f7ff ff1d 	bl	800542c <prvInsertBlockIntoFreeList>
}
 80055f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 80055f6:	f7ff bc9d 	b.w	8004f34 <xTaskResumeAll>
 80055fa:	bf00      	nop
 80055fc:	20003e14 	.word	0x20003e14
 8005600:	20003e18 	.word	0x20003e18

08005604 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
 8005604:	b508      	push	{r3, lr}
  /*## FatFS: Link the USER driver ###########################*/
  retUSER = FATFS_LinkDriver(&USER_Driver, USERPath);
 8005606:	4903      	ldr	r1, [pc, #12]	; (8005614 <MX_FATFS_Init+0x10>)
 8005608:	4803      	ldr	r0, [pc, #12]	; (8005618 <MX_FATFS_Init+0x14>)
 800560a:	f7ff f82d 	bl	8004668 <FATFS_LinkDriver>
 800560e:	4b03      	ldr	r3, [pc, #12]	; (800561c <MX_FATFS_Init+0x18>)
 8005610:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */     
  /* USER CODE END Init */
}
 8005612:	bd08      	pop	{r3, pc}
 8005614:	20008ad4 	.word	0x20008ad4
 8005618:	20000010 	.word	0x20000010
 800561c:	20008ad8 	.word	0x20008ad8

08005620 <get_fattime>:
DWORD get_fattime(void)
{
  /* USER CODE BEGIN get_fattime */
  return 0;
  /* USER CODE END get_fattime */  
}
 8005620:	2000      	movs	r0, #0
 8005622:	4770      	bx	lr

08005624 <vApplicationGetIdleTaskMemory>:
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];
  
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
 8005624:	4b04      	ldr	r3, [pc, #16]	; (8005638 <vApplicationGetIdleTaskMemory+0x14>)
 8005626:	6003      	str	r3, [r0, #0]
{
 8005628:	b410      	push	{r4}
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 800562a:	2380      	movs	r3, #128	; 0x80
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
 800562c:	4c03      	ldr	r4, [pc, #12]	; (800563c <vApplicationGetIdleTaskMemory+0x18>)
 800562e:	600c      	str	r4, [r1, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 8005630:	6013      	str	r3, [r2, #0]
  /* place for user code */
}                   
 8005632:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005636:	4770      	bx	lr
 8005638:	20004028 	.word	0x20004028
 800563c:	20003e28 	.word	0x20003e28

08005640 <StartMainTask>:
  * @param  argument: Not used 
  * @retval None
  */
/* USER CODE END Header_StartMainTask */
void StartMainTask(void const * argument)
{
 8005640:	b508      	push	{r3, lr}
  /* init code for FATFS */
  MX_FATFS_Init();
 8005642:	f7ff ffdf 	bl	8005604 <MX_FATFS_Init>

  /* USER CODE BEGIN 5 */
#if (REFRESH_MODE==2)

#if (USE_SD_CARD)
  FATFS_UnLinkDriver(USERPath);
 8005646:	4807      	ldr	r0, [pc, #28]	; (8005664 <StartMainTask+0x24>)
 8005648:	f7ff f832 	bl	80046b0 <FATFS_UnLinkDriver>
  FATFS_LinkDriver(&USER_Driver, USERPath);
 800564c:	4905      	ldr	r1, [pc, #20]	; (8005664 <StartMainTask+0x24>)
 800564e:	4806      	ldr	r0, [pc, #24]	; (8005668 <StartMainTask+0x28>)
 8005650:	f7ff f80a 	bl	8004668 <FATFS_LinkDriver>
#endif

  setup();
 8005654:	f7fb fcd6 	bl	8001004 <setup>
  /* Infinite loop */
  for(;;)
  {
	loop();
 8005658:	f7fb fcdc 	bl	8001014 <loop>
    osDelay(1);
 800565c:	2001      	movs	r0, #1
 800565e:	f7ff f873 	bl	8004748 <osDelay>
 8005662:	e7f9      	b.n	8005658 <StartMainTask+0x18>
 8005664:	20008ad4 	.word	0x20008ad4
 8005668:	20000010 	.word	0x20000010

0800566c <StartRefreshTask>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartRefreshTask */
void StartRefreshTask(void const * argument)
{
 800566c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN StartRefreshTask */
#if (REFRESH_MODE==2)
  /* Infinite loop */
  for(;;)
  {
	refreshDisplay();
 800566e:	f000 ff4d 	bl	800650c <refreshDisplay>
    osDelay(1000/REFRESH_RATE);
 8005672:	2008      	movs	r0, #8
 8005674:	f7ff f868 	bl	8004748 <osDelay>
 8005678:	e7f9      	b.n	800566e <StartRefreshTask+0x2>
 800567a:	bf00      	nop

0800567c <SystemClock_Config>:
{
 800567c:	b570      	push	{r4, r5, r6, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800567e:	2400      	movs	r4, #0
{
 8005680:	b094      	sub	sp, #80	; 0x50
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8005682:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
 8005686:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800568a:	e9cd 4404 	strd	r4, r4, [sp, #16]
 800568e:	e9cd 4406 	strd	r4, r4, [sp, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 8005692:	4a1d      	ldr	r2, [pc, #116]	; (8005708 <SystemClock_Config+0x8c>)
 8005694:	9401      	str	r4, [sp, #4]
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8005696:	9403      	str	r4, [sp, #12]
  __HAL_RCC_PWR_CLK_ENABLE();
 8005698:	6c11      	ldr	r1, [r2, #64]	; 0x40
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800569a:	4b1c      	ldr	r3, [pc, #112]	; (800570c <SystemClock_Config+0x90>)
  __HAL_RCC_PWR_CLK_ENABLE();
 800569c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80056a0:	6411      	str	r1, [r2, #64]	; 0x40
 80056a2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80056a4:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 80056a8:	9201      	str	r2, [sp, #4]
 80056aa:	9a01      	ldr	r2, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80056ac:	9402      	str	r4, [sp, #8]
 80056ae:	681a      	ldr	r2, [r3, #0]
 80056b0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80056b4:	601a      	str	r2, [r3, #0]
 80056b6:	681b      	ldr	r3, [r3, #0]
 80056b8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80056bc:	9302      	str	r3, [sp, #8]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80056be:	2101      	movs	r1, #1
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80056c0:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80056c4:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80056c8:	2502      	movs	r5, #2
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80056ca:	9802      	ldr	r0, [sp, #8]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80056cc:	9108      	str	r1, [sp, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80056ce:	9209      	str	r2, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLM = 8;
 80056d0:	2108      	movs	r1, #8
  RCC_OscInitStruct.PLL.PLLN = 168;
 80056d2:	22a8      	movs	r2, #168	; 0xa8
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80056d4:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80056d6:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLQ = 4;
 80056d8:	2304      	movs	r3, #4
  RCC_OscInitStruct.PLL.PLLM = 8;
 80056da:	9110      	str	r1, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 168;
 80056dc:	9211      	str	r2, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLQ = 4;
 80056de:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80056e0:	950e      	str	r5, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80056e2:	9512      	str	r5, [sp, #72]	; 0x48
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80056e4:	260f      	movs	r6, #15
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80056e6:	f7fa ffc5 	bl	8000674 <HAL_RCC_OscConfig>
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80056ea:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80056ee:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 80056f2:	a803      	add	r0, sp, #12
 80056f4:	2105      	movs	r1, #5
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80056f6:	9504      	str	r5, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80056f8:	9405      	str	r4, [sp, #20]
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80056fa:	9603      	str	r6, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80056fc:	e9cd 2306 	strd	r2, r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8005700:	f7fb f9a2 	bl	8000a48 <HAL_RCC_ClockConfig>
}
 8005704:	b014      	add	sp, #80	; 0x50
 8005706:	bd70      	pop	{r4, r5, r6, pc}
 8005708:	40023800 	.word	0x40023800
 800570c:	40007000 	.word	0x40007000

08005710 <main>:
{
 8005710:	b580      	push	{r7, lr}
 8005712:	b090      	sub	sp, #64	; 0x40
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8005714:	2500      	movs	r5, #0
  HAL_Init();
 8005716:	f7fa ff2b 	bl	8000570 <HAL_Init>
  SystemClock_Config();
 800571a:	f7ff ffaf 	bl	800567c <SystemClock_Config>
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800571e:	4b27      	ldr	r3, [pc, #156]	; (80057bc <main+0xac>)
 8005720:	9501      	str	r5, [sp, #4]
 8005722:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  htim2.Instance = TIM2;
 8005724:	4e26      	ldr	r6, [pc, #152]	; (80057c0 <main+0xb0>)
  osThreadDef(mainTask, StartMainTask, osPriorityBelowNormal, 0, 2000);
 8005726:	4c27      	ldr	r4, [pc, #156]	; (80057c4 <main+0xb4>)
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8005728:	60b5      	str	r5, [r6, #8]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800572a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800572e:	631a      	str	r2, [r3, #48]	; 0x30
 8005730:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8005732:	6135      	str	r5, [r6, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8005734:	f003 0380 	and.w	r3, r3, #128	; 0x80
  htim2.Init.Period = 1000;
 8005738:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800573c:	9301      	str	r3, [sp, #4]
  htim2.Init.Prescaler = 84;
 800573e:	2154      	movs	r1, #84	; 0x54
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8005740:	2380      	movs	r3, #128	; 0x80
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 8005742:	4630      	mov	r0, r6
  htim2.Instance = TIM2;
 8005744:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8005748:	f8dd c004 	ldr.w	ip, [sp, #4]
  htim2.Init.Period = 1000;
 800574c:	60f2      	str	r2, [r6, #12]
  htim2.Init.Prescaler = 84;
 800574e:	e9c6 7100 	strd	r7, r1, [r6]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8005752:	61b3      	str	r3, [r6, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8005754:	9509      	str	r5, [sp, #36]	; 0x24
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8005756:	9502      	str	r5, [sp, #8]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8005758:	e9cd 550a 	strd	r5, r5, [sp, #40]	; 0x28
 800575c:	950c      	str	r5, [sp, #48]	; 0x30
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800575e:	9503      	str	r5, [sp, #12]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 8005760:	f7fb fa3e 	bl	8000be0 <HAL_TIM_Base_Init>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8005764:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8005768:	a909      	add	r1, sp, #36	; 0x24
 800576a:	4630      	mov	r0, r6
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800576c:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 800576e:	f7fb facb 	bl	8000d08 <HAL_TIM_ConfigClockSource>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8005772:	4630      	mov	r0, r6
 8005774:	a902      	add	r1, sp, #8
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005776:	e9cd 5502 	strd	r5, r5, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 800577a:	f7fb fc1d 	bl	8000fb8 <HAL_TIMEx_MasterConfigSynchronization>
  osThreadDef(mainTask, StartMainTask, osPriorityBelowNormal, 0, 2000);
 800577e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005780:	ae02      	add	r6, sp, #8
 8005782:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8005784:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8005788:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  mainTaskHandle = osThreadCreate(osThread(mainTask), NULL);
 800578c:	4629      	mov	r1, r5
 800578e:	a802      	add	r0, sp, #8
 8005790:	f7fe ffb0 	bl	80046f4 <osThreadCreate>
 8005794:	4b0c      	ldr	r3, [pc, #48]	; (80057c8 <main+0xb8>)
  osThreadDef(refreshTask, StartRefreshTask, osPriorityNormal, 0, 128);
 8005796:	340c      	adds	r4, #12
  mainTaskHandle = osThreadCreate(osThread(mainTask), NULL);
 8005798:	6018      	str	r0, [r3, #0]
  osThreadDef(refreshTask, StartRefreshTask, osPriorityNormal, 0, 128);
 800579a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800579c:	ae09      	add	r6, sp, #36	; 0x24
 800579e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80057a0:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 80057a4:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  refreshTaskHandle = osThreadCreate(osThread(refreshTask), NULL);
 80057a8:	4629      	mov	r1, r5
 80057aa:	a809      	add	r0, sp, #36	; 0x24
 80057ac:	f7fe ffa2 	bl	80046f4 <osThreadCreate>
 80057b0:	4b06      	ldr	r3, [pc, #24]	; (80057cc <main+0xbc>)
 80057b2:	6018      	str	r0, [r3, #0]
  osKernelStart();
 80057b4:	f7fe ff98 	bl	80046e8 <osKernelStart>
 80057b8:	e7fe      	b.n	80057b8 <main+0xa8>
 80057ba:	bf00      	nop
 80057bc:	40023800 	.word	0x40023800
 80057c0:	20008f48 	.word	0x20008f48
 80057c4:	08007c84 	.word	0x08007c84
 80057c8:	20008f3c 	.word	0x20008f3c
 80057cc:	20008f40 	.word	0x20008f40

080057d0 <HAL_TIM_PeriodElapsedCallback>:
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */
#if (REFRESH_MODE==2)
  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 80057d0:	6802      	ldr	r2, [r0, #0]
 80057d2:	4b03      	ldr	r3, [pc, #12]	; (80057e0 <HAL_TIM_PeriodElapsedCallback+0x10>)
 80057d4:	429a      	cmp	r2, r3
 80057d6:	d000      	beq.n	80057da <HAL_TIM_PeriodElapsedCallback+0xa>
		refreshDisplay();
		HAL_TIM_Base_Start_IT(&htim2);
	}
#endif
  /* USER CODE END Callback 1 */
}
 80057d8:	4770      	bx	lr
    HAL_IncTick();
 80057da:	f7fa bee3 	b.w	80005a4 <HAL_IncTick>
 80057de:	bf00      	nop
 80057e0:	40010000 	.word	0x40010000

080057e4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80057e4:	b082      	sub	sp, #8
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80057e6:	4b0e      	ldr	r3, [pc, #56]	; (8005820 <HAL_MspInit+0x3c>)
 80057e8:	2200      	movs	r2, #0
 80057ea:	9200      	str	r2, [sp, #0]
 80057ec:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80057ee:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 80057f2:	6459      	str	r1, [r3, #68]	; 0x44
 80057f4:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80057f6:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
 80057fa:	9100      	str	r1, [sp, #0]
 80057fc:	9900      	ldr	r1, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80057fe:	9201      	str	r2, [sp, #4]
 8005800:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8005802:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8005806:	6419      	str	r1, [r3, #64]	; 0x40
 8005808:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800580a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800580e:	9301      	str	r3, [sp, #4]
 8005810:	9b01      	ldr	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8005812:	210f      	movs	r1, #15
 8005814:	f06f 0001 	mvn.w	r0, #1

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8005818:	b002      	add	sp, #8
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 800581a:	f7fa bee7 	b.w	80005ec <HAL_NVIC_SetPriority>
 800581e:	bf00      	nop
 8005820:	40023800 	.word	0x40023800

08005824 <HAL_TIM_Base_MspInit>:
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM2)
 8005824:	6803      	ldr	r3, [r0, #0]
 8005826:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800582a:	d000      	beq.n	800582e <HAL_TIM_Base_MspInit+0xa>
 800582c:	4770      	bx	lr
{
 800582e:	b500      	push	{lr}
 8005830:	b083      	sub	sp, #12
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 8005832:	2200      	movs	r2, #0
 8005834:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
 8005838:	9201      	str	r2, [sp, #4]
 800583a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800583c:	f041 0101 	orr.w	r1, r1, #1
 8005840:	6419      	str	r1, [r3, #64]	; 0x40
 8005842:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005844:	f003 0301 	and.w	r3, r3, #1
 8005848:	9301      	str	r3, [sp, #4]
    /* TIM2 interrupt Init */
    HAL_NVIC_SetPriority(TIM2_IRQn, 5, 0);
 800584a:	2105      	movs	r1, #5
 800584c:	201c      	movs	r0, #28
    __HAL_RCC_TIM2_CLK_ENABLE();
 800584e:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM2_IRQn, 5, 0);
 8005850:	f7fa fecc 	bl	80005ec <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8005854:	201c      	movs	r0, #28
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }

}
 8005856:	b003      	add	sp, #12
 8005858:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 800585c:	f7fa befc 	b.w	8000658 <HAL_NVIC_EnableIRQ>

08005860 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8005860:	b530      	push	{r4, r5, lr}
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, TickPriority ,0); 
 8005862:	4601      	mov	r1, r0
{
 8005864:	b089      	sub	sp, #36	; 0x24
  HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, TickPriority ,0); 
 8005866:	2200      	movs	r2, #0
 8005868:	2019      	movs	r0, #25
 800586a:	f7fa febf 	bl	80005ec <HAL_NVIC_SetPriority>
  
  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn); 
 800586e:	2019      	movs	r0, #25
 8005870:	f7fa fef2 	bl	8000658 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 8005874:	2500      	movs	r5, #0
 8005876:	4b16      	ldr	r3, [pc, #88]	; (80058d0 <HAL_InitTick+0x70>)
 8005878:	9502      	str	r5, [sp, #8]
 800587a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
  
  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 800587c:	4c15      	ldr	r4, [pc, #84]	; (80058d4 <HAL_InitTick+0x74>)
  __HAL_RCC_TIM1_CLK_ENABLE();
 800587e:	f042 0201 	orr.w	r2, r2, #1
 8005882:	645a      	str	r2, [r3, #68]	; 0x44
 8005884:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8005886:	f003 0301 	and.w	r3, r3, #1
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800588a:	a901      	add	r1, sp, #4
  __HAL_RCC_TIM1_CLK_ENABLE();
 800588c:	9302      	str	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800588e:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM1_CLK_ENABLE();
 8005890:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8005892:	f7fb f983 	bl	8000b9c <HAL_RCC_GetClockConfig>
  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 8005896:	f7fb f971 	bl	8000b7c <HAL_RCC_GetPCLK2Freq>
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800589a:	4a0f      	ldr	r2, [pc, #60]	; (80058d8 <HAL_InitTick+0x78>)
  htim1.Instance = TIM1;
 800589c:	490f      	ldr	r1, [pc, #60]	; (80058dc <HAL_InitTick+0x7c>)
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000 / 1000) - 1;
  htim1.Init.Prescaler = uwPrescalerValue;
  htim1.Init.ClockDivision = 0;
 800589e:	6125      	str	r5, [r4, #16]
  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 80058a0:	0043      	lsls	r3, r0, #1
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 80058a2:	fba2 2303 	umull	r2, r3, r2, r3
 80058a6:	0c9b      	lsrs	r3, r3, #18
 80058a8:	3b01      	subs	r3, #1
  htim1.Init.Period = (1000000 / 1000) - 1;
 80058aa:	f240 32e7 	movw	r2, #999	; 0x3e7
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 80058ae:	4620      	mov	r0, r4
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 80058b0:	e9c4 3501 	strd	r3, r5, [r4, #4]
  htim1.Instance = TIM1;
 80058b4:	6021      	str	r1, [r4, #0]
  htim1.Init.Period = (1000000 / 1000) - 1;
 80058b6:	60e2      	str	r2, [r4, #12]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 80058b8:	f7fb f992 	bl	8000be0 <HAL_TIM_Base_Init>
 80058bc:	b110      	cbz	r0, 80058c4 <HAL_InitTick+0x64>
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
  }
  
  /* Return function status */
  return HAL_ERROR;
 80058be:	2001      	movs	r0, #1
}
 80058c0:	b009      	add	sp, #36	; 0x24
 80058c2:	bd30      	pop	{r4, r5, pc}
    return HAL_TIM_Base_Start_IT(&htim1);
 80058c4:	4620      	mov	r0, r4
 80058c6:	f7fb fa0f 	bl	8000ce8 <HAL_TIM_Base_Start_IT>
}
 80058ca:	b009      	add	sp, #36	; 0x24
 80058cc:	bd30      	pop	{r4, r5, pc}
 80058ce:	bf00      	nop
 80058d0:	40023800 	.word	0x40023800
 80058d4:	20008f88 	.word	0x20008f88
 80058d8:	431bde83 	.word	0x431bde83
 80058dc:	40010000 	.word	0x40010000

080058e0 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 80058e0:	4770      	bx	lr
 80058e2:	bf00      	nop

080058e4 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80058e4:	e7fe      	b.n	80058e4 <HardFault_Handler>
 80058e6:	bf00      	nop

080058e8 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 80058e8:	e7fe      	b.n	80058e8 <MemManage_Handler>
 80058ea:	bf00      	nop

080058ec <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 80058ec:	e7fe      	b.n	80058ec <BusFault_Handler>
 80058ee:	bf00      	nop

080058f0 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80058f0:	e7fe      	b.n	80058f0 <UsageFault_Handler>
 80058f2:	bf00      	nop

080058f4 <DebugMon_Handler>:
 80058f4:	4770      	bx	lr
 80058f6:	bf00      	nop

080058f8 <TIM1_UP_TIM10_IRQHandler>:
void TIM1_UP_TIM10_IRQHandler(void)
{
  /* USER CODE BEGIN TIM1_UP_TIM10_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM10_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 80058f8:	4801      	ldr	r0, [pc, #4]	; (8005900 <TIM1_UP_TIM10_IRQHandler+0x8>)
 80058fa:	f7fb bab3 	b.w	8000e64 <HAL_TIM_IRQHandler>
 80058fe:	bf00      	nop
 8005900:	20008f88 	.word	0x20008f88

08005904 <TIM2_IRQHandler>:
void TIM2_IRQHandler(void)
{
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 8005904:	4801      	ldr	r0, [pc, #4]	; (800590c <TIM2_IRQHandler+0x8>)
 8005906:	f7fb baad 	b.w	8000e64 <HAL_TIM_IRQHandler>
 800590a:	bf00      	nop
 800590c:	20008f48 	.word	0x20008f48

08005910 <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 8005910:	4a0c      	ldr	r2, [pc, #48]	; (8005944 <_sbrk+0x34>)
{
 8005912:	b508      	push	{r3, lr}
	if (heap_end == 0)
 8005914:	6813      	ldr	r3, [r2, #0]
 8005916:	b133      	cbz	r3, 8005926 <_sbrk+0x16>
		heap_end = &end;

	prev_heap_end = heap_end;
	if (heap_end + incr > stack_ptr)
 8005918:	4418      	add	r0, r3
 800591a:	4669      	mov	r1, sp
 800591c:	4288      	cmp	r0, r1
 800591e:	d808      	bhi.n	8005932 <_sbrk+0x22>
	{
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 8005920:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 8005922:	4618      	mov	r0, r3
 8005924:	bd08      	pop	{r3, pc}
		heap_end = &end;
 8005926:	4b08      	ldr	r3, [pc, #32]	; (8005948 <_sbrk+0x38>)
 8005928:	6013      	str	r3, [r2, #0]
	if (heap_end + incr > stack_ptr)
 800592a:	4418      	add	r0, r3
 800592c:	4669      	mov	r1, sp
 800592e:	4288      	cmp	r0, r1
 8005930:	d9f6      	bls.n	8005920 <_sbrk+0x10>
		errno = ENOMEM;
 8005932:	f001 fd5f 	bl	80073f4 <__errno>
 8005936:	230c      	movs	r3, #12
 8005938:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 800593a:	f04f 33ff 	mov.w	r3, #4294967295
}
 800593e:	4618      	mov	r0, r3
 8005940:	bd08      	pop	{r3, pc}
 8005942:	bf00      	nop
 8005944:	2000407c 	.word	0x2000407c
 8005948:	20008fd0 	.word	0x20008fd0

0800594c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800594c:	4910      	ldr	r1, [pc, #64]	; (8005990 <SystemInit+0x44>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800594e:	4b11      	ldr	r3, [pc, #68]	; (8005994 <SystemInit+0x48>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8005950:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8005954:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
{
 8005958:	b410      	push	{r4}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800595a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  RCC->CR |= (uint32_t)0x00000001;
 800595e:	681a      	ldr	r2, [r3, #0]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8005960:	4c0d      	ldr	r4, [pc, #52]	; (8005998 <SystemInit+0x4c>)
  RCC->CFGR = 0x00000000;
 8005962:	2000      	movs	r0, #0
  RCC->CR |= (uint32_t)0x00000001;
 8005964:	f042 0201 	orr.w	r2, r2, #1
 8005968:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 800596a:	6098      	str	r0, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800596c:	681a      	ldr	r2, [r3, #0]
 800596e:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8005972:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8005976:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 8005978:	605c      	str	r4, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800597a:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800597c:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8005980:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8005984:	601a      	str	r2, [r3, #0]
  RCC->CIR = 0x00000000;
 8005986:	60d8      	str	r0, [r3, #12]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8005988:	608c      	str	r4, [r1, #8]
#endif
}
 800598a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800598e:	4770      	bx	lr
 8005990:	e000ed00 	.word	0xe000ed00
 8005994:	40023800 	.word	0x40023800
 8005998:	24003010 	.word	0x24003010

0800599c <USER_status>:
DSTATUS USER_status (
	BYTE pdrv       /* Physical drive number to identify the drive */
)
{
  /* USER CODE BEGIN STATUS */
	if (pdrv) return STA_NOINIT;		/* Supports only drive 0 */
 800599c:	b918      	cbnz	r0, 80059a6 <USER_status+0xa>

	return Stat;	/* Return disk status */
 800599e:	4b03      	ldr	r3, [pc, #12]	; (80059ac <USER_status+0x10>)
 80059a0:	7818      	ldrb	r0, [r3, #0]
 80059a2:	b2c0      	uxtb	r0, r0
 80059a4:	4770      	bx	lr
	if (pdrv) return STA_NOINIT;		/* Supports only drive 0 */
 80059a6:	2001      	movs	r0, #1
  /* USER CODE END STATUS */
}
 80059a8:	4770      	bx	lr
 80059aa:	bf00      	nop
 80059ac:	2000000c 	.word	0x2000000c

080059b0 <rcvr_datablock>:
{
 80059b0:	b470      	push	{r4, r5, r6}
	Timer1 = 200;
 80059b2:	4c2a      	ldr	r4, [pc, #168]	; (8005a5c <rcvr_datablock+0xac>)
	SPIx->DR=dat;
 80059b4:	4a2a      	ldr	r2, [pc, #168]	; (8005a60 <rcvr_datablock+0xb0>)
	Timer1 = 200;
 80059b6:	23c8      	movs	r3, #200	; 0xc8
 80059b8:	6023      	str	r3, [r4, #0]
	SPIx->DR=dat;
 80059ba:	25ff      	movs	r5, #255	; 0xff
 80059bc:	60d5      	str	r5, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80059be:	6893      	ldr	r3, [r2, #8]
 80059c0:	f003 0383 	and.w	r3, r3, #131	; 0x83
 80059c4:	2b03      	cmp	r3, #3
 80059c6:	d1fa      	bne.n	80059be <rcvr_datablock+0xe>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 80059c8:	68d3      	ldr	r3, [r2, #12]
 80059ca:	b2db      	uxtb	r3, r3
	} while ((token == 0xFF) && Timer1);
 80059cc:	2bff      	cmp	r3, #255	; 0xff
 80059ce:	d105      	bne.n	80059dc <rcvr_datablock+0x2c>
 80059d0:	6823      	ldr	r3, [r4, #0]
 80059d2:	2b00      	cmp	r3, #0
 80059d4:	d1f2      	bne.n	80059bc <rcvr_datablock+0xc>
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */
 80059d6:	2000      	movs	r0, #0
}
 80059d8:	bc70      	pop	{r4, r5, r6}
 80059da:	4770      	bx	lr
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */
 80059dc:	2bfe      	cmp	r3, #254	; 0xfe
 80059de:	d1fa      	bne.n	80059d6 <rcvr_datablock+0x26>
	SPIx->CR1|=SPI_CR1_DFF;						/* Put SPI into 16-bit mode */
 80059e0:	6813      	ldr	r3, [r2, #0]
		while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);	/* Wait for end of the SPI transaction */
 80059e2:	4c1f      	ldr	r4, [pc, #124]	; (8005a60 <rcvr_datablock+0xb0>)
	SPIx->CR1|=SPI_CR1_DFF;						/* Put SPI into 16-bit mode */
 80059e4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
	SPIx->DR=0xFFFF;							/* Start the first SPI transaction */
 80059e8:	f64f 76ff 	movw	r6, #65535	; 0xffff
	SPIx->CR1|=SPI_CR1_DFF;						/* Put SPI into 16-bit mode */
 80059ec:	6013      	str	r3, [r2, #0]
	btr -= 2;
 80059ee:	3902      	subs	r1, #2
	SPIx->DR=0xFFFF;							/* Start the first SPI transaction */
 80059f0:	60d6      	str	r6, [r2, #12]
		while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);	/* Wait for end of the SPI transaction */
 80059f2:	68a3      	ldr	r3, [r4, #8]
 80059f4:	f003 0383 	and.w	r3, r3, #131	; 0x83
 80059f8:	2b03      	cmp	r3, #3
 80059fa:	d1fa      	bne.n	80059f2 <rcvr_datablock+0x42>
		d = SPIx->DR;							/* Get received word */
 80059fc:	68e2      	ldr	r2, [r4, #12]
		SPIx->DR=0xFFFF;						/* Start next transaction */
 80059fe:	60e6      	str	r6, [r4, #12]
		buff[1] = d; buff[0] = d >> 8; 			/* Store received data */
 8005a00:	4603      	mov	r3, r0
 8005a02:	f3c2 2507 	ubfx	r5, r2, #8, #8
	} while (btr -= 2);
 8005a06:	3902      	subs	r1, #2
		buff[1] = d; buff[0] = d >> 8; 			/* Store received data */
 8005a08:	7042      	strb	r2, [r0, #1]
 8005a0a:	f803 5b02 	strb.w	r5, [r3], #2
	} while (btr -= 2);
 8005a0e:	d001      	beq.n	8005a14 <rcvr_datablock+0x64>
		buff += 2;
 8005a10:	4618      	mov	r0, r3
 8005a12:	e7ee      	b.n	80059f2 <rcvr_datablock+0x42>
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);		/* Wait for end of the SPI transaction */
 8005a14:	4a12      	ldr	r2, [pc, #72]	; (8005a60 <rcvr_datablock+0xb0>)
 8005a16:	6893      	ldr	r3, [r2, #8]
 8005a18:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005a1c:	2b03      	cmp	r3, #3
 8005a1e:	d1fa      	bne.n	8005a16 <rcvr_datablock+0x66>
	d = SPIx->DR;								/* Get last word received */
 8005a20:	68d3      	ldr	r3, [r2, #12]
	buff[1] = d; buff[0] = d >> 8;				/* Store it */
 8005a22:	70c3      	strb	r3, [r0, #3]
 8005a24:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8005a28:	7083      	strb	r3, [r0, #2]
	SPIx->CR1&=~SPI_CR1_DFF;					/* Put SPI into 8-bit mode */
 8005a2a:	6813      	ldr	r3, [r2, #0]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005a2c:	490c      	ldr	r1, [pc, #48]	; (8005a60 <rcvr_datablock+0xb0>)
	SPIx->CR1&=~SPI_CR1_DFF;					/* Put SPI into 8-bit mode */
 8005a2e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
	SPIx->DR=dat;
 8005a32:	20ff      	movs	r0, #255	; 0xff
	SPIx->CR1&=~SPI_CR1_DFF;					/* Put SPI into 8-bit mode */
 8005a34:	6013      	str	r3, [r2, #0]
	SPIx->DR=dat;
 8005a36:	60d0      	str	r0, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005a38:	688b      	ldr	r3, [r1, #8]
 8005a3a:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005a3e:	2b03      	cmp	r3, #3
 8005a40:	d1fa      	bne.n	8005a38 <rcvr_datablock+0x88>
	SPIx->DR=dat;
 8005a42:	23ff      	movs	r3, #255	; 0xff
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005a44:	4a06      	ldr	r2, [pc, #24]	; (8005a60 <rcvr_datablock+0xb0>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005a46:	68c8      	ldr	r0, [r1, #12]
	SPIx->DR=dat;
 8005a48:	60cb      	str	r3, [r1, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005a4a:	6893      	ldr	r3, [r2, #8]
 8005a4c:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005a50:	2b03      	cmp	r3, #3
 8005a52:	d1fa      	bne.n	8005a4a <rcvr_datablock+0x9a>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005a54:	2001      	movs	r0, #1
 8005a56:	68d3      	ldr	r3, [r2, #12]
}
 8005a58:	bc70      	pop	{r4, r5, r6}
 8005a5a:	4770      	bx	lr
 8005a5c:	20004084 	.word	0x20004084
 8005a60:	40003800 	.word	0x40003800

08005a64 <xmit_datablock.part.2>:
	SPIx->CR1|=SPI_CR1_DFF;						/* Put SPI into 16-bit mode */
 8005a64:	4a26      	ldr	r2, [pc, #152]	; (8005b00 <xmit_datablock.part.2+0x9c>)
int xmit_datablock (	/* 1:OK, 0:Failed */
 8005a66:	b410      	push	{r4}
	SPIx->CR1|=SPI_CR1_DFF;						/* Put SPI into 16-bit mode */
 8005a68:	6813      	ldr	r3, [r2, #0]
 8005a6a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8005a6e:	6013      	str	r3, [r2, #0]
	d = buff[0] << 8 | buff[1]; buff += 2;
 8005a70:	7801      	ldrb	r1, [r0, #0]
 8005a72:	7843      	ldrb	r3, [r0, #1]
	SPIx->DR=d;									/* Send the first word */
 8005a74:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8005a78:	60d3      	str	r3, [r2, #12]
 8005a7a:	1d01      	adds	r1, r0, #4
 8005a7c:	f200 2402 	addw	r4, r0, #514	; 0x202
		d = buff[0] << 8 | buff[1]; buff += 2;	/* Word to send next */
 8005a80:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 8005a84:	f811 0c01 	ldrb.w	r0, [r1, #-1]
 8005a88:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
		while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);	/* Wait for end of the SPI transaction */
 8005a8c:	6893      	ldr	r3, [r2, #8]
 8005a8e:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005a92:	2b03      	cmp	r3, #3
 8005a94:	d1fa      	bne.n	8005a8c <xmit_datablock.part.2+0x28>
 8005a96:	3102      	adds	r1, #2
	} while (btx -= 2);
 8005a98:	42a1      	cmp	r1, r4
		SPIx->DR;								/* Discard received word */
 8005a9a:	68d3      	ldr	r3, [r2, #12]
		SPIx->DR=d;								/* Start next transaction */
 8005a9c:	60d0      	str	r0, [r2, #12]
	} while (btx -= 2);
 8005a9e:	d1ef      	bne.n	8005a80 <xmit_datablock.part.2+0x1c>
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);		/* Wait for end of the SPI transaction */
 8005aa0:	4a17      	ldr	r2, [pc, #92]	; (8005b00 <xmit_datablock.part.2+0x9c>)
 8005aa2:	6893      	ldr	r3, [r2, #8]
 8005aa4:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005aa8:	2b03      	cmp	r3, #3
 8005aaa:	d1fa      	bne.n	8005aa2 <xmit_datablock.part.2+0x3e>
	SPIx->DR;									/* Discard received word */
 8005aac:	68d3      	ldr	r3, [r2, #12]
	SPIx->CR1&=~SPI_CR1_DFF;					/* Put SPI into 8-bit mode */
 8005aae:	6813      	ldr	r3, [r2, #0]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005ab0:	4913      	ldr	r1, [pc, #76]	; (8005b00 <xmit_datablock.part.2+0x9c>)
	SPIx->CR1&=~SPI_CR1_DFF;					/* Put SPI into 8-bit mode */
 8005ab2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
	SPIx->DR=dat;
 8005ab6:	20ff      	movs	r0, #255	; 0xff
	SPIx->CR1&=~SPI_CR1_DFF;					/* Put SPI into 8-bit mode */
 8005ab8:	6013      	str	r3, [r2, #0]
	SPIx->DR=dat;
 8005aba:	60d0      	str	r0, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005abc:	688b      	ldr	r3, [r1, #8]
 8005abe:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005ac2:	2b03      	cmp	r3, #3
 8005ac4:	d1fa      	bne.n	8005abc <xmit_datablock.part.2+0x58>
	SPIx->DR=dat;
 8005ac6:	23ff      	movs	r3, #255	; 0xff
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005ac8:	4a0d      	ldr	r2, [pc, #52]	; (8005b00 <xmit_datablock.part.2+0x9c>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005aca:	68c8      	ldr	r0, [r1, #12]
	SPIx->DR=dat;
 8005acc:	60cb      	str	r3, [r1, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005ace:	6893      	ldr	r3, [r2, #8]
 8005ad0:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005ad4:	2b03      	cmp	r3, #3
 8005ad6:	d1fa      	bne.n	8005ace <xmit_datablock.part.2+0x6a>
	SPIx->DR=dat;
 8005ad8:	23ff      	movs	r3, #255	; 0xff
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005ada:	4909      	ldr	r1, [pc, #36]	; (8005b00 <xmit_datablock.part.2+0x9c>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005adc:	68d0      	ldr	r0, [r2, #12]
	SPIx->DR=dat;
 8005ade:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005ae0:	688b      	ldr	r3, [r1, #8]
 8005ae2:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005ae6:	2b03      	cmp	r3, #3
 8005ae8:	d1fa      	bne.n	8005ae0 <xmit_datablock.part.2+0x7c>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005aea:	68c8      	ldr	r0, [r1, #12]
}
 8005aec:	f85d 4b04 	ldr.w	r4, [sp], #4
		if ((resp & 0x1F) != 0x05) return 0;	/* Function fails if the data packet was not accepted */
 8005af0:	f000 001f 	and.w	r0, r0, #31
}
 8005af4:	f1a0 0005 	sub.w	r0, r0, #5
 8005af8:	fab0 f080 	clz	r0, r0
 8005afc:	0940      	lsrs	r0, r0, #5
 8005afe:	4770      	bx	lr
 8005b00:	40003800 	.word	0x40003800

08005b04 <send_cmd>:
	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
 8005b04:	0602      	lsls	r2, r0, #24
{
 8005b06:	b538      	push	{r3, r4, r5, lr}
 8005b08:	4604      	mov	r4, r0
 8005b0a:	460d      	mov	r5, r1
	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
 8005b0c:	f100 809a 	bmi.w	8005c44 <send_cmd+0x140>
	if (cmd != CMD12) {
 8005b10:	2c0c      	cmp	r4, #12
 8005b12:	d03a      	beq.n	8005b8a <send_cmd+0x86>
	SD_CS_HIGH;									/* Set CS# high */
 8005b14:	4a50      	ldr	r2, [pc, #320]	; (8005c58 <send_cmd+0x154>)
	SPIx->DR=dat;
 8005b16:	4b51      	ldr	r3, [pc, #324]	; (8005c5c <send_cmd+0x158>)
	SD_CS_HIGH;									/* Set CS# high */
 8005b18:	2001      	movs	r0, #1
	SPIx->DR=dat;
 8005b1a:	21ff      	movs	r1, #255	; 0xff
	SD_CS_HIGH;									/* Set CS# high */
 8005b1c:	6190      	str	r0, [r2, #24]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005b1e:	461a      	mov	r2, r3
	SPIx->DR=dat;
 8005b20:	60d9      	str	r1, [r3, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005b22:	6893      	ldr	r3, [r2, #8]
 8005b24:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005b28:	2b03      	cmp	r3, #3
 8005b2a:	d1fa      	bne.n	8005b22 <send_cmd+0x1e>
	SD_CS_LOW;										/* Set CS# low */
 8005b2c:	4b4a      	ldr	r3, [pc, #296]	; (8005c58 <send_cmd+0x154>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005b2e:	68d0      	ldr	r0, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005b30:	494a      	ldr	r1, [pc, #296]	; (8005c5c <send_cmd+0x158>)
	SD_CS_LOW;										/* Set CS# low */
 8005b32:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8005b36:	6198      	str	r0, [r3, #24]
	SPIx->DR=dat;
 8005b38:	23ff      	movs	r3, #255	; 0xff
 8005b3a:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005b3c:	688b      	ldr	r3, [r1, #8]
 8005b3e:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005b42:	2b03      	cmp	r3, #3
 8005b44:	d1fa      	bne.n	8005b3c <send_cmd+0x38>
	Timer2 = wt;
 8005b46:	4846      	ldr	r0, [pc, #280]	; (8005c60 <send_cmd+0x15c>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005b48:	68cb      	ldr	r3, [r1, #12]
	SPIx->DR=dat;
 8005b4a:	4a44      	ldr	r2, [pc, #272]	; (8005c5c <send_cmd+0x158>)
	Timer2 = wt;
 8005b4c:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8005b50:	6003      	str	r3, [r0, #0]
	SPIx->DR=dat;
 8005b52:	21ff      	movs	r1, #255	; 0xff
 8005b54:	60d1      	str	r1, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005b56:	6893      	ldr	r3, [r2, #8]
 8005b58:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005b5c:	2b03      	cmp	r3, #3
 8005b5e:	d1fa      	bne.n	8005b56 <send_cmd+0x52>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005b60:	68d3      	ldr	r3, [r2, #12]
	} while (d != 0xFF && Timer2);				/* Wait for card goes ready or timeout */
 8005b62:	b2db      	uxtb	r3, r3
 8005b64:	2bff      	cmp	r3, #255	; 0xff
 8005b66:	d010      	beq.n	8005b8a <send_cmd+0x86>
 8005b68:	6803      	ldr	r3, [r0, #0]
 8005b6a:	2b00      	cmp	r3, #0
 8005b6c:	d1f2      	bne.n	8005b54 <send_cmd+0x50>
	SD_CS_HIGH;									/* Set CS# high */
 8005b6e:	483a      	ldr	r0, [pc, #232]	; (8005c58 <send_cmd+0x154>)
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005b70:	493a      	ldr	r1, [pc, #232]	; (8005c5c <send_cmd+0x158>)
	SD_CS_HIGH;									/* Set CS# high */
 8005b72:	2401      	movs	r4, #1
	SPIx->DR=dat;
 8005b74:	23ff      	movs	r3, #255	; 0xff
	SD_CS_HIGH;									/* Set CS# high */
 8005b76:	6184      	str	r4, [r0, #24]
	SPIx->DR=dat;
 8005b78:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005b7a:	688b      	ldr	r3, [r1, #8]
 8005b7c:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005b80:	2b03      	cmp	r3, #3
 8005b82:	d1fa      	bne.n	8005b7a <send_cmd+0x76>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005b84:	68cb      	ldr	r3, [r1, #12]
		if (!sel()) return 0xFF;
 8005b86:	20ff      	movs	r0, #255	; 0xff
}
 8005b88:	bd38      	pop	{r3, r4, r5, pc}
	SPIx->DR=dat;
 8005b8a:	4a34      	ldr	r2, [pc, #208]	; (8005c5c <send_cmd+0x158>)
 8005b8c:	f044 0340 	orr.w	r3, r4, #64	; 0x40
 8005b90:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005b92:	6893      	ldr	r3, [r2, #8]
 8005b94:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005b98:	2b03      	cmp	r3, #3
 8005b9a:	d1fa      	bne.n	8005b92 <send_cmd+0x8e>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
 8005b9c:	0e2b      	lsrs	r3, r5, #24
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005b9e:	482f      	ldr	r0, [pc, #188]	; (8005c5c <send_cmd+0x158>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005ba0:	68d1      	ldr	r1, [r2, #12]
	SPIx->DR=dat;
 8005ba2:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005ba4:	6883      	ldr	r3, [r0, #8]
 8005ba6:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005baa:	2b03      	cmp	r3, #3
 8005bac:	d1fa      	bne.n	8005ba4 <send_cmd+0xa0>
 8005bae:	f3c5 4307 	ubfx	r3, r5, #16, #8
 8005bb2:	492a      	ldr	r1, [pc, #168]	; (8005c5c <send_cmd+0x158>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005bb4:	68c2      	ldr	r2, [r0, #12]
	SPIx->DR=dat;
 8005bb6:	60c3      	str	r3, [r0, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005bb8:	688b      	ldr	r3, [r1, #8]
 8005bba:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005bbe:	2b03      	cmp	r3, #3
 8005bc0:	d1fa      	bne.n	8005bb8 <send_cmd+0xb4>
 8005bc2:	f3c5 2307 	ubfx	r3, r5, #8, #8
 8005bc6:	4a25      	ldr	r2, [pc, #148]	; (8005c5c <send_cmd+0x158>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005bc8:	68c8      	ldr	r0, [r1, #12]
	SPIx->DR=dat;
 8005bca:	60cb      	str	r3, [r1, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005bcc:	6893      	ldr	r3, [r2, #8]
 8005bce:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005bd2:	2b03      	cmp	r3, #3
 8005bd4:	d1fa      	bne.n	8005bcc <send_cmd+0xc8>
 8005bd6:	b2ed      	uxtb	r5, r5
 8005bd8:	4920      	ldr	r1, [pc, #128]	; (8005c5c <send_cmd+0x158>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005bda:	68d3      	ldr	r3, [r2, #12]
	SPIx->DR=dat;
 8005bdc:	60d5      	str	r5, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005bde:	688b      	ldr	r3, [r1, #8]
 8005be0:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005be4:	2b03      	cmp	r3, #3
 8005be6:	d1fa      	bne.n	8005bde <send_cmd+0xda>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005be8:	68cb      	ldr	r3, [r1, #12]
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
 8005bea:	b9e4      	cbnz	r4, 8005c26 <send_cmd+0x122>
 8005bec:	2395      	movs	r3, #149	; 0x95
	SPIx->DR=dat;
 8005bee:	4a1b      	ldr	r2, [pc, #108]	; (8005c5c <send_cmd+0x158>)
 8005bf0:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005bf2:	6893      	ldr	r3, [r2, #8]
 8005bf4:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005bf8:	2b03      	cmp	r3, #3
 8005bfa:	d1fa      	bne.n	8005bf2 <send_cmd+0xee>
	if (cmd == CMD12) xchg_spi(0xFF);	/* Diacard following one byte when CMD12 */
 8005bfc:	2c0c      	cmp	r4, #12
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005bfe:	68d3      	ldr	r3, [r2, #12]
	if (cmd == CMD12) xchg_spi(0xFF);	/* Diacard following one byte when CMD12 */
 8005c00:	d016      	beq.n	8005c30 <send_cmd+0x12c>
	SPIx->DR=dat;
 8005c02:	4a16      	ldr	r2, [pc, #88]	; (8005c5c <send_cmd+0x158>)
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
 8005c04:	210a      	movs	r1, #10
	SPIx->DR=dat;
 8005c06:	24ff      	movs	r4, #255	; 0xff
 8005c08:	60d4      	str	r4, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005c0a:	6893      	ldr	r3, [r2, #8]
 8005c0c:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005c10:	2b03      	cmp	r3, #3
 8005c12:	d1fa      	bne.n	8005c0a <send_cmd+0x106>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005c14:	68d3      	ldr	r3, [r2, #12]
 8005c16:	b2d8      	uxtb	r0, r3
	} while ((res & 0x80) && --n);
 8005c18:	061b      	lsls	r3, r3, #24
 8005c1a:	d5b5      	bpl.n	8005b88 <send_cmd+0x84>
 8005c1c:	1e4b      	subs	r3, r1, #1
 8005c1e:	f013 01ff 	ands.w	r1, r3, #255	; 0xff
 8005c22:	d1f1      	bne.n	8005c08 <send_cmd+0x104>
}
 8005c24:	bd38      	pop	{r3, r4, r5, pc}
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
 8005c26:	2c08      	cmp	r4, #8
 8005c28:	bf0c      	ite	eq
 8005c2a:	2387      	moveq	r3, #135	; 0x87
 8005c2c:	2301      	movne	r3, #1
 8005c2e:	e7de      	b.n	8005bee <send_cmd+0xea>
	SPIx->DR=dat;
 8005c30:	23ff      	movs	r3, #255	; 0xff
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005c32:	490a      	ldr	r1, [pc, #40]	; (8005c5c <send_cmd+0x158>)
	SPIx->DR=dat;
 8005c34:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005c36:	688b      	ldr	r3, [r1, #8]
 8005c38:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005c3c:	2b03      	cmp	r3, #3
 8005c3e:	d1fa      	bne.n	8005c36 <send_cmd+0x132>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005c40:	68cb      	ldr	r3, [r1, #12]
 8005c42:	e7de      	b.n	8005c02 <send_cmd+0xfe>
		res = send_cmd(CMD55, 0);
 8005c44:	2100      	movs	r1, #0
 8005c46:	2037      	movs	r0, #55	; 0x37
 8005c48:	f7ff ff5c 	bl	8005b04 <send_cmd>
		if (res > 1) return res;
 8005c4c:	2801      	cmp	r0, #1
 8005c4e:	d89b      	bhi.n	8005b88 <send_cmd+0x84>
		cmd &= 0x7F;
 8005c50:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 8005c54:	e75c      	b.n	8005b10 <send_cmd+0xc>
 8005c56:	bf00      	nop
 8005c58:	40020400 	.word	0x40020400
 8005c5c:	40003800 	.word	0x40003800
 8005c60:	20004088 	.word	0x20004088

08005c64 <USER_initialize>:
	if (pdrv) return STA_NOINIT;			/* Supports only drive 0 */
 8005c64:	b108      	cbz	r0, 8005c6a <USER_initialize+0x6>
 8005c66:	2001      	movs	r0, #1
}
 8005c68:	4770      	bx	lr
	SD_CS_IO;
 8005c6a:	4ba8      	ldr	r3, [pc, #672]	; (8005f0c <USER_initialize+0x2a8>)
	enableSPIclocks();
 8005c6c:	49a8      	ldr	r1, [pc, #672]	; (8005f10 <USER_initialize+0x2ac>)
	SPIx->CR1 &= 0x3040; // Clear SPI settings
 8005c6e:	4aa9      	ldr	r2, [pc, #676]	; (8005f14 <USER_initialize+0x2b0>)
{
 8005c70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005c74:	4605      	mov	r5, r0
	SD_CS_IO;
 8005c76:	6818      	ldr	r0, [r3, #0]
	if (Stat & STA_NODISK) return Stat;	/* Is card existing in the soket? */
 8005c78:	4ea7      	ldr	r6, [pc, #668]	; (8005f18 <USER_initialize+0x2b4>)
	SD_CS_IO;
 8005c7a:	f020 0003 	bic.w	r0, r0, #3
 8005c7e:	6018      	str	r0, [r3, #0]
 8005c80:	6818      	ldr	r0, [r3, #0]
 8005c82:	f040 0001 	orr.w	r0, r0, #1
 8005c86:	6018      	str	r0, [r3, #0]
 8005c88:	6858      	ldr	r0, [r3, #4]
 8005c8a:	f020 0001 	bic.w	r0, r0, #1
 8005c8e:	6058      	str	r0, [r3, #4]
 8005c90:	6858      	ldr	r0, [r3, #4]
 8005c92:	6058      	str	r0, [r3, #4]
 8005c94:	6898      	ldr	r0, [r3, #8]
 8005c96:	f020 0003 	bic.w	r0, r0, #3
 8005c9a:	6098      	str	r0, [r3, #8]
 8005c9c:	6898      	ldr	r0, [r3, #8]
 8005c9e:	f040 0003 	orr.w	r0, r0, #3
 8005ca2:	6098      	str	r0, [r3, #8]
 8005ca4:	68d8      	ldr	r0, [r3, #12]
 8005ca6:	f020 0003 	bic.w	r0, r0, #3
 8005caa:	60d8      	str	r0, [r3, #12]
 8005cac:	68d8      	ldr	r0, [r3, #12]
 8005cae:	60d8      	str	r0, [r3, #12]
	enableSPIclocks();
 8005cb0:	6b08      	ldr	r0, [r1, #48]	; 0x30
 8005cb2:	f040 0002 	orr.w	r0, r0, #2
 8005cb6:	6308      	str	r0, [r1, #48]	; 0x30
 8005cb8:	6c08      	ldr	r0, [r1, #64]	; 0x40
 8005cba:	f440 4080 	orr.w	r0, r0, #16384	; 0x4000
 8005cbe:	6408      	str	r0, [r1, #64]	; 0x40
	SD_MOSI_IO; SD_MISO_IO; SD_SCK_IO;
 8005cc0:	6819      	ldr	r1, [r3, #0]
 8005cc2:	f021 4140 	bic.w	r1, r1, #3221225472	; 0xc0000000
 8005cc6:	6019      	str	r1, [r3, #0]
 8005cc8:	6819      	ldr	r1, [r3, #0]
 8005cca:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 8005cce:	6019      	str	r1, [r3, #0]
 8005cd0:	6859      	ldr	r1, [r3, #4]
 8005cd2:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 8005cd6:	6059      	str	r1, [r3, #4]
 8005cd8:	6859      	ldr	r1, [r3, #4]
 8005cda:	6059      	str	r1, [r3, #4]
 8005cdc:	6899      	ldr	r1, [r3, #8]
 8005cde:	f021 4140 	bic.w	r1, r1, #3221225472	; 0xc0000000
 8005ce2:	6099      	str	r1, [r3, #8]
 8005ce4:	6899      	ldr	r1, [r3, #8]
 8005ce6:	f041 4140 	orr.w	r1, r1, #3221225472	; 0xc0000000
 8005cea:	6099      	str	r1, [r3, #8]
 8005cec:	68d9      	ldr	r1, [r3, #12]
 8005cee:	f021 4140 	bic.w	r1, r1, #3221225472	; 0xc0000000
 8005cf2:	60d9      	str	r1, [r3, #12]
 8005cf4:	68d9      	ldr	r1, [r3, #12]
 8005cf6:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 8005cfa:	60d9      	str	r1, [r3, #12]
 8005cfc:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8005cfe:	f021 4170 	bic.w	r1, r1, #4026531840	; 0xf0000000
 8005d02:	6259      	str	r1, [r3, #36]	; 0x24
 8005d04:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8005d06:	f041 41a0 	orr.w	r1, r1, #1342177280	; 0x50000000
 8005d0a:	6259      	str	r1, [r3, #36]	; 0x24
 8005d0c:	6819      	ldr	r1, [r3, #0]
 8005d0e:	f021 5140 	bic.w	r1, r1, #805306368	; 0x30000000
 8005d12:	6019      	str	r1, [r3, #0]
 8005d14:	6819      	ldr	r1, [r3, #0]
 8005d16:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 8005d1a:	6019      	str	r1, [r3, #0]
 8005d1c:	6859      	ldr	r1, [r3, #4]
 8005d1e:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8005d22:	6059      	str	r1, [r3, #4]
 8005d24:	6859      	ldr	r1, [r3, #4]
 8005d26:	6059      	str	r1, [r3, #4]
 8005d28:	6899      	ldr	r1, [r3, #8]
 8005d2a:	f021 5140 	bic.w	r1, r1, #805306368	; 0x30000000
 8005d2e:	6099      	str	r1, [r3, #8]
 8005d30:	6899      	ldr	r1, [r3, #8]
 8005d32:	f041 5140 	orr.w	r1, r1, #805306368	; 0x30000000
 8005d36:	6099      	str	r1, [r3, #8]
 8005d38:	68d9      	ldr	r1, [r3, #12]
 8005d3a:	f021 5140 	bic.w	r1, r1, #805306368	; 0x30000000
 8005d3e:	60d9      	str	r1, [r3, #12]
 8005d40:	68d9      	ldr	r1, [r3, #12]
 8005d42:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8005d46:	60d9      	str	r1, [r3, #12]
 8005d48:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8005d4a:	f021 6170 	bic.w	r1, r1, #251658240	; 0xf000000
 8005d4e:	6259      	str	r1, [r3, #36]	; 0x24
 8005d50:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8005d52:	f041 61a0 	orr.w	r1, r1, #83886080	; 0x5000000
 8005d56:	6259      	str	r1, [r3, #36]	; 0x24
 8005d58:	6819      	ldr	r1, [r3, #0]
 8005d5a:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 8005d5e:	6019      	str	r1, [r3, #0]
 8005d60:	6819      	ldr	r1, [r3, #0]
 8005d62:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 8005d66:	6019      	str	r1, [r3, #0]
 8005d68:	6859      	ldr	r1, [r3, #4]
 8005d6a:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 8005d6e:	6059      	str	r1, [r3, #4]
 8005d70:	6859      	ldr	r1, [r3, #4]
 8005d72:	6059      	str	r1, [r3, #4]
 8005d74:	6899      	ldr	r1, [r3, #8]
 8005d76:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 8005d7a:	6099      	str	r1, [r3, #8]
 8005d7c:	6899      	ldr	r1, [r3, #8]
 8005d7e:	f041 6140 	orr.w	r1, r1, #201326592	; 0xc000000
 8005d82:	6099      	str	r1, [r3, #8]
 8005d84:	68d9      	ldr	r1, [r3, #12]
 8005d86:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 8005d8a:	60d9      	str	r1, [r3, #12]
 8005d8c:	68d9      	ldr	r1, [r3, #12]
 8005d8e:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
 8005d92:	60d9      	str	r1, [r3, #12]
 8005d94:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8005d96:	f421 0170 	bic.w	r1, r1, #15728640	; 0xf00000
 8005d9a:	6259      	str	r1, [r3, #36]	; 0x24
 8005d9c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8005d9e:	f441 01a0 	orr.w	r1, r1, #5242880	; 0x500000
 8005da2:	6259      	str	r1, [r3, #36]	; 0x24
	SPIx->CR1 &= 0x3040; // Clear SPI settings
 8005da4:	6811      	ldr	r1, [r2, #0]
 8005da6:	f401 5141 	and.w	r1, r1, #12352	; 0x3040
 8005daa:	6011      	str	r1, [r2, #0]
	SPIx->CR1 |= SPI_CR1_MSTR | SPI_CR1_SSI | SPI_CR1_SSM; // Master mode
 8005dac:	6811      	ldr	r1, [r2, #0]
 8005dae:	f441 7141 	orr.w	r1, r1, #772	; 0x304
 8005db2:	6011      	str	r1, [r2, #0]
	SPIx->I2SCFGR &= ~SPI_I2SCFGR_I2SMOD;
 8005db4:	69d1      	ldr	r1, [r2, #28]
	SPIx->CRCPR = 10;
 8005db6:	240a      	movs	r4, #10
	SPIx->I2SCFGR &= ~SPI_I2SCFGR_I2SMOD;
 8005db8:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
 8005dbc:	61d1      	str	r1, [r2, #28]
	SPIx->CRCPR = 10;
 8005dbe:	6114      	str	r4, [r2, #16]
	SPIx->CR1|=SPI_CR1_SPE;							/* Enable SPI function */
 8005dc0:	6811      	ldr	r1, [r2, #0]
 8005dc2:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8005dc6:	6011      	str	r1, [r2, #0]
	SD_CS_HIGH;									/* Set CS# high */
 8005dc8:	2101      	movs	r1, #1
 8005dca:	6199      	str	r1, [r3, #24]
	if (Stat & STA_NODISK) return Stat;	/* Is card existing in the soket? */
 8005dcc:	7833      	ldrb	r3, [r6, #0]
 8005dce:	079b      	lsls	r3, r3, #30
{
 8005dd0:	b082      	sub	sp, #8
	if (Stat & STA_NODISK) return Stat;	/* Is card existing in the soket? */
 8005dd2:	d436      	bmi.n	8005e42 <USER_initialize+0x1de>
	FCLK_SLOW();
 8005dd4:	6813      	ldr	r3, [r2, #0]
 8005dd6:	f023 0338 	bic.w	r3, r3, #56	; 0x38
 8005dda:	6013      	str	r3, [r2, #0]
 8005ddc:	6813      	ldr	r3, [r2, #0]
 8005dde:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 8005de2:	6013      	str	r3, [r2, #0]
	SPIx->DR=dat;
 8005de4:	21ff      	movs	r1, #255	; 0xff
 8005de6:	60d1      	str	r1, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005de8:	6893      	ldr	r3, [r2, #8]
 8005dea:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005dee:	2b03      	cmp	r3, #3
 8005df0:	d1fa      	bne.n	8005de8 <USER_initialize+0x184>
 8005df2:	1e63      	subs	r3, r4, #1
	for (n = 10; n; n--) xchg_spi(0xFF);	/* Send 80 dummy clocks */
 8005df4:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005df8:	68d0      	ldr	r0, [r2, #12]
	for (n = 10; n; n--) xchg_spi(0xFF);	/* Send 80 dummy clocks */
 8005dfa:	d1f4      	bne.n	8005de6 <USER_initialize+0x182>
	if (send_cmd(CMD0, 0) == 1) {			/* Put the card SPI/Idle state */
 8005dfc:	4621      	mov	r1, r4
 8005dfe:	4620      	mov	r0, r4
 8005e00:	f7ff fe80 	bl	8005b04 <send_cmd>
 8005e04:	2801      	cmp	r0, #1
 8005e06:	4607      	mov	r7, r0
 8005e08:	d027      	beq.n	8005e5a <USER_initialize+0x1f6>
	CardType = ty;	/* Card type */
 8005e0a:	4944      	ldr	r1, [pc, #272]	; (8005f1c <USER_initialize+0x2b8>)
	SD_CS_HIGH;									/* Set CS# high */
 8005e0c:	4a3f      	ldr	r2, [pc, #252]	; (8005f0c <USER_initialize+0x2a8>)
	SPIx->DR=dat;
 8005e0e:	4b41      	ldr	r3, [pc, #260]	; (8005f14 <USER_initialize+0x2b0>)
	CardType = ty;	/* Card type */
 8005e10:	700d      	strb	r5, [r1, #0]
	SD_CS_HIGH;									/* Set CS# high */
 8005e12:	2001      	movs	r0, #1
	SPIx->DR=dat;
 8005e14:	21ff      	movs	r1, #255	; 0xff
	SD_CS_HIGH;									/* Set CS# high */
 8005e16:	6190      	str	r0, [r2, #24]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005e18:	461a      	mov	r2, r3
	SPIx->DR=dat;
 8005e1a:	60d9      	str	r1, [r3, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005e1c:	6893      	ldr	r3, [r2, #8]
 8005e1e:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005e22:	2b03      	cmp	r3, #3
 8005e24:	d1fa      	bne.n	8005e1c <USER_initialize+0x1b8>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005e26:	68d3      	ldr	r3, [r2, #12]
	if (ty) {			/* OK */
 8005e28:	b185      	cbz	r5, 8005e4c <USER_initialize+0x1e8>
		FCLK_FAST();			/* Set fast clock */
 8005e2a:	6813      	ldr	r3, [r2, #0]
 8005e2c:	f023 0338 	bic.w	r3, r3, #56	; 0x38
 8005e30:	6013      	str	r3, [r2, #0]
 8005e32:	6813      	ldr	r3, [r2, #0]
 8005e34:	f043 0308 	orr.w	r3, r3, #8
 8005e38:	6013      	str	r3, [r2, #0]
		Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
 8005e3a:	7833      	ldrb	r3, [r6, #0]
 8005e3c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8005e40:	7033      	strb	r3, [r6, #0]
	return Stat;
 8005e42:	7830      	ldrb	r0, [r6, #0]
 8005e44:	b2c0      	uxtb	r0, r0
}
 8005e46:	b002      	add	sp, #8
 8005e48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		Stat = STA_NOINIT;
 8005e4c:	2301      	movs	r3, #1
 8005e4e:	7033      	strb	r3, [r6, #0]
	return Stat;
 8005e50:	7830      	ldrb	r0, [r6, #0]
 8005e52:	b2c0      	uxtb	r0, r0
}
 8005e54:	b002      	add	sp, #8
 8005e56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		Timer1 = 1000;						/* Initialization timeout = 1 sec */
 8005e5a:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 8005f20 <USER_initialize+0x2bc>
 8005e5e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
 8005e62:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8005e66:	2008      	movs	r0, #8
		Timer1 = 1000;						/* Initialization timeout = 1 sec */
 8005e68:	f8c8 3000 	str.w	r3, [r8]
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
 8005e6c:	f7ff fe4a 	bl	8005b04 <send_cmd>
 8005e70:	2801      	cmp	r0, #1
 8005e72:	d141      	bne.n	8005ef8 <USER_initialize+0x294>
 8005e74:	af01      	add	r7, sp, #4
	SPIx->DR=dat;
 8005e76:	4a27      	ldr	r2, [pc, #156]	; (8005f14 <USER_initialize+0x2b0>)
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
 8005e78:	463c      	mov	r4, r7
 8005e7a:	a802      	add	r0, sp, #8
	SPIx->DR=dat;
 8005e7c:	21ff      	movs	r1, #255	; 0xff
 8005e7e:	60d1      	str	r1, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005e80:	6893      	ldr	r3, [r2, #8]
 8005e82:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005e86:	2b03      	cmp	r3, #3
 8005e88:	d1fa      	bne.n	8005e80 <USER_initialize+0x21c>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005e8a:	68d3      	ldr	r3, [r2, #12]
 8005e8c:	f804 3b01 	strb.w	r3, [r4], #1
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);	/* Get 32 bit return value of R7 resp */
 8005e90:	4284      	cmp	r4, r0
 8005e92:	d1f4      	bne.n	8005e7e <USER_initialize+0x21a>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* Is the card supports vcc of 2.7-3.6V? */
 8005e94:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8005e98:	2b01      	cmp	r3, #1
 8005e9a:	d1b6      	bne.n	8005e0a <USER_initialize+0x1a6>
 8005e9c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005ea0:	2baa      	cmp	r3, #170	; 0xaa
 8005ea2:	d1b2      	bne.n	8005e0a <USER_initialize+0x1a6>
 8005ea4:	e002      	b.n	8005eac <USER_initialize+0x248>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30)) ;	/* Wait for end of initialization with ACMD41(HCS) */
 8005ea6:	f7ff fe2d 	bl	8005b04 <send_cmd>
 8005eaa:	b130      	cbz	r0, 8005eba <USER_initialize+0x256>
 8005eac:	f8d8 3000 	ldr.w	r3, [r8]
 8005eb0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8005eb4:	20a9      	movs	r0, #169	; 0xa9
 8005eb6:	2b00      	cmp	r3, #0
 8005eb8:	d1f5      	bne.n	8005ea6 <USER_initialize+0x242>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
 8005eba:	f8d8 3000 	ldr.w	r3, [r8]
 8005ebe:	2b00      	cmp	r3, #0
 8005ec0:	d0a3      	beq.n	8005e0a <USER_initialize+0x1a6>
 8005ec2:	2100      	movs	r1, #0
 8005ec4:	203a      	movs	r0, #58	; 0x3a
 8005ec6:	f7ff fe1d 	bl	8005b04 <send_cmd>
 8005eca:	2800      	cmp	r0, #0
 8005ecc:	d19d      	bne.n	8005e0a <USER_initialize+0x1a6>
	SPIx->DR=dat;
 8005ece:	4b11      	ldr	r3, [pc, #68]	; (8005f14 <USER_initialize+0x2b0>)
 8005ed0:	21ff      	movs	r1, #255	; 0xff
 8005ed2:	60d9      	str	r1, [r3, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005ed4:	689a      	ldr	r2, [r3, #8]
 8005ed6:	f002 0283 	and.w	r2, r2, #131	; 0x83
 8005eda:	2a03      	cmp	r2, #3
 8005edc:	d1fa      	bne.n	8005ed4 <USER_initialize+0x270>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005ede:	68da      	ldr	r2, [r3, #12]
 8005ee0:	f807 2b01 	strb.w	r2, [r7], #1
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
 8005ee4:	42a7      	cmp	r7, r4
 8005ee6:	d1f4      	bne.n	8005ed2 <USER_initialize+0x26e>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* Card id SDv2 */
 8005ee8:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8005eec:	f013 0f40 	tst.w	r3, #64	; 0x40
 8005ef0:	bf14      	ite	ne
 8005ef2:	250c      	movne	r5, #12
 8005ef4:	2504      	moveq	r5, #4
 8005ef6:	e788      	b.n	8005e0a <USER_initialize+0x1a6>
			if (send_cmd(ACMD41, 0) <= 1) 	{	/* SDv1 or MMC? */
 8005ef8:	4621      	mov	r1, r4
 8005efa:	20a9      	movs	r0, #169	; 0xa9
 8005efc:	f7ff fe02 	bl	8005b04 <send_cmd>
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 (CMD1(0)) */
 8005f00:	2802      	cmp	r0, #2
 8005f02:	bf3a      	itte	cc
 8005f04:	27a9      	movcc	r7, #169	; 0xa9
 8005f06:	2402      	movcc	r4, #2
 8005f08:	2401      	movcs	r4, #1
 8005f0a:	e00e      	b.n	8005f2a <USER_initialize+0x2c6>
 8005f0c:	40020400 	.word	0x40020400
 8005f10:	40023800 	.word	0x40023800
 8005f14:	40003800 	.word	0x40003800
 8005f18:	2000000c 	.word	0x2000000c
 8005f1c:	20004080 	.word	0x20004080
 8005f20:	20004084 	.word	0x20004084
			while (Timer1 && send_cmd(cmd, 0)) ;		/* Wait for end of initialization */
 8005f24:	f7ff fdee 	bl	8005b04 <send_cmd>
 8005f28:	b128      	cbz	r0, 8005f36 <USER_initialize+0x2d2>
 8005f2a:	f8d8 3000 	ldr.w	r3, [r8]
 8005f2e:	2100      	movs	r1, #0
 8005f30:	4638      	mov	r0, r7
 8005f32:	2b00      	cmp	r3, #0
 8005f34:	d1f6      	bne.n	8005f24 <USER_initialize+0x2c0>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set block length: 512 */
 8005f36:	f8d8 3000 	ldr.w	r3, [r8]
 8005f3a:	2b00      	cmp	r3, #0
 8005f3c:	f43f af65 	beq.w	8005e0a <USER_initialize+0x1a6>
 8005f40:	f44f 7100 	mov.w	r1, #512	; 0x200
 8005f44:	2010      	movs	r0, #16
 8005f46:	f7ff fddd 	bl	8005b04 <send_cmd>
 8005f4a:	2800      	cmp	r0, #0
 8005f4c:	bf08      	it	eq
 8005f4e:	4625      	moveq	r5, r4
 8005f50:	e75b      	b.n	8005e0a <USER_initialize+0x1a6>
 8005f52:	bf00      	nop

08005f54 <USER_read>:
	BYTE pdrv,      /* Physical drive nmuber to identify the drive */
	BYTE *buff,     /* Data buffer to store read data */
	DWORD sector,   /* Sector address in LBA */
	UINT count      /* Number of sectors to read */
)
{
 8005f54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  /* USER CODE BEGIN READ */
	if (pdrv || !count) return RES_PARERR;		/* Check parameter */
 8005f58:	2800      	cmp	r0, #0
 8005f5a:	d12e      	bne.n	8005fba <USER_read+0x66>
 8005f5c:	461d      	mov	r5, r3
 8005f5e:	b363      	cbz	r3, 8005fba <USER_read+0x66>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 8005f60:	4b49      	ldr	r3, [pc, #292]	; (8006088 <USER_read+0x134>)
 8005f62:	781b      	ldrb	r3, [r3, #0]
 8005f64:	07d8      	lsls	r0, r3, #31
 8005f66:	d47d      	bmi.n	8006064 <USER_read+0x110>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* LBA ot BA conversion (byte addressing cards) */
 8005f68:	4b48      	ldr	r3, [pc, #288]	; (800608c <USER_read+0x138>)
 8005f6a:	781b      	ldrb	r3, [r3, #0]
 8005f6c:	071b      	lsls	r3, r3, #28
 8005f6e:	bf58      	it	pl
 8005f70:	0252      	lslpl	r2, r2, #9

	if (count == 1) {	/* Single sector read */
 8005f72:	2d01      	cmp	r5, #1
 8005f74:	460c      	mov	r4, r1
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
 8005f76:	4611      	mov	r1, r2
	if (count == 1) {	/* Single sector read */
 8005f78:	d078      	beq.n	800606c <USER_read+0x118>
			&& rcvr_datablock(buff, 512)) {
			count = 0;
		}
	}
	else {				/* Multiple sector read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
 8005f7a:	2012      	movs	r0, #18
 8005f7c:	f7ff fdc2 	bl	8005b04 <send_cmd>
 8005f80:	b9f8      	cbnz	r0, 8005fc2 <USER_read+0x6e>
	SPIx->DR=dat;
 8005f82:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8005f86:	4b42      	ldr	r3, [pc, #264]	; (8006090 <USER_read+0x13c>)
 8005f88:	4942      	ldr	r1, [pc, #264]	; (8006094 <USER_read+0x140>)
 8005f8a:	4660      	mov	r0, ip
	Timer1 = 200;
 8005f8c:	27c8      	movs	r7, #200	; 0xc8
	SPIx->DR=0xFFFF;							/* Start the first SPI transaction */
 8005f8e:	f64f 76ff 	movw	r6, #65535	; 0xffff
	Timer1 = 200;
 8005f92:	601f      	str	r7, [r3, #0]
	SPIx->DR=dat;
 8005f94:	60c8      	str	r0, [r1, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005f96:	688a      	ldr	r2, [r1, #8]
 8005f98:	f002 0283 	and.w	r2, r2, #131	; 0x83
 8005f9c:	2a03      	cmp	r2, #3
 8005f9e:	d1fa      	bne.n	8005f96 <USER_read+0x42>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005fa0:	68ca      	ldr	r2, [r1, #12]
 8005fa2:	b2d2      	uxtb	r2, r2
	} while ((token == 0xFF) && Timer1);
 8005fa4:	2aff      	cmp	r2, #255	; 0xff
 8005fa6:	d11d      	bne.n	8005fe4 <USER_read+0x90>
 8005fa8:	681a      	ldr	r2, [r3, #0]
 8005faa:	2a00      	cmp	r2, #0
 8005fac:	d1f2      	bne.n	8005f94 <USER_read+0x40>
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */
 8005fae:	2501      	movs	r5, #1
			do {
				if (!rcvr_datablock(buff, 512)) break;
				buff += 512;
			} while (--count);
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
 8005fb0:	2100      	movs	r1, #0
 8005fb2:	200c      	movs	r0, #12
 8005fb4:	f7ff fda6 	bl	8005b04 <send_cmd>
 8005fb8:	e004      	b.n	8005fc4 <USER_read+0x70>
	if (pdrv || !count) return RES_PARERR;		/* Check parameter */
 8005fba:	2504      	movs	r5, #4
	}
	desel();

	return count ? RES_ERROR : RES_OK;	/* Return result */
  /* USER CODE END READ */
}
 8005fbc:	4628      	mov	r0, r5
 8005fbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
 8005fc2:	2501      	movs	r5, #1
	SD_CS_HIGH;									/* Set CS# high */
 8005fc4:	4a34      	ldr	r2, [pc, #208]	; (8006098 <USER_read+0x144>)
	SPIx->DR=dat;
 8005fc6:	4b33      	ldr	r3, [pc, #204]	; (8006094 <USER_read+0x140>)
	SD_CS_HIGH;									/* Set CS# high */
 8005fc8:	2001      	movs	r0, #1
	SPIx->DR=dat;
 8005fca:	21ff      	movs	r1, #255	; 0xff
	SD_CS_HIGH;									/* Set CS# high */
 8005fcc:	6190      	str	r0, [r2, #24]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005fce:	461a      	mov	r2, r3
	SPIx->DR=dat;
 8005fd0:	60d9      	str	r1, [r3, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8005fd2:	6893      	ldr	r3, [r2, #8]
 8005fd4:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8005fd8:	2b03      	cmp	r3, #3
 8005fda:	d1fa      	bne.n	8005fd2 <USER_read+0x7e>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8005fdc:	68d3      	ldr	r3, [r2, #12]
}
 8005fde:	4628      	mov	r0, r5
 8005fe0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */
 8005fe4:	2afe      	cmp	r2, #254	; 0xfe
 8005fe6:	d1e2      	bne.n	8005fae <USER_read+0x5a>
	SPIx->CR1|=SPI_CR1_DFF;						/* Put SPI into 16-bit mode */
 8005fe8:	680a      	ldr	r2, [r1, #0]
 8005fea:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8005fee:	600a      	str	r2, [r1, #0]
 8005ff0:	f104 0e02 	add.w	lr, r4, #2
	SPIx->DR=0xFFFF;							/* Start the first SPI transaction */
 8005ff4:	60ce      	str	r6, [r1, #12]
 8005ff6:	f504 7800 	add.w	r8, r4, #512	; 0x200
		while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);	/* Wait for end of the SPI transaction */
 8005ffa:	688a      	ldr	r2, [r1, #8]
 8005ffc:	f002 0283 	and.w	r2, r2, #131	; 0x83
 8006000:	2a03      	cmp	r2, #3
 8006002:	d1fa      	bne.n	8005ffa <USER_read+0xa6>
		d = SPIx->DR;							/* Get received word */
 8006004:	68ca      	ldr	r2, [r1, #12]
		SPIx->DR=0xFFFF;						/* Start next transaction */
 8006006:	60ce      	str	r6, [r1, #12]
		buff[1] = d; buff[0] = d >> 8; 			/* Store received data */
 8006008:	f3c2 2907 	ubfx	r9, r2, #8, #8
 800600c:	f80e 2c01 	strb.w	r2, [lr, #-1]
 8006010:	f80e 9c02 	strb.w	r9, [lr, #-2]
 8006014:	f10e 0e02 	add.w	lr, lr, #2
	} while (btr -= 2);
 8006018:	45f0      	cmp	r8, lr
 800601a:	d1ee      	bne.n	8005ffa <USER_read+0xa6>
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);		/* Wait for end of the SPI transaction */
 800601c:	688a      	ldr	r2, [r1, #8]
 800601e:	f002 0283 	and.w	r2, r2, #131	; 0x83
 8006022:	2a03      	cmp	r2, #3
 8006024:	d1fa      	bne.n	800601c <USER_read+0xc8>
	d = SPIx->DR;								/* Get last word received */
 8006026:	68ca      	ldr	r2, [r1, #12]
	buff[1] = d; buff[0] = d >> 8;				/* Store it */
 8006028:	f884 21ff 	strb.w	r2, [r4, #511]	; 0x1ff
 800602c:	f3c2 2207 	ubfx	r2, r2, #8, #8
 8006030:	f884 21fe 	strb.w	r2, [r4, #510]	; 0x1fe
	SPIx->CR1&=~SPI_CR1_DFF;					/* Put SPI into 8-bit mode */
 8006034:	680a      	ldr	r2, [r1, #0]
 8006036:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800603a:	600a      	str	r2, [r1, #0]
	SPIx->DR=dat;
 800603c:	f8c1 c00c 	str.w	ip, [r1, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8006040:	688a      	ldr	r2, [r1, #8]
 8006042:	f002 0283 	and.w	r2, r2, #131	; 0x83
 8006046:	2a03      	cmp	r2, #3
 8006048:	d1fa      	bne.n	8006040 <USER_read+0xec>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 800604a:	68ca      	ldr	r2, [r1, #12]
	SPIx->DR=dat;
 800604c:	f8c1 c00c 	str.w	ip, [r1, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8006050:	688a      	ldr	r2, [r1, #8]
 8006052:	f002 0283 	and.w	r2, r2, #131	; 0x83
 8006056:	2a03      	cmp	r2, #3
 8006058:	d1fa      	bne.n	8006050 <USER_read+0xfc>
			} while (--count);
 800605a:	3d01      	subs	r5, #1
	return (BYTE)(SPIx->DR);					/* Return received byte */
 800605c:	68ca      	ldr	r2, [r1, #12]
				buff += 512;
 800605e:	4644      	mov	r4, r8
			} while (--count);
 8006060:	d197      	bne.n	8005f92 <USER_read+0x3e>
 8006062:	e7a5      	b.n	8005fb0 <USER_read+0x5c>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 8006064:	2503      	movs	r5, #3
}
 8006066:	4628      	mov	r0, r5
 8006068:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
 800606c:	2011      	movs	r0, #17
 800606e:	f7ff fd49 	bl	8005b04 <send_cmd>
 8006072:	2800      	cmp	r0, #0
 8006074:	d1a6      	bne.n	8005fc4 <USER_read+0x70>
			&& rcvr_datablock(buff, 512)) {
 8006076:	4620      	mov	r0, r4
 8006078:	f44f 7100 	mov.w	r1, #512	; 0x200
 800607c:	f7ff fc98 	bl	80059b0 <rcvr_datablock>
 8006080:	fab0 f580 	clz	r5, r0
 8006084:	096d      	lsrs	r5, r5, #5
 8006086:	e79d      	b.n	8005fc4 <USER_read+0x70>
 8006088:	2000000c 	.word	0x2000000c
 800608c:	20004080 	.word	0x20004080
 8006090:	20004084 	.word	0x20004084
 8006094:	40003800 	.word	0x40003800
 8006098:	40020400 	.word	0x40020400

0800609c <USER_ioctl>:
DRESULT USER_ioctl (
	BYTE pdrv,      /* Physical drive nmuber (0..) */
	BYTE cmd,       /* Control code */
	void *buff      /* Buffer to send/receive control data */
)
{
 800609c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800609e:	b085      	sub	sp, #20
	DRESULT res;
	BYTE n, csd[16];
	DWORD *dp, st, ed, csize;


	if (pdrv) return RES_PARERR;					/* Check parameter */
 80060a0:	b980      	cbnz	r0, 80060c4 <USER_ioctl+0x28>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 80060a2:	4ba3      	ldr	r3, [pc, #652]	; (8006330 <USER_ioctl+0x294>)
 80060a4:	781b      	ldrb	r3, [r3, #0]
 80060a6:	07d8      	lsls	r0, r3, #31
 80060a8:	d408      	bmi.n	80060bc <USER_ioctl+0x20>
 80060aa:	4615      	mov	r5, r2

	res = RES_ERROR;

	switch (cmd) {
 80060ac:	2904      	cmp	r1, #4
 80060ae:	f200 80ae 	bhi.w	800620e <USER_ioctl+0x172>
 80060b2:	e8df f001 	tbb	[pc, r1]
 80060b6:	4a7d      	.short	0x4a7d
 80060b8:	22ac      	.short	0x22ac
 80060ba:	0b          	.byte	0x0b
 80060bb:	00          	.byte	0x00
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 80060bc:	2403      	movs	r4, #3

	desel();

	return res;
  /* USER CODE END IOCTL */
}
 80060be:	4620      	mov	r0, r4
 80060c0:	b005      	add	sp, #20
 80060c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (pdrv) return RES_PARERR;					/* Check parameter */
 80060c4:	2404      	movs	r4, #4
}
 80060c6:	4620      	mov	r0, r4
 80060c8:	b005      	add	sp, #20
 80060ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (!(CardType & CT_SDC)) break;				/* Check if the card is SDC */
 80060cc:	4e99      	ldr	r6, [pc, #612]	; (8006334 <USER_ioctl+0x298>)
 80060ce:	7833      	ldrb	r3, [r6, #0]
 80060d0:	f013 0f06 	tst.w	r3, #6
 80060d4:	f040 80cb 	bne.w	800626e <USER_ioctl+0x1d2>
	res = RES_ERROR;
 80060d8:	2401      	movs	r4, #1
	SD_CS_HIGH;									/* Set CS# high */
 80060da:	4a97      	ldr	r2, [pc, #604]	; (8006338 <USER_ioctl+0x29c>)
	SPIx->DR=dat;
 80060dc:	4b97      	ldr	r3, [pc, #604]	; (800633c <USER_ioctl+0x2a0>)
	SD_CS_HIGH;									/* Set CS# high */
 80060de:	2001      	movs	r0, #1
	SPIx->DR=dat;
 80060e0:	21ff      	movs	r1, #255	; 0xff
	SD_CS_HIGH;									/* Set CS# high */
 80060e2:	6190      	str	r0, [r2, #24]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80060e4:	461a      	mov	r2, r3
	SPIx->DR=dat;
 80060e6:	60d9      	str	r1, [r3, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80060e8:	6893      	ldr	r3, [r2, #8]
 80060ea:	f003 0383 	and.w	r3, r3, #131	; 0x83
 80060ee:	2b03      	cmp	r3, #3
 80060f0:	d1fa      	bne.n	80060e8 <USER_ioctl+0x4c>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 80060f2:	68d3      	ldr	r3, [r2, #12]
}
 80060f4:	4620      	mov	r0, r4
 80060f6:	b005      	add	sp, #20
 80060f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (CardType & CT_SD2) {	/* SDC ver 2.00 */
 80060fa:	4b8e      	ldr	r3, [pc, #568]	; (8006334 <USER_ioctl+0x298>)
 80060fc:	781c      	ldrb	r4, [r3, #0]
 80060fe:	f014 0104 	ands.w	r1, r4, #4
 8006102:	f040 8088 	bne.w	8006216 <USER_ioctl+0x17a>
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
 8006106:	2009      	movs	r0, #9
 8006108:	f7ff fcfc 	bl	8005b04 <send_cmd>
 800610c:	4606      	mov	r6, r0
 800610e:	2800      	cmp	r0, #0
 8006110:	d1e2      	bne.n	80060d8 <USER_ioctl+0x3c>
 8006112:	2110      	movs	r1, #16
 8006114:	4668      	mov	r0, sp
 8006116:	f7ff fc4b 	bl	80059b0 <rcvr_datablock>
 800611a:	2800      	cmp	r0, #0
 800611c:	d0dc      	beq.n	80060d8 <USER_ioctl+0x3c>
				if (CardType & CT_SD1) {	/* SDC ver 1.XX */
 800611e:	f014 0402 	ands.w	r4, r4, #2
 8006122:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8006126:	f89d 100b 	ldrb.w	r1, [sp, #11]
 800612a:	f000 80f4 	beq.w	8006316 <USER_ioctl+0x27a>
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
 800612e:	005b      	lsls	r3, r3, #1
 8006130:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8006134:	f003 037e 	and.w	r3, r3, #126	; 0x7e
 8006138:	eb03 13d1 	add.w	r3, r3, r1, lsr #7
 800613c:	0992      	lsrs	r2, r2, #6
 800613e:	3301      	adds	r3, #1
 8006140:	3a01      	subs	r2, #1
 8006142:	4093      	lsls	r3, r2
				res = RES_OK;
 8006144:	4634      	mov	r4, r6
					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
 8006146:	602b      	str	r3, [r5, #0]
 8006148:	e7c7      	b.n	80060da <USER_ioctl+0x3e>
		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
 800614a:	2100      	movs	r1, #0
 800614c:	2009      	movs	r0, #9
 800614e:	f7ff fcd9 	bl	8005b04 <send_cmd>
 8006152:	4604      	mov	r4, r0
 8006154:	2800      	cmp	r0, #0
 8006156:	d1bf      	bne.n	80060d8 <USER_ioctl+0x3c>
 8006158:	2110      	movs	r1, #16
 800615a:	4668      	mov	r0, sp
 800615c:	f7ff fc28 	bl	80059b0 <rcvr_datablock>
 8006160:	2800      	cmp	r0, #0
 8006162:	d0b9      	beq.n	80060d8 <USER_ioctl+0x3c>
			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
 8006164:	f89d 3000 	ldrb.w	r3, [sp]
 8006168:	099b      	lsrs	r3, r3, #6
 800616a:	2b01      	cmp	r3, #1
 800616c:	f000 80c3 	beq.w	80062f6 <USER_ioctl+0x25a>
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 8006170:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006174:	f89d 0006 	ldrb.w	r0, [sp, #6]
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 8006178:	f89d 2005 	ldrb.w	r2, [sp, #5]
 800617c:	f89d 1009 	ldrb.w	r1, [sp, #9]
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 8006180:	f89d 7008 	ldrb.w	r7, [sp, #8]
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 8006184:	f89d 600a 	ldrb.w	r6, [sp, #10]
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 8006188:	009b      	lsls	r3, r3, #2
 800618a:	0280      	lsls	r0, r0, #10
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 800618c:	f002 020f 	and.w	r2, r2, #15
 8006190:	0049      	lsls	r1, r1, #1
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 8006192:	eb03 1397 	add.w	r3, r3, r7, lsr #6
 8006196:	f400 6040 	and.w	r0, r0, #3072	; 0xc00
				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 800619a:	eb02 12d6 	add.w	r2, r2, r6, lsr #7
 800619e:	f001 0106 	and.w	r1, r1, #6
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 80061a2:	4403      	add	r3, r0
				*(DWORD*)buff = csize << (n - 9);
 80061a4:	440a      	add	r2, r1
				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 80061a6:	3301      	adds	r3, #1
				*(DWORD*)buff = csize << (n - 9);
 80061a8:	3a07      	subs	r2, #7
 80061aa:	4093      	lsls	r3, r2
 80061ac:	602b      	str	r3, [r5, #0]
 80061ae:	e794      	b.n	80060da <USER_ioctl+0x3e>
	SD_CS_LOW;										/* Set CS# low */
 80061b0:	4961      	ldr	r1, [pc, #388]	; (8006338 <USER_ioctl+0x29c>)
	SPIx->DR=dat;
 80061b2:	4b62      	ldr	r3, [pc, #392]	; (800633c <USER_ioctl+0x2a0>)
	SD_CS_LOW;										/* Set CS# low */
 80061b4:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	SPIx->DR=dat;
 80061b8:	22ff      	movs	r2, #255	; 0xff
	SD_CS_LOW;										/* Set CS# low */
 80061ba:	6188      	str	r0, [r1, #24]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80061bc:	4619      	mov	r1, r3
	SPIx->DR=dat;
 80061be:	60da      	str	r2, [r3, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80061c0:	688b      	ldr	r3, [r1, #8]
 80061c2:	f003 0383 	and.w	r3, r3, #131	; 0x83
 80061c6:	2b03      	cmp	r3, #3
 80061c8:	d1fa      	bne.n	80061c0 <USER_ioctl+0x124>
	Timer2 = wt;
 80061ca:	485d      	ldr	r0, [pc, #372]	; (8006340 <USER_ioctl+0x2a4>)
	return (BYTE)(SPIx->DR);					/* Return received byte */
 80061cc:	68cb      	ldr	r3, [r1, #12]
	SPIx->DR=dat;
 80061ce:	4a5b      	ldr	r2, [pc, #364]	; (800633c <USER_ioctl+0x2a0>)
	Timer2 = wt;
 80061d0:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 80061d4:	6003      	str	r3, [r0, #0]
	SPIx->DR=dat;
 80061d6:	21ff      	movs	r1, #255	; 0xff
 80061d8:	60d1      	str	r1, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80061da:	6893      	ldr	r3, [r2, #8]
 80061dc:	f003 0383 	and.w	r3, r3, #131	; 0x83
 80061e0:	2b03      	cmp	r3, #3
 80061e2:	d1fa      	bne.n	80061da <USER_ioctl+0x13e>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 80061e4:	68d3      	ldr	r3, [r2, #12]
	} while (d != 0xFF && Timer2);				/* Wait for card goes ready or timeout */
 80061e6:	b2db      	uxtb	r3, r3
 80061e8:	2bff      	cmp	r3, #255	; 0xff
 80061ea:	d012      	beq.n	8006212 <USER_ioctl+0x176>
 80061ec:	6803      	ldr	r3, [r0, #0]
 80061ee:	2b00      	cmp	r3, #0
 80061f0:	d1f2      	bne.n	80061d8 <USER_ioctl+0x13c>
	SD_CS_HIGH;									/* Set CS# high */
 80061f2:	4851      	ldr	r0, [pc, #324]	; (8006338 <USER_ioctl+0x29c>)
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80061f4:	4951      	ldr	r1, [pc, #324]	; (800633c <USER_ioctl+0x2a0>)
	SD_CS_HIGH;									/* Set CS# high */
 80061f6:	2401      	movs	r4, #1
	SPIx->DR=dat;
 80061f8:	23ff      	movs	r3, #255	; 0xff
	SD_CS_HIGH;									/* Set CS# high */
 80061fa:	6184      	str	r4, [r0, #24]
	SPIx->DR=dat;
 80061fc:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80061fe:	688b      	ldr	r3, [r1, #8]
 8006200:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8006204:	2b03      	cmp	r3, #3
 8006206:	d1fa      	bne.n	80061fe <USER_ioctl+0x162>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8006208:	68cb      	ldr	r3, [r1, #12]
	res = RES_ERROR;
 800620a:	2401      	movs	r4, #1
 800620c:	e765      	b.n	80060da <USER_ioctl+0x3e>
		res = RES_PARERR;
 800620e:	2404      	movs	r4, #4
 8006210:	e763      	b.n	80060da <USER_ioctl+0x3e>
		if (sel()) res = RES_OK;
 8006212:	2400      	movs	r4, #0
 8006214:	e761      	b.n	80060da <USER_ioctl+0x3e>
			if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
 8006216:	2100      	movs	r1, #0
 8006218:	208d      	movs	r0, #141	; 0x8d
 800621a:	f7ff fc73 	bl	8005b04 <send_cmd>
 800621e:	2800      	cmp	r0, #0
 8006220:	f47f af5a 	bne.w	80060d8 <USER_ioctl+0x3c>
	SPIx->DR=dat;
 8006224:	4a45      	ldr	r2, [pc, #276]	; (800633c <USER_ioctl+0x2a0>)
 8006226:	23ff      	movs	r3, #255	; 0xff
 8006228:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 800622a:	6893      	ldr	r3, [r2, #8]
 800622c:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8006230:	2b03      	cmp	r3, #3
 8006232:	d1fa      	bne.n	800622a <USER_ioctl+0x18e>
				if (rcvr_datablock(csd, 16)) {				/* Read partial block */
 8006234:	2110      	movs	r1, #16
 8006236:	4668      	mov	r0, sp
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8006238:	68d3      	ldr	r3, [r2, #12]
				if (rcvr_datablock(csd, 16)) {				/* Read partial block */
 800623a:	f7ff fbb9 	bl	80059b0 <rcvr_datablock>
 800623e:	2800      	cmp	r0, #0
 8006240:	f43f af4a 	beq.w	80060d8 <USER_ioctl+0x3c>
	SPIx->DR=dat;
 8006244:	493d      	ldr	r1, [pc, #244]	; (800633c <USER_ioctl+0x2a0>)
				if (rcvr_datablock(csd, 16)) {				/* Read partial block */
 8006246:	2430      	movs	r4, #48	; 0x30
	SPIx->DR=dat;
 8006248:	22ff      	movs	r2, #255	; 0xff
 800624a:	60ca      	str	r2, [r1, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 800624c:	688b      	ldr	r3, [r1, #8]
 800624e:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8006252:	2b03      	cmp	r3, #3
 8006254:	d1fa      	bne.n	800624c <USER_ioctl+0x1b0>
 8006256:	3c01      	subs	r4, #1
					for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
 8006258:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
	return (BYTE)(SPIx->DR);					/* Return received byte */
 800625c:	68cb      	ldr	r3, [r1, #12]
					for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
 800625e:	d1f4      	bne.n	800624a <USER_ioctl+0x1ae>
					*(DWORD*)buff = 16UL << (csd[10] >> 4);
 8006260:	f89d 200a 	ldrb.w	r2, [sp, #10]
 8006264:	2310      	movs	r3, #16
 8006266:	0912      	lsrs	r2, r2, #4
 8006268:	4093      	lsls	r3, r2
 800626a:	602b      	str	r3, [r5, #0]
 800626c:	e735      	b.n	80060da <USER_ioctl+0x3e>
		if (disk_ioctl(pdrv, MMC_GET_CSD, csd)) break;	/* Get CSD */
 800626e:	466a      	mov	r2, sp
 8006270:	210b      	movs	r1, #11
 8006272:	2000      	movs	r0, #0
 8006274:	f7fb f844 	bl	8001300 <disk_ioctl>
 8006278:	4604      	mov	r4, r0
 800627a:	2800      	cmp	r0, #0
 800627c:	f47f af2c 	bne.w	80060d8 <USER_ioctl+0x3c>
		if (!(csd[0] >> 6) && !(csd[10] & 0x40)) break;	/* Check if sector erase can be applied to the card */
 8006280:	f89d 3000 	ldrb.w	r3, [sp]
 8006284:	099b      	lsrs	r3, r3, #6
 8006286:	d104      	bne.n	8006292 <USER_ioctl+0x1f6>
 8006288:	f89d 300a 	ldrb.w	r3, [sp, #10]
 800628c:	065a      	lsls	r2, r3, #25
 800628e:	f57f af23 	bpl.w	80060d8 <USER_ioctl+0x3c>
		dp = buff; st = dp[0]; ed = dp[1];				/* Load sector block */
 8006292:	e9d5 1500 	ldrd	r1, r5, [r5]
		if (!(CardType & CT_BLOCK)) {
 8006296:	7833      	ldrb	r3, [r6, #0]
 8006298:	071b      	lsls	r3, r3, #28
			st *= 512; ed *= 512;
 800629a:	bf58      	it	pl
 800629c:	0249      	lslpl	r1, r1, #9
		if (send_cmd(CMD32, st) == 0 && send_cmd(CMD33, ed) == 0 && send_cmd(CMD38, 0) == 0 && wait_ready(30000)) {	/* Erase sector block */
 800629e:	f04f 0020 	mov.w	r0, #32
			st *= 512; ed *= 512;
 80062a2:	bf58      	it	pl
 80062a4:	026d      	lslpl	r5, r5, #9
		if (send_cmd(CMD32, st) == 0 && send_cmd(CMD33, ed) == 0 && send_cmd(CMD38, 0) == 0 && wait_ready(30000)) {	/* Erase sector block */
 80062a6:	f7ff fc2d 	bl	8005b04 <send_cmd>
 80062aa:	2800      	cmp	r0, #0
 80062ac:	f47f af14 	bne.w	80060d8 <USER_ioctl+0x3c>
 80062b0:	4629      	mov	r1, r5
 80062b2:	2021      	movs	r0, #33	; 0x21
 80062b4:	f7ff fc26 	bl	8005b04 <send_cmd>
 80062b8:	4601      	mov	r1, r0
 80062ba:	2800      	cmp	r0, #0
 80062bc:	f47f af0c 	bne.w	80060d8 <USER_ioctl+0x3c>
 80062c0:	2026      	movs	r0, #38	; 0x26
 80062c2:	f7ff fc1f 	bl	8005b04 <send_cmd>
 80062c6:	2800      	cmp	r0, #0
 80062c8:	f47f af06 	bne.w	80060d8 <USER_ioctl+0x3c>
	Timer2 = wt;
 80062cc:	481c      	ldr	r0, [pc, #112]	; (8006340 <USER_ioctl+0x2a4>)
	SPIx->DR=dat;
 80062ce:	4a1b      	ldr	r2, [pc, #108]	; (800633c <USER_ioctl+0x2a0>)
	Timer2 = wt;
 80062d0:	f247 5330 	movw	r3, #30000	; 0x7530
 80062d4:	6003      	str	r3, [r0, #0]
	SPIx->DR=dat;
 80062d6:	21ff      	movs	r1, #255	; 0xff
 80062d8:	60d1      	str	r1, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80062da:	6893      	ldr	r3, [r2, #8]
 80062dc:	f003 0383 	and.w	r3, r3, #131	; 0x83
 80062e0:	2b03      	cmp	r3, #3
 80062e2:	d1fa      	bne.n	80062da <USER_ioctl+0x23e>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 80062e4:	68d3      	ldr	r3, [r2, #12]
	} while (d != 0xFF && Timer2);				/* Wait for card goes ready or timeout */
 80062e6:	b2db      	uxtb	r3, r3
 80062e8:	2bff      	cmp	r3, #255	; 0xff
 80062ea:	f43f aef6 	beq.w	80060da <USER_ioctl+0x3e>
 80062ee:	6803      	ldr	r3, [r0, #0]
 80062f0:	2b00      	cmp	r3, #0
 80062f2:	d1f1      	bne.n	80062d8 <USER_ioctl+0x23c>
 80062f4:	e6f0      	b.n	80060d8 <USER_ioctl+0x3c>
				csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
 80062f6:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80062fa:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80062fe:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8006302:	0412      	lsls	r2, r2, #16
 8006304:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
 8006308:	3201      	adds	r2, #1
 800630a:	eb03 2301 	add.w	r3, r3, r1, lsl #8
 800630e:	4413      	add	r3, r2
				*(DWORD*)buff = csize << 10;
 8006310:	029b      	lsls	r3, r3, #10
 8006312:	602b      	str	r3, [r5, #0]
 8006314:	e6e1      	b.n	80060da <USER_ioctl+0x3e>
					*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
 8006316:	00ca      	lsls	r2, r1, #3
 8006318:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800631c:	f002 0218 	and.w	r2, r2, #24
 8006320:	3301      	adds	r3, #1
 8006322:	eb02 1251 	add.w	r2, r2, r1, lsr #5
 8006326:	fb02 3303 	mla	r3, r2, r3, r3
 800632a:	602b      	str	r3, [r5, #0]
 800632c:	e6d5      	b.n	80060da <USER_ioctl+0x3e>
 800632e:	bf00      	nop
 8006330:	2000000c 	.word	0x2000000c
 8006334:	20004080 	.word	0x20004080
 8006338:	40020400 	.word	0x40020400
 800633c:	40003800 	.word	0x40003800
 8006340:	20004088 	.word	0x20004088

08006344 <USER_write>:
	if (pdrv || !count) return RES_PARERR;		/* Check parameter */
 8006344:	2800      	cmp	r0, #0
 8006346:	d159      	bne.n	80063fc <USER_write+0xb8>
{ 
 8006348:	b5f0      	push	{r4, r5, r6, r7, lr}
 800634a:	461d      	mov	r5, r3
 800634c:	b083      	sub	sp, #12
	if (pdrv || !count) return RES_PARERR;		/* Check parameter */
 800634e:	2b00      	cmp	r3, #0
 8006350:	d051      	beq.n	80063f6 <USER_write+0xb2>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check drive status */
 8006352:	4b54      	ldr	r3, [pc, #336]	; (80064a4 <USER_write+0x160>)
 8006354:	460e      	mov	r6, r1
 8006356:	7819      	ldrb	r1, [r3, #0]
 8006358:	07cc      	lsls	r4, r1, #31
 800635a:	d465      	bmi.n	8006428 <USER_write+0xe4>
	if (Stat & STA_PROTECT) return RES_WRPRT;	/* Check write protect */
 800635c:	781b      	ldrb	r3, [r3, #0]
 800635e:	0758      	lsls	r0, r3, #29
 8006360:	d465      	bmi.n	800642e <USER_write+0xea>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* LBA ==> BA conversion (byte addressing cards) */
 8006362:	4b51      	ldr	r3, [pc, #324]	; (80064a8 <USER_write+0x164>)
 8006364:	781b      	ldrb	r3, [r3, #0]
 8006366:	0719      	lsls	r1, r3, #28
 8006368:	bf58      	it	pl
 800636a:	0252      	lslpl	r2, r2, #9
	if (count == 1) {	/* Single sector write */
 800636c:	2d01      	cmp	r5, #1
 800636e:	d061      	beq.n	8006434 <USER_write+0xf0>
		if (CardType & CT_SDC) send_cmd(ACMD23, count);	/* Predefine number of sectors */
 8006370:	f013 0f06 	tst.w	r3, #6
 8006374:	d005      	beq.n	8006382 <USER_write+0x3e>
 8006376:	4629      	mov	r1, r5
 8006378:	2097      	movs	r0, #151	; 0x97
 800637a:	9201      	str	r2, [sp, #4]
 800637c:	f7ff fbc2 	bl	8005b04 <send_cmd>
 8006380:	9a01      	ldr	r2, [sp, #4]
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
 8006382:	4611      	mov	r1, r2
 8006384:	2019      	movs	r0, #25
 8006386:	f7ff fbbd 	bl	8005b04 <send_cmd>
 800638a:	bb20      	cbnz	r0, 80063d6 <USER_write+0x92>
 800638c:	4f47      	ldr	r7, [pc, #284]	; (80064ac <USER_write+0x168>)
	SPIx->DR=dat;
 800638e:	4c48      	ldr	r4, [pc, #288]	; (80064b0 <USER_write+0x16c>)
 8006390:	21ff      	movs	r1, #255	; 0xff
	Timer2 = wt;
 8006392:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8006396:	603b      	str	r3, [r7, #0]
	SPIx->DR=dat;
 8006398:	60e1      	str	r1, [r4, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 800639a:	68a2      	ldr	r2, [r4, #8]
 800639c:	f002 0283 	and.w	r2, r2, #131	; 0x83
 80063a0:	2a03      	cmp	r2, #3
 80063a2:	d1fa      	bne.n	800639a <USER_write+0x56>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 80063a4:	68e2      	ldr	r2, [r4, #12]
	} while (d != 0xFF && Timer2);				/* Wait for card goes ready or timeout */
 80063a6:	b2d2      	uxtb	r2, r2
 80063a8:	2aff      	cmp	r2, #255	; 0xff
 80063aa:	d029      	beq.n	8006400 <USER_write+0xbc>
 80063ac:	683a      	ldr	r2, [r7, #0]
 80063ae:	2a00      	cmp	r2, #0
 80063b0:	d1f2      	bne.n	8006398 <USER_write+0x54>
	Timer2 = wt;
 80063b2:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
	SPIx->DR=dat;
 80063b6:	4b3e      	ldr	r3, [pc, #248]	; (80064b0 <USER_write+0x16c>)
	Timer2 = wt;
 80063b8:	603a      	str	r2, [r7, #0]
	SPIx->DR=dat;
 80063ba:	21ff      	movs	r1, #255	; 0xff
 80063bc:	60d9      	str	r1, [r3, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80063be:	689a      	ldr	r2, [r3, #8]
 80063c0:	f002 0283 	and.w	r2, r2, #131	; 0x83
 80063c4:	2a03      	cmp	r2, #3
 80063c6:	d1fa      	bne.n	80063be <USER_write+0x7a>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 80063c8:	68da      	ldr	r2, [r3, #12]
	} while (d != 0xFF && Timer2);				/* Wait for card goes ready or timeout */
 80063ca:	b2d2      	uxtb	r2, r2
 80063cc:	2aff      	cmp	r2, #255	; 0xff
 80063ce:	d04b      	beq.n	8006468 <USER_write+0x124>
 80063d0:	683a      	ldr	r2, [r7, #0]
 80063d2:	2a00      	cmp	r2, #0
 80063d4:	d1f2      	bne.n	80063bc <USER_write+0x78>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
 80063d6:	2001      	movs	r0, #1
	SD_CS_HIGH;									/* Set CS# high */
 80063d8:	4a36      	ldr	r2, [pc, #216]	; (80064b4 <USER_write+0x170>)
	SPIx->DR=dat;
 80063da:	4b35      	ldr	r3, [pc, #212]	; (80064b0 <USER_write+0x16c>)
	SD_CS_HIGH;									/* Set CS# high */
 80063dc:	2401      	movs	r4, #1
	SPIx->DR=dat;
 80063de:	21ff      	movs	r1, #255	; 0xff
	SD_CS_HIGH;									/* Set CS# high */
 80063e0:	6194      	str	r4, [r2, #24]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80063e2:	461a      	mov	r2, r3
	SPIx->DR=dat;
 80063e4:	60d9      	str	r1, [r3, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 80063e6:	6893      	ldr	r3, [r2, #8]
 80063e8:	f003 0383 	and.w	r3, r3, #131	; 0x83
 80063ec:	2b03      	cmp	r3, #3
 80063ee:	d1fa      	bne.n	80063e6 <USER_write+0xa2>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 80063f0:	68d3      	ldr	r3, [r2, #12]
}
 80063f2:	b003      	add	sp, #12
 80063f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (pdrv || !count) return RES_PARERR;		/* Check parameter */
 80063f6:	2004      	movs	r0, #4
}
 80063f8:	b003      	add	sp, #12
 80063fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (pdrv || !count) return RES_PARERR;		/* Check parameter */
 80063fc:	2004      	movs	r0, #4
}
 80063fe:	4770      	bx	lr
	SPIx->DR=dat;
 8006400:	23fc      	movs	r3, #252	; 0xfc
 8006402:	60e3      	str	r3, [r4, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8006404:	68a3      	ldr	r3, [r4, #8]
 8006406:	f003 0383 	and.w	r3, r3, #131	; 0x83
 800640a:	2b03      	cmp	r3, #3
 800640c:	d1fa      	bne.n	8006404 <USER_write+0xc0>
 800640e:	4630      	mov	r0, r6
 8006410:	9101      	str	r1, [sp, #4]
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8006412:	68e3      	ldr	r3, [r4, #12]
 8006414:	f7ff fb26 	bl	8005a64 <xmit_datablock.part.2>
				if (!xmit_datablock(buff, 0xFC)) break;
 8006418:	2800      	cmp	r0, #0
 800641a:	d0ca      	beq.n	80063b2 <USER_write+0x6e>
			} while (--count);
 800641c:	3d01      	subs	r5, #1
				buff += 512;
 800641e:	f506 7600 	add.w	r6, r6, #512	; 0x200
			} while (--count);
 8006422:	9901      	ldr	r1, [sp, #4]
 8006424:	d1b5      	bne.n	8006392 <USER_write+0x4e>
 8006426:	e7c4      	b.n	80063b2 <USER_write+0x6e>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check drive status */
 8006428:	2003      	movs	r0, #3
}
 800642a:	b003      	add	sp, #12
 800642c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (Stat & STA_PROTECT) return RES_WRPRT;	/* Check write protect */
 800642e:	2002      	movs	r0, #2
}
 8006430:	b003      	add	sp, #12
 8006432:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
 8006434:	4611      	mov	r1, r2
 8006436:	2018      	movs	r0, #24
 8006438:	f7ff fb64 	bl	8005b04 <send_cmd>
 800643c:	2800      	cmp	r0, #0
 800643e:	d1ca      	bne.n	80063d6 <USER_write+0x92>
	Timer2 = wt;
 8006440:	4f1a      	ldr	r7, [pc, #104]	; (80064ac <USER_write+0x168>)
	SPIx->DR=dat;
 8006442:	4a1b      	ldr	r2, [pc, #108]	; (80064b0 <USER_write+0x16c>)
	Timer2 = wt;
 8006444:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8006448:	603b      	str	r3, [r7, #0]
	SPIx->DR=dat;
 800644a:	21ff      	movs	r1, #255	; 0xff
 800644c:	60d1      	str	r1, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 800644e:	6893      	ldr	r3, [r2, #8]
 8006450:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8006454:	2b03      	cmp	r3, #3
 8006456:	d1fa      	bne.n	800644e <USER_write+0x10a>
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8006458:	68d3      	ldr	r3, [r2, #12]
	} while (d != 0xFF && Timer2);				/* Wait for card goes ready or timeout */
 800645a:	b2db      	uxtb	r3, r3
 800645c:	2bff      	cmp	r3, #255	; 0xff
 800645e:	d010      	beq.n	8006482 <USER_write+0x13e>
 8006460:	683b      	ldr	r3, [r7, #0]
 8006462:	2b00      	cmp	r3, #0
 8006464:	d1f2      	bne.n	800644c <USER_write+0x108>
 8006466:	e7b6      	b.n	80063d6 <USER_write+0x92>
	SPIx->DR=dat;
 8006468:	22fd      	movs	r2, #253	; 0xfd
 800646a:	60da      	str	r2, [r3, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 800646c:	4a10      	ldr	r2, [pc, #64]	; (80064b0 <USER_write+0x16c>)
 800646e:	6893      	ldr	r3, [r2, #8]
 8006470:	f003 0383 	and.w	r3, r3, #131	; 0x83
 8006474:	2b03      	cmp	r3, #3
 8006476:	d1fa      	bne.n	800646e <USER_write+0x12a>
 8006478:	1c28      	adds	r0, r5, #0
	return (BYTE)(SPIx->DR);					/* Return received byte */
 800647a:	68d3      	ldr	r3, [r2, #12]
 800647c:	bf18      	it	ne
 800647e:	2001      	movne	r0, #1
 8006480:	e7aa      	b.n	80063d8 <USER_write+0x94>
	SPIx->DR=dat;
 8006482:	23fe      	movs	r3, #254	; 0xfe
 8006484:	60d3      	str	r3, [r2, #12]
	while ((SPIx->SR&SPI_FLAGS)!=SPI_RxTx);
 8006486:	4a0a      	ldr	r2, [pc, #40]	; (80064b0 <USER_write+0x16c>)
 8006488:	6893      	ldr	r3, [r2, #8]
 800648a:	f003 0383 	and.w	r3, r3, #131	; 0x83
 800648e:	2b03      	cmp	r3, #3
 8006490:	d1fa      	bne.n	8006488 <USER_write+0x144>
 8006492:	4630      	mov	r0, r6
	return (BYTE)(SPIx->DR);					/* Return received byte */
 8006494:	68d3      	ldr	r3, [r2, #12]
 8006496:	f7ff fae5 	bl	8005a64 <xmit_datablock.part.2>
 800649a:	fab0 f080 	clz	r0, r0
 800649e:	0940      	lsrs	r0, r0, #5
 80064a0:	e79a      	b.n	80063d8 <USER_write+0x94>
 80064a2:	bf00      	nop
 80064a4:	2000000c 	.word	0x2000000c
 80064a8:	20004080 	.word	0x20004080
 80064ac:	20004088 	.word	0x20004088
 80064b0:	40003800 	.word	0x40003800
 80064b4:	40020400 	.word	0x40020400

080064b8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80064b8:	f8df d034 	ldr.w	sp, [pc, #52]	; 80064f0 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80064bc:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80064be:	e003      	b.n	80064c8 <LoopCopyDataInit>

080064c0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80064c0:	4b0c      	ldr	r3, [pc, #48]	; (80064f4 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80064c2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80064c4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80064c6:	3104      	adds	r1, #4

080064c8 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80064c8:	480b      	ldr	r0, [pc, #44]	; (80064f8 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80064ca:	4b0c      	ldr	r3, [pc, #48]	; (80064fc <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80064cc:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80064ce:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80064d0:	d3f6      	bcc.n	80064c0 <CopyDataInit>
  ldr  r2, =_sbss
 80064d2:	4a0b      	ldr	r2, [pc, #44]	; (8006500 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80064d4:	e002      	b.n	80064dc <LoopFillZerobss>

080064d6 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80064d6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80064d8:	f842 3b04 	str.w	r3, [r2], #4

080064dc <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80064dc:	4b09      	ldr	r3, [pc, #36]	; (8006504 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80064de:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80064e0:	d3f9      	bcc.n	80064d6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80064e2:	f7ff fa33 	bl	800594c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80064e6:	f000 ff8b 	bl	8007400 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80064ea:	f7ff f911 	bl	8005710 <main>
  bx  lr    
 80064ee:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 80064f0:	2001ffff 	.word	0x2001ffff
  ldr  r3, =_sidata
 80064f4:	080081d0 	.word	0x080081d0
  ldr  r0, =_sdata
 80064f8:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 80064fc:	2000008c 	.word	0x2000008c
  ldr  r2, =_sbss
 8006500:	2000008c 	.word	0x2000008c
  ldr  r3, = _ebss
 8006504:	20008fcc 	.word	0x20008fcc

08006508 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8006508:	e7fe      	b.n	8006508 <ADC_IRQHandler>
	...

0800650c <refreshDisplay>:
{

    uint32_t pixel, x_offset,y_offset;
    uint8_t row, column, segment, cBit, panel_x, panel_y;
    
    for(cBit=0; cBit<(BITS_PER_CHANNEL); cBit++)
 800650c:	4baf      	ldr	r3, [pc, #700]	; (80067cc <refreshDisplay+0x2c0>)
 800650e:	781b      	ldrb	r3, [r3, #0]
 8006510:	2b00      	cmp	r3, #0
 8006512:	f000 8159 	beq.w	80067c8 <refreshDisplay+0x2bc>
{
 8006516:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    for(cBit=0; cBit<(BITS_PER_CHANNEL); cBit++)
 800651a:	f04f 0b00 	mov.w	fp, #0
    B((x&0x02)>>1);
 800651e:	f8df 92bc 	ldr.w	r9, [pc, #700]	; 80067dc <refreshDisplay+0x2d0>
    R2(rCh(getFRAMEpx(px))>>i);
 8006522:	f8df 82bc 	ldr.w	r8, [pc, #700]	; 80067e0 <refreshDisplay+0x2d4>
{
 8006526:	b08b      	sub	sp, #44	; 0x2c
   CLK_LOW;
 8006528:	46de      	mov	lr, fp
 800652a:	4ba9      	ldr	r3, [pc, #676]	; (80067d0 <refreshDisplay+0x2c4>)
 800652c:	9308      	str	r3, [sp, #32]
    for(cBit=0; cBit<(BITS_PER_CHANNEL); cBit++)
 800652e:	2300      	movs	r3, #0
 8006530:	9309      	str	r3, [sp, #36]	; 0x24
 8006532:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8006534:	b2eb      	uxtb	r3, r5
    B((x&0x02)>>1);
 8006536:	f003 0002 	and.w	r0, r3, #2
    C((x&0x04)>>2);
 800653a:	f003 0104 	and.w	r1, r3, #4
    B((x&0x02)>>1);
 800653e:	43c0      	mvns	r0, r0
    C((x&0x04)>>2);
 8006540:	43c9      	mvns	r1, r1
    B((x&0x02)>>1);
 8006542:	0540      	lsls	r0, r0, #21
 8006544:	016a      	lsls	r2, r5, #5
 8006546:	f002 0240 	and.w	r2, r2, #64	; 0x40
    C((x&0x04)>>2);
 800654a:	0589      	lsls	r1, r1, #22
    B((x&0x02)>>1);
 800654c:	f400 0080 	and.w	r0, r0, #4194304	; 0x400000
    A(x&0x01);
 8006550:	f013 0f01 	tst.w	r3, #1
    C((x&0x04)>>2);
 8006554:	f001 7180 	and.w	r1, r1, #16777216	; 0x1000000
    B((x&0x02)>>1);
 8006558:	ea40 0002 	orr.w	r0, r0, r2
    A(x&0x01);
 800655c:	ea4f 2345 	mov.w	r3, r5, lsl #9
    C((x&0x04)>>2);
 8006560:	ea4f 02a5 	mov.w	r2, r5, asr #2
 8006564:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
    A(x&0x01);
 8006568:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800656c:	4999      	ldr	r1, [pc, #612]	; (80067d4 <refreshDisplay+0x2c8>)
 800656e:	bf14      	ite	ne
 8006570:	2400      	movne	r4, #0
 8006572:	f04f 7400 	moveq.w	r4, #33554432	; 0x2000000
 8006576:	4323      	orrs	r3, r4
 8006578:	618b      	str	r3, [r1, #24]
    C((x&0x04)>>2);
 800657a:	9b08      	ldr	r3, [sp, #32]
 800657c:	9306      	str	r3, [sp, #24]
       {
    	   selectRow(row);
            y_offset=(row*DISPLAY_WIDTH);   
            for(panel_y=0;panel_y<NUM_OF_PANELS_Y;panel_y++)
            {
                x_offset=0;
 800657e:	2300      	movs	r3, #0
    B((x&0x02)>>1);
 8006580:	f8c9 0018 	str.w	r0, [r9, #24]
                x_offset=0;
 8006584:	9307      	str	r3, [sp, #28]
    C((x&0x04)>>2);
 8006586:	618a      	str	r2, [r1, #24]
 8006588:	9b06      	ldr	r3, [sp, #24]
 800658a:	9304      	str	r3, [sp, #16]
 800658c:	2302      	movs	r3, #2
 800658e:	9305      	str	r3, [sp, #20]
 8006590:	9b04      	ldr	r3, [sp, #16]
 8006592:	9300      	str	r3, [sp, #0]
 8006594:	f503 5210 	add.w	r2, r3, #9216	; 0x2400
 8006598:	9201      	str	r2, [sp, #4]
 800659a:	f503 5293 	add.w	r2, r3, #4704	; 0x1260
 800659e:	f503 5a90 	add.w	sl, r3, #4608	; 0x1200
 80065a2:	f503 5b58 	add.w	fp, r3, #13824	; 0x3600
 80065a6:	9203      	str	r2, [sp, #12]
    R1(rCh(getFRAMEpx(px))>>i);
 80065a8:	9b00      	ldr	r3, [sp, #0]
    R2(rCh(getFRAMEpx(px))>>i);
 80065aa:	f89a 2002 	ldrb.w	r2, [sl, #2]
    R1(rCh(getFRAMEpx(px))>>i);
 80065ae:	f893 c002 	ldrb.w	ip, [r3, #2]
    G1(gCh(getFRAMEpx(px))>>i);
 80065b2:	7858      	ldrb	r0, [r3, #1]
    B1(bCh(getFRAMEpx(px))>>i);
 80065b4:	f813 1b03 	ldrb.w	r1, [r3], #3
 80065b8:	9300      	str	r3, [sp, #0]
    R1(rCh(getFRAMEpx(px))>>i);
 80065ba:	ea6f 040c 	mvn.w	r4, ip
 80065be:	fa44 f40e 	asr.w	r4, r4, lr
 80065c2:	fa4c fc0e 	asr.w	ip, ip, lr
    G2(gCh(getFRAMEpx(px))>>i);
 80065c6:	f89a 3001 	ldrb.w	r3, [sl, #1]
 80065ca:	9302      	str	r3, [sp, #8]
    R1(rCh(getFRAMEpx(px))>>i);
 80065cc:	07a4      	lsls	r4, r4, #30
 80065ce:	ea4f 3c8c 	mov.w	ip, ip, lsl #14
    R3(rCh(getFRAMEpx(px))>>i);
 80065d2:	9b01      	ldr	r3, [sp, #4]
    B2(bCh(getFRAMEpx(px))>>i);
 80065d4:	f81a 7b03 	ldrb.w	r7, [sl], #3
    R3(rCh(getFRAMEpx(px))>>i);
 80065d8:	789e      	ldrb	r6, [r3, #2]
    G3(gCh(getFRAMEpx(px))>>i);
 80065da:	785d      	ldrb	r5, [r3, #1]
    R1(rCh(getFRAMEpx(px))>>i);
 80065dc:	f40c 4c80 	and.w	ip, ip, #16384	; 0x4000
 80065e0:	f004 4480 	and.w	r4, r4, #1073741824	; 0x40000000
 80065e4:	ea44 040c 	orr.w	r4, r4, ip
 80065e8:	f8c9 4018 	str.w	r4, [r9, #24]
    G1(gCh(getFRAMEpx(px))>>i);
 80065ec:	43c4      	mvns	r4, r0
 80065ee:	fa44 f40e 	asr.w	r4, r4, lr
 80065f2:	fa40 f00e 	asr.w	r0, r0, lr
 80065f6:	0524      	lsls	r4, r4, #20
 80065f8:	0100      	lsls	r0, r0, #4
 80065fa:	f404 1480 	and.w	r4, r4, #1048576	; 0x100000
 80065fe:	f000 0010 	and.w	r0, r0, #16
 8006602:	4320      	orrs	r0, r4
    B3(bCh(getFRAMEpx(px))>>i);
 8006604:	f813 4b03 	ldrb.w	r4, [r3], #3
 8006608:	9301      	str	r3, [sp, #4]
    G1(gCh(getFRAMEpx(px))>>i);
 800660a:	f8c9 0018 	str.w	r0, [r9, #24]
    B1(bCh(getFRAMEpx(px))>>i);
 800660e:	43c8      	mvns	r0, r1
 8006610:	fa40 f00e 	asr.w	r0, r0, lr
 8006614:	fa41 f10e 	asr.w	r1, r1, lr
 8006618:	0740      	lsls	r0, r0, #29
 800661a:	0349      	lsls	r1, r1, #13
 800661c:	f000 5000 	and.w	r0, r0, #536870912	; 0x20000000
 8006620:	f401 5100 	and.w	r1, r1, #8192	; 0x2000
 8006624:	4301      	orrs	r1, r0
    R4(rCh(getFRAMEpx(px))>>i);
 8006626:	f89b 0002 	ldrb.w	r0, [fp, #2]
    B1(bCh(getFRAMEpx(px))>>i);
 800662a:	f8c9 1018 	str.w	r1, [r9, #24]
    R2(rCh(getFRAMEpx(px))>>i);
 800662e:	43d1      	mvns	r1, r2
 8006630:	fa41 f10e 	asr.w	r1, r1, lr
 8006634:	fa42 f20e 	asr.w	r2, r2, lr
 8006638:	0509      	lsls	r1, r1, #20
 800663a:	0112      	lsls	r2, r2, #4
    G2(gCh(getFRAMEpx(px))>>i);
 800663c:	9b02      	ldr	r3, [sp, #8]
    R2(rCh(getFRAMEpx(px))>>i);
 800663e:	f401 1180 	and.w	r1, r1, #1048576	; 0x100000
 8006642:	f002 0210 	and.w	r2, r2, #16
 8006646:	430a      	orrs	r2, r1
    G4(gCh(getFRAMEpx(px))>>i);
 8006648:	f89b 1001 	ldrb.w	r1, [fp, #1]
    R2(rCh(getFRAMEpx(px))>>i);
 800664c:	f8c8 2018 	str.w	r2, [r8, #24]
    G2(gCh(getFRAMEpx(px))>>i);
 8006650:	43da      	mvns	r2, r3
 8006652:	fa42 f20e 	asr.w	r2, r2, lr
 8006656:	fa43 f30e 	asr.w	r3, r3, lr
 800665a:	0552      	lsls	r2, r2, #21
 800665c:	015b      	lsls	r3, r3, #5
 800665e:	f402 1200 	and.w	r2, r2, #2097152	; 0x200000
 8006662:	f003 0320 	and.w	r3, r3, #32
 8006666:	4313      	orrs	r3, r2
    B4(bCh(getFRAMEpx(px))>>i);
 8006668:	f81b 2b03 	ldrb.w	r2, [fp], #3
    G2(gCh(getFRAMEpx(px))>>i);
 800666c:	f8c9 3018 	str.w	r3, [r9, #24]
    B2(bCh(getFRAMEpx(px))>>i);
 8006670:	43fb      	mvns	r3, r7
 8006672:	fa43 f30e 	asr.w	r3, r3, lr
 8006676:	fa47 f70e 	asr.w	r7, r7, lr
 800667a:	055b      	lsls	r3, r3, #21
 800667c:	017f      	lsls	r7, r7, #5
 800667e:	f007 0720 	and.w	r7, r7, #32
 8006682:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8006686:	433b      	orrs	r3, r7
 8006688:	f8c8 3018 	str.w	r3, [r8, #24]
    R3(rCh(getFRAMEpx(px))>>i);
 800668c:	43f3      	mvns	r3, r6
 800668e:	fa43 f30e 	asr.w	r3, r3, lr
 8006692:	fa46 f60e 	asr.w	r6, r6, lr
 8006696:	069b      	lsls	r3, r3, #26
 8006698:	02b6      	lsls	r6, r6, #10
 800669a:	f406 6680 	and.w	r6, r6, #1024	; 0x400
 800669e:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80066a2:	4333      	orrs	r3, r6
 80066a4:	4e4b      	ldr	r6, [pc, #300]	; (80067d4 <refreshDisplay+0x2c8>)
 80066a6:	61b3      	str	r3, [r6, #24]
    G3(gCh(getFRAMEpx(px))>>i);
 80066a8:	43eb      	mvns	r3, r5
 80066aa:	fa43 f30e 	asr.w	r3, r3, lr
 80066ae:	fa45 f50e 	asr.w	r5, r5, lr
 80066b2:	04db      	lsls	r3, r3, #19
 80066b4:	00ed      	lsls	r5, r5, #3
 80066b6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80066ba:	f005 0508 	and.w	r5, r5, #8
 80066be:	431d      	orrs	r5, r3
    B3(bCh(getFRAMEpx(px))>>i);
 80066c0:	43e3      	mvns	r3, r4
 80066c2:	fa43 f30e 	asr.w	r3, r3, lr
 80066c6:	fa44 f40e 	asr.w	r4, r4, lr
 80066ca:	06db      	lsls	r3, r3, #27
 80066cc:	02e4      	lsls	r4, r4, #11
 80066ce:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80066d2:	f404 6400 	and.w	r4, r4, #2048	; 0x800
 80066d6:	431c      	orrs	r4, r3
    R4(rCh(getFRAMEpx(px))>>i);
 80066d8:	43c3      	mvns	r3, r0
 80066da:	fa43 f30e 	asr.w	r3, r3, lr
 80066de:	fa40 f00e 	asr.w	r0, r0, lr
 80066e2:	06db      	lsls	r3, r3, #27
 80066e4:	02c0      	lsls	r0, r0, #11
 80066e6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80066ea:	f400 6000 	and.w	r0, r0, #2048	; 0x800
 80066ee:	4318      	orrs	r0, r3
    B4(bCh(getFRAMEpx(px))>>i);
 80066f0:	43d3      	mvns	r3, r2
 80066f2:	fa43 f30e 	asr.w	r3, r3, lr
 80066f6:	fa42 f20e 	asr.w	r2, r2, lr
 80066fa:	069b      	lsls	r3, r3, #26
 80066fc:	0292      	lsls	r2, r2, #10
 80066fe:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8006702:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 8006706:	431a      	orrs	r2, r3
    G4(gCh(getFRAMEpx(px))>>i);
 8006708:	fa41 f30e 	asr.w	r3, r1, lr
 800670c:	03db      	lsls	r3, r3, #15
 800670e:	43c9      	mvns	r1, r1
 8006710:	b29b      	uxth	r3, r3
 8006712:	fa41 f10e 	asr.w	r1, r1, lr
 8006716:	ea43 71c1 	orr.w	r1, r3, r1, lsl #31
   CLK_HIGH;
 800671a:	f44f 7300 	mov.w	r3, #512	; 0x200
    G3(gCh(getFRAMEpx(px))>>i);
 800671e:	61b5      	str	r5, [r6, #24]
    B3(bCh(getFRAMEpx(px))>>i);
 8006720:	61b4      	str	r4, [r6, #24]
    R4(rCh(getFRAMEpx(px))>>i);
 8006722:	f8c8 0018 	str.w	r0, [r8, #24]
    G4(gCh(getFRAMEpx(px))>>i);
 8006726:	f8c9 1018 	str.w	r1, [r9, #24]
    B4(bCh(getFRAMEpx(px))>>i);
 800672a:	f8c8 2018 	str.w	r2, [r8, #24]
   CLK_HIGH;
 800672e:	f8c8 3018 	str.w	r3, [r8, #24]
 8006732:	bf00      	nop
   CLK_LOW;
 8006734:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8006738:	f8c8 3018 	str.w	r3, [r8, #24]
                {       
                    for(segment=1; segment<=NUM_OF_SEGMENTS;segment++)
                    {
                        pixel=y_offset+x_offset+((NUM_OF_SEGMENTS-segment)*SEGMENT_OFFSET);

                        for(column=0;column<PANEL_WIDTH; column++)
 800673c:	9b03      	ldr	r3, [sp, #12]
 800673e:	4553      	cmp	r3, sl
 8006740:	f47f af32 	bne.w	80065a8 <refreshDisplay+0x9c>
 8006744:	9b04      	ldr	r3, [sp, #16]
 8006746:	f5a3 6310 	sub.w	r3, r3, #2304	; 0x900
 800674a:	9304      	str	r3, [sp, #16]
                    for(segment=1; segment<=NUM_OF_SEGMENTS;segment++)
 800674c:	9b05      	ldr	r3, [sp, #20]
 800674e:	2b01      	cmp	r3, #1
 8006750:	d137      	bne.n	80067c2 <refreshDisplay+0x2b6>
                            setColor(pixel+column, cBit);

                            clock();                        
                        }
                    }
                    x_offset+=PANEL_WIDTH;
 8006752:	9b07      	ldr	r3, [sp, #28]
 8006754:	9a06      	ldr	r2, [sp, #24]
 8006756:	3320      	adds	r3, #32
 8006758:	3260      	adds	r2, #96	; 0x60
                for(panel_x=0;panel_x<NUM_OF_PANELS_X;panel_x++)
 800675a:	2b60      	cmp	r3, #96	; 0x60
                    x_offset+=PANEL_WIDTH;
 800675c:	9307      	str	r3, [sp, #28]
 800675e:	9206      	str	r2, [sp, #24]
                for(panel_x=0;panel_x<NUM_OF_PANELS_X;panel_x++)
 8006760:	f47f af12 	bne.w	8006588 <refreshDisplay+0x7c>
    LAT_HIGH;
 8006764:	4a1b      	ldr	r2, [pc, #108]	; (80067d4 <refreshDisplay+0x2c8>)
 8006766:	2320      	movs	r3, #32
 8006768:	6193      	str	r3, [r2, #24]
 800676a:	bf00      	nop
                y_offset+=VERTICAL_PANEL_OFFSET;
            }

            latch();

            OE_LOW;
 800676c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
    LAT_LOW;
 8006770:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8006774:	6191      	str	r1, [r2, #24]
            OE_LOW;
 8006776:	6193      	str	r3, [r2, #24]
                delay_nops(BRIGHTNESS<<cBit); // BCM Modulation
 8006778:	4b17      	ldr	r3, [pc, #92]	; (80067d8 <refreshDisplay+0x2cc>)
 800677a:	881a      	ldrh	r2, [r3, #0]
 800677c:	fa02 f20e 	lsl.w	r2, r2, lr
// DISPLAY DELAY FUNCTIONS
// display_nops, simpleDelay, refreshDelay, displayDelay
//------------------------------------------------------------------------------------------
void delay_nops(uint32_t nops)
{
    while(nops--) NOP();
 8006780:	1e53      	subs	r3, r2, #1
 8006782:	b11a      	cbz	r2, 800678c <refreshDisplay+0x280>
 8006784:	bf00      	nop
 8006786:	f113 33ff 	adds.w	r3, r3, #4294967295
 800678a:	d2fb      	bcs.n	8006784 <refreshDisplay+0x278>
            OE_HIGH;
 800678c:	4a11      	ldr	r2, [pc, #68]	; (80067d4 <refreshDisplay+0x2c8>)
 800678e:	2310      	movs	r3, #16
 8006790:	6193      	str	r3, [r2, #24]
 8006792:	bf00      	nop
    while(nops--) NOP();
 8006794:	bf00      	nop
 8006796:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006798:	9a08      	ldr	r2, [sp, #32]
 800679a:	3301      	adds	r3, #1
 800679c:	f502 7290 	add.w	r2, r2, #288	; 0x120
       for(row=0; row<NUM_OF_ROWS; row++)
 80067a0:	2b08      	cmp	r3, #8
 80067a2:	9309      	str	r3, [sp, #36]	; 0x24
 80067a4:	9208      	str	r2, [sp, #32]
 80067a6:	f47f aec4 	bne.w	8006532 <refreshDisplay+0x26>
    for(cBit=0; cBit<(BITS_PER_CHANNEL); cBit++)
 80067aa:	4b08      	ldr	r3, [pc, #32]	; (80067cc <refreshDisplay+0x2c0>)
 80067ac:	f10e 0201 	add.w	r2, lr, #1
 80067b0:	781b      	ldrb	r3, [r3, #0]
 80067b2:	fa5f fe82 	uxtb.w	lr, r2
 80067b6:	4573      	cmp	r3, lr
 80067b8:	f63f aeb7 	bhi.w	800652a <refreshDisplay+0x1e>
}
 80067bc:	b00b      	add	sp, #44	; 0x2c
 80067be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80067c2:	2301      	movs	r3, #1
 80067c4:	9305      	str	r3, [sp, #20]
 80067c6:	e6e3      	b.n	8006590 <refreshDisplay+0x84>
 80067c8:	4770      	bx	lr
 80067ca:	bf00      	nop
 80067cc:	20000024 	.word	0x20000024
 80067d0:	2000498c 	.word	0x2000498c
 80067d4:	40020400 	.word	0x40020400
 80067d8:	20000026 	.word	0x20000026
 80067dc:	40020000 	.word	0x40020000
 80067e0:	40020800 	.word	0x40020800

080067e4 <displaySetBrightness>:
    BRIGHTNESS=level;
 80067e4:	4b01      	ldr	r3, [pc, #4]	; (80067ec <displaySetBrightness+0x8>)
 80067e6:	8018      	strh	r0, [r3, #0]
}
 80067e8:	4770      	bx	lr
 80067ea:	bf00      	nop
 80067ec:	20000026 	.word	0x20000026

080067f0 <displayInit>:
{
 80067f0:	b430      	push	{r4, r5}
	enablePORTclocks();
 80067f2:	4ca2      	ldr	r4, [pc, #648]	; (8006a7c <displayInit+0x28c>)
	R1_IO; G1_IO; B1_IO;
 80067f4:	48a2      	ldr	r0, [pc, #648]	; (8006a80 <displayInit+0x290>)
	enablePORTclocks();
 80067f6:	6b25      	ldr	r5, [r4, #48]	; 0x30
	R2_IO; G2_IO; B2_IO;
 80067f8:	4aa2      	ldr	r2, [pc, #648]	; (8006a84 <displayInit+0x294>)
	R3_IO; G3_IO; B3_IO;
 80067fa:	49a3      	ldr	r1, [pc, #652]	; (8006a88 <displayInit+0x298>)
 80067fc:	4ba3      	ldr	r3, [pc, #652]	; (8006a8c <displayInit+0x29c>)
	enablePORTclocks();
 80067fe:	f045 0501 	orr.w	r5, r5, #1
 8006802:	6325      	str	r5, [r4, #48]	; 0x30
 8006804:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8006806:	f045 0502 	orr.w	r5, r5, #2
 800680a:	6325      	str	r5, [r4, #48]	; 0x30
 800680c:	6b25      	ldr	r5, [r4, #48]	; 0x30
 800680e:	f045 0504 	orr.w	r5, r5, #4
 8006812:	6325      	str	r5, [r4, #48]	; 0x30
	R1_IO; G1_IO; B1_IO;
 8006814:	6804      	ldr	r4, [r0, #0]
 8006816:	f024 5440 	bic.w	r4, r4, #805306368	; 0x30000000
 800681a:	6004      	str	r4, [r0, #0]
 800681c:	6804      	ldr	r4, [r0, #0]
 800681e:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 8006822:	6004      	str	r4, [r0, #0]
 8006824:	6844      	ldr	r4, [r0, #4]
 8006826:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
 800682a:	6044      	str	r4, [r0, #4]
 800682c:	6844      	ldr	r4, [r0, #4]
 800682e:	6044      	str	r4, [r0, #4]
 8006830:	6884      	ldr	r4, [r0, #8]
 8006832:	f024 5440 	bic.w	r4, r4, #805306368	; 0x30000000
 8006836:	6084      	str	r4, [r0, #8]
 8006838:	6884      	ldr	r4, [r0, #8]
 800683a:	f044 5440 	orr.w	r4, r4, #805306368	; 0x30000000
 800683e:	6084      	str	r4, [r0, #8]
 8006840:	68c4      	ldr	r4, [r0, #12]
 8006842:	f024 5440 	bic.w	r4, r4, #805306368	; 0x30000000
 8006846:	60c4      	str	r4, [r0, #12]
 8006848:	68c4      	ldr	r4, [r0, #12]
 800684a:	60c4      	str	r4, [r0, #12]
 800684c:	6804      	ldr	r4, [r0, #0]
 800684e:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 8006852:	6004      	str	r4, [r0, #0]
 8006854:	6804      	ldr	r4, [r0, #0]
 8006856:	f444 7480 	orr.w	r4, r4, #256	; 0x100
 800685a:	6004      	str	r4, [r0, #0]
 800685c:	6844      	ldr	r4, [r0, #4]
 800685e:	f024 0410 	bic.w	r4, r4, #16
 8006862:	6044      	str	r4, [r0, #4]
 8006864:	6844      	ldr	r4, [r0, #4]
 8006866:	6044      	str	r4, [r0, #4]
 8006868:	6884      	ldr	r4, [r0, #8]
 800686a:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 800686e:	6084      	str	r4, [r0, #8]
 8006870:	6884      	ldr	r4, [r0, #8]
 8006872:	f444 7440 	orr.w	r4, r4, #768	; 0x300
 8006876:	6084      	str	r4, [r0, #8]
 8006878:	68c4      	ldr	r4, [r0, #12]
 800687a:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 800687e:	60c4      	str	r4, [r0, #12]
 8006880:	68c4      	ldr	r4, [r0, #12]
 8006882:	60c4      	str	r4, [r0, #12]
 8006884:	6804      	ldr	r4, [r0, #0]
 8006886:	f024 6440 	bic.w	r4, r4, #201326592	; 0xc000000
 800688a:	6004      	str	r4, [r0, #0]
 800688c:	6804      	ldr	r4, [r0, #0]
 800688e:	f044 6480 	orr.w	r4, r4, #67108864	; 0x4000000
 8006892:	6004      	str	r4, [r0, #0]
 8006894:	6844      	ldr	r4, [r0, #4]
 8006896:	f424 5400 	bic.w	r4, r4, #8192	; 0x2000
 800689a:	6044      	str	r4, [r0, #4]
 800689c:	6844      	ldr	r4, [r0, #4]
 800689e:	6044      	str	r4, [r0, #4]
 80068a0:	6884      	ldr	r4, [r0, #8]
 80068a2:	f024 6440 	bic.w	r4, r4, #201326592	; 0xc000000
 80068a6:	6084      	str	r4, [r0, #8]
 80068a8:	6884      	ldr	r4, [r0, #8]
 80068aa:	f044 6440 	orr.w	r4, r4, #201326592	; 0xc000000
 80068ae:	6084      	str	r4, [r0, #8]
 80068b0:	68c4      	ldr	r4, [r0, #12]
 80068b2:	f024 6440 	bic.w	r4, r4, #201326592	; 0xc000000
 80068b6:	60c4      	str	r4, [r0, #12]
 80068b8:	68c4      	ldr	r4, [r0, #12]
 80068ba:	60c4      	str	r4, [r0, #12]
	R2_IO; G2_IO; B2_IO;
 80068bc:	6814      	ldr	r4, [r2, #0]
 80068be:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 80068c2:	6014      	str	r4, [r2, #0]
 80068c4:	6814      	ldr	r4, [r2, #0]
 80068c6:	f444 7480 	orr.w	r4, r4, #256	; 0x100
 80068ca:	6014      	str	r4, [r2, #0]
 80068cc:	6854      	ldr	r4, [r2, #4]
 80068ce:	f024 0410 	bic.w	r4, r4, #16
 80068d2:	6054      	str	r4, [r2, #4]
 80068d4:	6854      	ldr	r4, [r2, #4]
 80068d6:	6054      	str	r4, [r2, #4]
 80068d8:	6894      	ldr	r4, [r2, #8]
 80068da:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 80068de:	6094      	str	r4, [r2, #8]
 80068e0:	6894      	ldr	r4, [r2, #8]
 80068e2:	f444 7440 	orr.w	r4, r4, #768	; 0x300
 80068e6:	6094      	str	r4, [r2, #8]
 80068e8:	68d4      	ldr	r4, [r2, #12]
 80068ea:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 80068ee:	60d4      	str	r4, [r2, #12]
 80068f0:	68d4      	ldr	r4, [r2, #12]
 80068f2:	60d4      	str	r4, [r2, #12]
 80068f4:	6804      	ldr	r4, [r0, #0]
 80068f6:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
 80068fa:	6004      	str	r4, [r0, #0]
 80068fc:	6804      	ldr	r4, [r0, #0]
 80068fe:	f444 6480 	orr.w	r4, r4, #1024	; 0x400
 8006902:	6004      	str	r4, [r0, #0]
 8006904:	6844      	ldr	r4, [r0, #4]
 8006906:	f024 0420 	bic.w	r4, r4, #32
 800690a:	6044      	str	r4, [r0, #4]
 800690c:	6844      	ldr	r4, [r0, #4]
 800690e:	6044      	str	r4, [r0, #4]
 8006910:	6884      	ldr	r4, [r0, #8]
 8006912:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
 8006916:	6084      	str	r4, [r0, #8]
 8006918:	6884      	ldr	r4, [r0, #8]
 800691a:	f444 6440 	orr.w	r4, r4, #3072	; 0xc00
 800691e:	6084      	str	r4, [r0, #8]
 8006920:	68c4      	ldr	r4, [r0, #12]
 8006922:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
 8006926:	60c4      	str	r4, [r0, #12]
 8006928:	68c4      	ldr	r4, [r0, #12]
 800692a:	60c4      	str	r4, [r0, #12]
 800692c:	6814      	ldr	r4, [r2, #0]
 800692e:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
 8006932:	6014      	str	r4, [r2, #0]
 8006934:	6814      	ldr	r4, [r2, #0]
 8006936:	f444 6480 	orr.w	r4, r4, #1024	; 0x400
 800693a:	6014      	str	r4, [r2, #0]
 800693c:	6854      	ldr	r4, [r2, #4]
 800693e:	f024 0420 	bic.w	r4, r4, #32
 8006942:	6054      	str	r4, [r2, #4]
 8006944:	6854      	ldr	r4, [r2, #4]
 8006946:	6054      	str	r4, [r2, #4]
 8006948:	6894      	ldr	r4, [r2, #8]
 800694a:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
 800694e:	6094      	str	r4, [r2, #8]
 8006950:	6894      	ldr	r4, [r2, #8]
 8006952:	f444 6440 	orr.w	r4, r4, #3072	; 0xc00
 8006956:	6094      	str	r4, [r2, #8]
 8006958:	68d4      	ldr	r4, [r2, #12]
 800695a:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
 800695e:	60d4      	str	r4, [r2, #12]
 8006960:	68d4      	ldr	r4, [r2, #12]
 8006962:	60d4      	str	r4, [r2, #12]
	R3_IO; G3_IO; B3_IO;
 8006964:	680c      	ldr	r4, [r1, #0]
 8006966:	f424 1440 	bic.w	r4, r4, #3145728	; 0x300000
 800696a:	600c      	str	r4, [r1, #0]
 800696c:	680c      	ldr	r4, [r1, #0]
 800696e:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
 8006972:	600c      	str	r4, [r1, #0]
 8006974:	684c      	ldr	r4, [r1, #4]
 8006976:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
 800697a:	604c      	str	r4, [r1, #4]
 800697c:	684c      	ldr	r4, [r1, #4]
 800697e:	604c      	str	r4, [r1, #4]
 8006980:	688c      	ldr	r4, [r1, #8]
 8006982:	f424 1440 	bic.w	r4, r4, #3145728	; 0x300000
 8006986:	608c      	str	r4, [r1, #8]
 8006988:	688c      	ldr	r4, [r1, #8]
 800698a:	f444 1440 	orr.w	r4, r4, #3145728	; 0x300000
 800698e:	608c      	str	r4, [r1, #8]
 8006990:	68cc      	ldr	r4, [r1, #12]
 8006992:	f424 1440 	bic.w	r4, r4, #3145728	; 0x300000
 8006996:	60cc      	str	r4, [r1, #12]
 8006998:	68cc      	ldr	r4, [r1, #12]
 800699a:	60cc      	str	r4, [r1, #12]
 800699c:	680c      	ldr	r4, [r1, #0]
 800699e:	f024 04c0 	bic.w	r4, r4, #192	; 0xc0
 80069a2:	600c      	str	r4, [r1, #0]
 80069a4:	680c      	ldr	r4, [r1, #0]
 80069a6:	f044 0440 	orr.w	r4, r4, #64	; 0x40
 80069aa:	600c      	str	r4, [r1, #0]
 80069ac:	684c      	ldr	r4, [r1, #4]
 80069ae:	f024 0408 	bic.w	r4, r4, #8
 80069b2:	604c      	str	r4, [r1, #4]
 80069b4:	684c      	ldr	r4, [r1, #4]
 80069b6:	604c      	str	r4, [r1, #4]
 80069b8:	688c      	ldr	r4, [r1, #8]
 80069ba:	f024 04c0 	bic.w	r4, r4, #192	; 0xc0
 80069be:	608c      	str	r4, [r1, #8]
 80069c0:	688c      	ldr	r4, [r1, #8]
 80069c2:	f044 04c0 	orr.w	r4, r4, #192	; 0xc0
 80069c6:	608c      	str	r4, [r1, #8]
 80069c8:	68cc      	ldr	r4, [r1, #12]
 80069ca:	f024 04c0 	bic.w	r4, r4, #192	; 0xc0
 80069ce:	60cc      	str	r4, [r1, #12]
 80069d0:	68cc      	ldr	r4, [r1, #12]
 80069d2:	60cc      	str	r4, [r1, #12]
 80069d4:	680c      	ldr	r4, [r1, #0]
 80069d6:	f424 0440 	bic.w	r4, r4, #12582912	; 0xc00000
 80069da:	600c      	str	r4, [r1, #0]
 80069dc:	680c      	ldr	r4, [r1, #0]
 80069de:	f444 0480 	orr.w	r4, r4, #4194304	; 0x400000
 80069e2:	600c      	str	r4, [r1, #0]
 80069e4:	684c      	ldr	r4, [r1, #4]
 80069e6:	f424 6400 	bic.w	r4, r4, #2048	; 0x800
 80069ea:	604c      	str	r4, [r1, #4]
 80069ec:	684c      	ldr	r4, [r1, #4]
 80069ee:	604c      	str	r4, [r1, #4]
 80069f0:	688c      	ldr	r4, [r1, #8]
 80069f2:	f424 0440 	bic.w	r4, r4, #12582912	; 0xc00000
 80069f6:	608c      	str	r4, [r1, #8]
 80069f8:	688c      	ldr	r4, [r1, #8]
 80069fa:	f444 0440 	orr.w	r4, r4, #12582912	; 0xc00000
 80069fe:	608c      	str	r4, [r1, #8]
 8006a00:	68cc      	ldr	r4, [r1, #12]
 8006a02:	f424 0440 	bic.w	r4, r4, #12582912	; 0xc00000
 8006a06:	60cc      	str	r4, [r1, #12]
 8006a08:	68cc      	ldr	r4, [r1, #12]
 8006a0a:	60cc      	str	r4, [r1, #12]
	R4_IO; G4_IO; B4_IO;
 8006a0c:	6814      	ldr	r4, [r2, #0]
 8006a0e:	f424 0440 	bic.w	r4, r4, #12582912	; 0xc00000
 8006a12:	6014      	str	r4, [r2, #0]
 8006a14:	6814      	ldr	r4, [r2, #0]
 8006a16:	f444 0480 	orr.w	r4, r4, #4194304	; 0x400000
 8006a1a:	6014      	str	r4, [r2, #0]
 8006a1c:	6854      	ldr	r4, [r2, #4]
 8006a1e:	f424 6400 	bic.w	r4, r4, #2048	; 0x800
 8006a22:	6054      	str	r4, [r2, #4]
 8006a24:	6854      	ldr	r4, [r2, #4]
 8006a26:	6054      	str	r4, [r2, #4]
 8006a28:	6894      	ldr	r4, [r2, #8]
 8006a2a:	f424 0440 	bic.w	r4, r4, #12582912	; 0xc00000
 8006a2e:	6094      	str	r4, [r2, #8]
 8006a30:	6894      	ldr	r4, [r2, #8]
 8006a32:	f444 0440 	orr.w	r4, r4, #12582912	; 0xc00000
 8006a36:	6094      	str	r4, [r2, #8]
 8006a38:	68d4      	ldr	r4, [r2, #12]
 8006a3a:	f424 0440 	bic.w	r4, r4, #12582912	; 0xc00000
 8006a3e:	60d4      	str	r4, [r2, #12]
 8006a40:	68d4      	ldr	r4, [r2, #12]
 8006a42:	60d4      	str	r4, [r2, #12]
 8006a44:	6804      	ldr	r4, [r0, #0]
 8006a46:	f024 4440 	bic.w	r4, r4, #3221225472	; 0xc0000000
 8006a4a:	6004      	str	r4, [r0, #0]
 8006a4c:	6804      	ldr	r4, [r0, #0]
 8006a4e:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
 8006a52:	6004      	str	r4, [r0, #0]
 8006a54:	6844      	ldr	r4, [r0, #4]
 8006a56:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
 8006a5a:	6044      	str	r4, [r0, #4]
 8006a5c:	6844      	ldr	r4, [r0, #4]
 8006a5e:	6044      	str	r4, [r0, #4]
 8006a60:	6884      	ldr	r4, [r0, #8]
 8006a62:	f024 4440 	bic.w	r4, r4, #3221225472	; 0xc0000000
 8006a66:	6084      	str	r4, [r0, #8]
 8006a68:	6884      	ldr	r4, [r0, #8]
 8006a6a:	f044 4440 	orr.w	r4, r4, #3221225472	; 0xc0000000
 8006a6e:	6084      	str	r4, [r0, #8]
 8006a70:	68c4      	ldr	r4, [r0, #12]
 8006a72:	f024 4440 	bic.w	r4, r4, #3221225472	; 0xc0000000
 8006a76:	60c4      	str	r4, [r0, #12]
 8006a78:	e00a      	b.n	8006a90 <displayInit+0x2a0>
 8006a7a:	bf00      	nop
 8006a7c:	40023800 	.word	0x40023800
 8006a80:	40020000 	.word	0x40020000
 8006a84:	40020800 	.word	0x40020800
 8006a88:	40020400 	.word	0x40020400
 8006a8c:	20004098 	.word	0x20004098
 8006a90:	68c4      	ldr	r4, [r0, #12]
 8006a92:	60c4      	str	r4, [r0, #12]
 8006a94:	6814      	ldr	r4, [r2, #0]
 8006a96:	f424 1440 	bic.w	r4, r4, #3145728	; 0x300000
 8006a9a:	6014      	str	r4, [r2, #0]
 8006a9c:	6814      	ldr	r4, [r2, #0]
 8006a9e:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
 8006aa2:	6014      	str	r4, [r2, #0]
 8006aa4:	6854      	ldr	r4, [r2, #4]
 8006aa6:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
 8006aaa:	6054      	str	r4, [r2, #4]
 8006aac:	6854      	ldr	r4, [r2, #4]
 8006aae:	6054      	str	r4, [r2, #4]
 8006ab0:	6894      	ldr	r4, [r2, #8]
 8006ab2:	f424 1440 	bic.w	r4, r4, #3145728	; 0x300000
 8006ab6:	6094      	str	r4, [r2, #8]
 8006ab8:	6894      	ldr	r4, [r2, #8]
 8006aba:	f444 1440 	orr.w	r4, r4, #3145728	; 0x300000
 8006abe:	6094      	str	r4, [r2, #8]
 8006ac0:	68d4      	ldr	r4, [r2, #12]
 8006ac2:	f424 1440 	bic.w	r4, r4, #3145728	; 0x300000
 8006ac6:	60d4      	str	r4, [r2, #12]
 8006ac8:	68d4      	ldr	r4, [r2, #12]
 8006aca:	60d4      	str	r4, [r2, #12]
	A_IO;
 8006acc:	680c      	ldr	r4, [r1, #0]
 8006ace:	f424 2440 	bic.w	r4, r4, #786432	; 0xc0000
 8006ad2:	600c      	str	r4, [r1, #0]
 8006ad4:	680c      	ldr	r4, [r1, #0]
 8006ad6:	f444 2480 	orr.w	r4, r4, #262144	; 0x40000
 8006ada:	600c      	str	r4, [r1, #0]
 8006adc:	684c      	ldr	r4, [r1, #4]
 8006ade:	f424 7400 	bic.w	r4, r4, #512	; 0x200
 8006ae2:	604c      	str	r4, [r1, #4]
 8006ae4:	684c      	ldr	r4, [r1, #4]
 8006ae6:	604c      	str	r4, [r1, #4]
 8006ae8:	688c      	ldr	r4, [r1, #8]
 8006aea:	f424 2440 	bic.w	r4, r4, #786432	; 0xc0000
 8006aee:	608c      	str	r4, [r1, #8]
 8006af0:	688c      	ldr	r4, [r1, #8]
 8006af2:	f444 2440 	orr.w	r4, r4, #786432	; 0xc0000
 8006af6:	608c      	str	r4, [r1, #8]
 8006af8:	68cc      	ldr	r4, [r1, #12]
 8006afa:	f424 2440 	bic.w	r4, r4, #786432	; 0xc0000
 8006afe:	60cc      	str	r4, [r1, #12]
 8006b00:	68cc      	ldr	r4, [r1, #12]
 8006b02:	60cc      	str	r4, [r1, #12]
	B_IO;
 8006b04:	6804      	ldr	r4, [r0, #0]
 8006b06:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
 8006b0a:	6004      	str	r4, [r0, #0]
 8006b0c:	6804      	ldr	r4, [r0, #0]
 8006b0e:	f444 5480 	orr.w	r4, r4, #4096	; 0x1000
 8006b12:	6004      	str	r4, [r0, #0]
 8006b14:	6844      	ldr	r4, [r0, #4]
 8006b16:	f024 0440 	bic.w	r4, r4, #64	; 0x40
 8006b1a:	6044      	str	r4, [r0, #4]
 8006b1c:	6844      	ldr	r4, [r0, #4]
 8006b1e:	6044      	str	r4, [r0, #4]
 8006b20:	6884      	ldr	r4, [r0, #8]
 8006b22:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
 8006b26:	6084      	str	r4, [r0, #8]
 8006b28:	6884      	ldr	r4, [r0, #8]
 8006b2a:	f444 5440 	orr.w	r4, r4, #12288	; 0x3000
 8006b2e:	6084      	str	r4, [r0, #8]
 8006b30:	68c4      	ldr	r4, [r0, #12]
 8006b32:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
 8006b36:	60c4      	str	r4, [r0, #12]
 8006b38:	68c4      	ldr	r4, [r0, #12]
 8006b3a:	60c4      	str	r4, [r0, #12]
	C_IO;
 8006b3c:	6808      	ldr	r0, [r1, #0]
 8006b3e:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
 8006b42:	6008      	str	r0, [r1, #0]
 8006b44:	6808      	ldr	r0, [r1, #0]
 8006b46:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 8006b4a:	6008      	str	r0, [r1, #0]
 8006b4c:	6848      	ldr	r0, [r1, #4]
 8006b4e:	f420 7080 	bic.w	r0, r0, #256	; 0x100
 8006b52:	6048      	str	r0, [r1, #4]
 8006b54:	6848      	ldr	r0, [r1, #4]
 8006b56:	6048      	str	r0, [r1, #4]
 8006b58:	6888      	ldr	r0, [r1, #8]
 8006b5a:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
 8006b5e:	6088      	str	r0, [r1, #8]
 8006b60:	6888      	ldr	r0, [r1, #8]
 8006b62:	f440 3040 	orr.w	r0, r0, #196608	; 0x30000
 8006b66:	6088      	str	r0, [r1, #8]
 8006b68:	68c8      	ldr	r0, [r1, #12]
 8006b6a:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
 8006b6e:	60c8      	str	r0, [r1, #12]
 8006b70:	68c8      	ldr	r0, [r1, #12]
 8006b72:	60c8      	str	r0, [r1, #12]
	CLK_IO; LAT_IO; OE_IO;
 8006b74:	6810      	ldr	r0, [r2, #0]
 8006b76:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8006b7a:	6010      	str	r0, [r2, #0]
 8006b7c:	6810      	ldr	r0, [r2, #0]
 8006b7e:	f440 2080 	orr.w	r0, r0, #262144	; 0x40000
 8006b82:	6010      	str	r0, [r2, #0]
 8006b84:	6850      	ldr	r0, [r2, #4]
 8006b86:	f420 7000 	bic.w	r0, r0, #512	; 0x200
 8006b8a:	6050      	str	r0, [r2, #4]
 8006b8c:	6850      	ldr	r0, [r2, #4]
 8006b8e:	6050      	str	r0, [r2, #4]
 8006b90:	6890      	ldr	r0, [r2, #8]
 8006b92:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8006b96:	6090      	str	r0, [r2, #8]
 8006b98:	6890      	ldr	r0, [r2, #8]
 8006b9a:	f440 2040 	orr.w	r0, r0, #786432	; 0xc0000
 8006b9e:	6090      	str	r0, [r2, #8]
 8006ba0:	68d0      	ldr	r0, [r2, #12]
 8006ba2:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8006ba6:	60d0      	str	r0, [r2, #12]
 8006ba8:	68d0      	ldr	r0, [r2, #12]
 8006baa:	60d0      	str	r0, [r2, #12]
 8006bac:	6808      	ldr	r0, [r1, #0]
 8006bae:	f420 6040 	bic.w	r0, r0, #3072	; 0xc00
 8006bb2:	6008      	str	r0, [r1, #0]
 8006bb4:	6808      	ldr	r0, [r1, #0]
 8006bb6:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
 8006bba:	6008      	str	r0, [r1, #0]
 8006bbc:	6848      	ldr	r0, [r1, #4]
 8006bbe:	f020 0020 	bic.w	r0, r0, #32
 8006bc2:	6048      	str	r0, [r1, #4]
 8006bc4:	6848      	ldr	r0, [r1, #4]
 8006bc6:	6048      	str	r0, [r1, #4]
 8006bc8:	6888      	ldr	r0, [r1, #8]
 8006bca:	f420 6040 	bic.w	r0, r0, #3072	; 0xc00
 8006bce:	6088      	str	r0, [r1, #8]
 8006bd0:	6888      	ldr	r0, [r1, #8]
 8006bd2:	f440 6040 	orr.w	r0, r0, #3072	; 0xc00
 8006bd6:	6088      	str	r0, [r1, #8]
 8006bd8:	68c8      	ldr	r0, [r1, #12]
 8006bda:	f420 6040 	bic.w	r0, r0, #3072	; 0xc00
 8006bde:	60c8      	str	r0, [r1, #12]
 8006be0:	68c8      	ldr	r0, [r1, #12]
 8006be2:	60c8      	str	r0, [r1, #12]
 8006be4:	6808      	ldr	r0, [r1, #0]
 8006be6:	f420 7040 	bic.w	r0, r0, #768	; 0x300
 8006bea:	6008      	str	r0, [r1, #0]
 8006bec:	6808      	ldr	r0, [r1, #0]
 8006bee:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 8006bf2:	6008      	str	r0, [r1, #0]
 8006bf4:	6848      	ldr	r0, [r1, #4]
 8006bf6:	f020 0010 	bic.w	r0, r0, #16
 8006bfa:	6048      	str	r0, [r1, #4]
 8006bfc:	6848      	ldr	r0, [r1, #4]
 8006bfe:	6048      	str	r0, [r1, #4]
 8006c00:	6888      	ldr	r0, [r1, #8]
 8006c02:	f420 7040 	bic.w	r0, r0, #768	; 0x300
 8006c06:	6088      	str	r0, [r1, #8]
 8006c08:	6888      	ldr	r0, [r1, #8]
 8006c0a:	f440 7040 	orr.w	r0, r0, #768	; 0x300
 8006c0e:	6088      	str	r0, [r1, #8]
 8006c10:	68c8      	ldr	r0, [r1, #12]
 8006c12:	f420 7040 	bic.w	r0, r0, #768	; 0x300
 8006c16:	60c8      	str	r0, [r1, #12]
 8006c18:	68c8      	ldr	r0, [r1, #12]
 8006c1a:	60c8      	str	r0, [r1, #12]
	STAT_LED_IO;
 8006c1c:	6811      	ldr	r1, [r2, #0]
 8006c1e:	f021 7140 	bic.w	r1, r1, #50331648	; 0x3000000
 8006c22:	6011      	str	r1, [r2, #0]
 8006c24:	6811      	ldr	r1, [r2, #0]
 8006c26:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8006c2a:	6011      	str	r1, [r2, #0]
 8006c2c:	6851      	ldr	r1, [r2, #4]
 8006c2e:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 8006c32:	6051      	str	r1, [r2, #4]
 8006c34:	6851      	ldr	r1, [r2, #4]
 8006c36:	6051      	str	r1, [r2, #4]
 8006c38:	6891      	ldr	r1, [r2, #8]
 8006c3a:	f021 7140 	bic.w	r1, r1, #50331648	; 0x3000000
 8006c3e:	6091      	str	r1, [r2, #8]
 8006c40:	6891      	ldr	r1, [r2, #8]
 8006c42:	6091      	str	r1, [r2, #8]
 8006c44:	68d1      	ldr	r1, [r2, #12]
 8006c46:	f021 7140 	bic.w	r1, r1, #50331648	; 0x3000000
 8006c4a:	60d1      	str	r1, [r2, #12]
 8006c4c:	68d1      	ldr	r1, [r2, #12]
 8006c4e:	60d1      	str	r1, [r2, #12]
	DATA_LED_IO;
 8006c50:	6811      	ldr	r1, [r2, #0]
 8006c52:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 8006c56:	6011      	str	r1, [r2, #0]
 8006c58:	6811      	ldr	r1, [r2, #0]
 8006c5a:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
 8006c5e:	6011      	str	r1, [r2, #0]
 8006c60:	6851      	ldr	r1, [r2, #4]
 8006c62:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 8006c66:	6051      	str	r1, [r2, #4]
 8006c68:	6851      	ldr	r1, [r2, #4]
 8006c6a:	6051      	str	r1, [r2, #4]
 8006c6c:	6891      	ldr	r1, [r2, #8]
 8006c6e:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 8006c72:	6091      	str	r1, [r2, #8]
 8006c74:	6891      	ldr	r1, [r2, #8]
 8006c76:	6091      	str	r1, [r2, #8]
 8006c78:	68d1      	ldr	r1, [r2, #12]
 8006c7a:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 8006c7e:	60d1      	str	r1, [r2, #12]
 8006c80:	68d1      	ldr	r1, [r2, #12]
 8006c82:	60d1      	str	r1, [r2, #12]
 8006c84:	f503 4190 	add.w	r1, r3, #18432	; 0x4800
    for(i=0;i<NUM_OF_PANELS*NUM_PIXELS_PER_PANEL;i++)setFRAMEpx(i,color); 
 8006c88:	2200      	movs	r2, #0
 8006c8a:	f843 2c04 	str.w	r2, [r3, #-4]
 8006c8e:	e943 2203 	strd	r2, r2, [r3, #-12]
 8006c92:	330c      	adds	r3, #12
 8006c94:	428b      	cmp	r3, r1
 8006c96:	d1f8      	bne.n	8006c8a <displayInit+0x49a>
    SELECTED_FONT=font;
 8006c98:	4b03      	ldr	r3, [pc, #12]	; (8006ca8 <displayInit+0x4b8>)
 8006c9a:	4904      	ldr	r1, [pc, #16]	; (8006cac <displayInit+0x4bc>)
 8006c9c:	4a04      	ldr	r2, [pc, #16]	; (8006cb0 <displayInit+0x4c0>)
}
 8006c9e:	bc30      	pop	{r4, r5}
    SELECTED_FONT=font;
 8006ca0:	e9c3 1200 	strd	r1, r2, [r3]
}
 8006ca4:	4770      	bx	lr
 8006ca6:	bf00      	nop
 8006ca8:	2000888c 	.word	0x2000888c
 8006cac:	7a200705 	.word	0x7a200705
 8006cb0:	08007e60 	.word	0x08007e60

08006cb4 <displayFill>:
{
 8006cb4:	b410      	push	{r4}
 8006cb6:	b083      	sub	sp, #12
 8006cb8:	aa02      	add	r2, sp, #8
 8006cba:	4b08      	ldr	r3, [pc, #32]	; (8006cdc <displayFill+0x28>)
 8006cbc:	f842 0d04 	str.w	r0, [r2, #-4]!
 8006cc0:	f503 4490 	add.w	r4, r3, #18432	; 0x4800
    for(i=0;i<NUM_OF_PANELS*NUM_PIXELS_PER_PANEL;i++)setFRAMEpx(i,color); 
 8006cc4:	8810      	ldrh	r0, [r2, #0]
 8006cc6:	7891      	ldrb	r1, [r2, #2]
 8006cc8:	8018      	strh	r0, [r3, #0]
 8006cca:	7099      	strb	r1, [r3, #2]
 8006ccc:	3303      	adds	r3, #3
 8006cce:	42a3      	cmp	r3, r4
 8006cd0:	d1f8      	bne.n	8006cc4 <displayFill+0x10>
}
 8006cd2:	b003      	add	sp, #12
 8006cd4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006cd8:	4770      	bx	lr
 8006cda:	bf00      	nop
 8006cdc:	2000408c 	.word	0x2000408c

08006ce0 <displayClear>:
{
 8006ce0:	4b05      	ldr	r3, [pc, #20]	; (8006cf8 <displayClear+0x18>)
    for(i=0;i<NUM_OF_PANELS*NUM_PIXELS_PER_PANEL;i++)setFRAMEpx(i,color); 
 8006ce2:	2200      	movs	r2, #0
 8006ce4:	f503 4190 	add.w	r1, r3, #18432	; 0x4800
 8006ce8:	f843 2c04 	str.w	r2, [r3, #-4]
 8006cec:	e943 2203 	strd	r2, r2, [r3, #-12]
 8006cf0:	330c      	adds	r3, #12
 8006cf2:	4299      	cmp	r1, r3
 8006cf4:	d1f8      	bne.n	8006ce8 <displayClear+0x8>
}
 8006cf6:	4770      	bx	lr
 8006cf8:	20004098 	.word	0x20004098

08006cfc <displayScroll>:
    for(i=0;i<num_of_px;i++)
 8006cfc:	2900      	cmp	r1, #0
 8006cfe:	f000 809a 	beq.w	8006e36 <displayScroll+0x13a>
{
 8006d02:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006d06:	b085      	sub	sp, #20
 8006d08:	f000 030c 	and.w	r3, r0, #12
 8006d0c:	e9cd 2102 	strd	r2, r1, [sp, #8]
 8006d10:	9300      	str	r3, [sp, #0]
 8006d12:	f000 0303 	and.w	r3, r0, #3
   dir=(dir&0x08)>>3;
 8006d16:	f3c0 06c0 	ubfx	r6, r0, #3, #1
 8006d1a:	9301      	str	r3, [sp, #4]
    dir=(dir&0x02)>>1;
 8006d1c:	f3c0 0540 	ubfx	r5, r0, #1, #1
    for(i=0;i<num_of_px;i++)
 8006d20:	2700      	movs	r7, #0
        if(dir&(LEFT|RIGHT))displayScrollLeftRight(dir);
 8006d22:	9b00      	ldr	r3, [sp, #0]
 8006d24:	2b00      	cmp	r3, #0
 8006d26:	d157      	bne.n	8006dd8 <displayScroll+0xdc>
        if(dir&(UP|DOWN))displayScrollUpDown(dir);
 8006d28:	9b01      	ldr	r3, [sp, #4]
 8006d2a:	b99b      	cbnz	r3, 8006d54 <displayScroll+0x58>
}
void simpleDelay(uint32_t delay)
{
    while(delay--)
 8006d2c:	9a02      	ldr	r2, [sp, #8]
 8006d2e:	f112 32ff 	adds.w	r2, r2, #4294967295
 8006d32:	d307      	bcc.n	8006d44 <displayScroll+0x48>
 8006d34:	f24a 4310 	movw	r3, #42000	; 0xa410
    while(nops--) NOP();
 8006d38:	bf00      	nop
 8006d3a:	3b01      	subs	r3, #1
 8006d3c:	d1fc      	bne.n	8006d38 <displayScroll+0x3c>
    while(delay--)
 8006d3e:	f112 32ff 	adds.w	r2, r2, #4294967295
 8006d42:	d2f7      	bcs.n	8006d34 <displayScroll+0x38>
    for(i=0;i<num_of_px;i++)
 8006d44:	3701      	adds	r7, #1
 8006d46:	9b03      	ldr	r3, [sp, #12]
 8006d48:	b2bf      	uxth	r7, r7
 8006d4a:	42bb      	cmp	r3, r7
 8006d4c:	d1e9      	bne.n	8006d22 <displayScroll+0x26>
}
 8006d4e:	b005      	add	sp, #20
 8006d50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006d54:	f8df e0e8 	ldr.w	lr, [pc, #232]	; 8006e40 <displayScroll+0x144>
 8006d58:	4c37      	ldr	r4, [pc, #220]	; (8006e38 <displayScroll+0x13c>)
 8006d5a:	f50e 7890 	add.w	r8, lr, #288	; 0x120
        if(dir)temp=getFRAMEpx(x);
 8006d5e:	b31d      	cbz	r5, 8006da8 <displayScroll+0xac>
 8006d60:	f5ae 438b 	sub.w	r3, lr, #17792	; 0x4580
 8006d64:	f894 b120 	ldrb.w	fp, [r4, #288]	; 0x120
 8006d68:	f894 a121 	ldrb.w	sl, [r4, #289]	; 0x121
 8006d6c:	f894 9122 	ldrb.w	r9, [r4, #290]	; 0x122
 8006d70:	3b40      	subs	r3, #64	; 0x40
 8006d72:	f50e 7c90 	add.w	ip, lr, #288	; 0x120
           if(dir)setFRAMEpx(x+line,getFRAMEpx(x+line+DISPLAY_WIDTH));
 8006d76:	f503 7290 	add.w	r2, r3, #288	; 0x120
 8006d7a:	f8b3 1120 	ldrh.w	r1, [r3, #288]	; 0x120
 8006d7e:	f893 0122 	ldrb.w	r0, [r3, #290]	; 0x122
 8006d82:	7098      	strb	r0, [r3, #2]
        for(y=0;y<(DISPLAY_HEIGHT-1);y++)
 8006d84:	4562      	cmp	r2, ip
           if(dir)setFRAMEpx(x+line,getFRAMEpx(x+line+DISPLAY_WIDTH));
 8006d86:	8019      	strh	r1, [r3, #0]
 8006d88:	4613      	mov	r3, r2
        for(y=0;y<(DISPLAY_HEIGHT-1);y++)
 8006d8a:	d1f4      	bne.n	8006d76 <displayScroll+0x7a>
        if(dir)setFRAMEpx(x+last_line,temp);
 8006d8c:	f88e b120 	strb.w	fp, [lr, #288]	; 0x120
 8006d90:	f88e a121 	strb.w	sl, [lr, #289]	; 0x121
 8006d94:	f88e 9122 	strb.w	r9, [lr, #290]	; 0x122
 8006d98:	f10e 0e03 	add.w	lr, lr, #3
    for(x=0;x<DISPLAY_WIDTH;x++)
 8006d9c:	45c6      	cmp	lr, r8
 8006d9e:	f104 0403 	add.w	r4, r4, #3
 8006da2:	d0c3      	beq.n	8006d2c <displayScroll+0x30>
        if(dir)temp=getFRAMEpx(x);
 8006da4:	2d00      	cmp	r5, #0
 8006da6:	d1db      	bne.n	8006d60 <displayScroll+0x64>
        else temp=getFRAMEpx(x+last_line);
 8006da8:	f89e 9120 	ldrb.w	r9, [lr, #288]	; 0x120
 8006dac:	f89e c121 	ldrb.w	ip, [lr, #289]	; 0x121
 8006db0:	f89e 0122 	ldrb.w	r0, [lr, #290]	; 0x122
 8006db4:	4673      	mov	r3, lr
           else setFRAMEpx(last_line-line+x,getFRAMEpx(last_line-line-(DISPLAY_WIDTH)+x));
 8006db6:	8819      	ldrh	r1, [r3, #0]
 8006db8:	789a      	ldrb	r2, [r3, #2]
 8006dba:	f8a3 1120 	strh.w	r1, [r3, #288]	; 0x120
 8006dbe:	f883 2122 	strb.w	r2, [r3, #290]	; 0x122
 8006dc2:	f5a3 7390 	sub.w	r3, r3, #288	; 0x120
        for(y=0;y<(DISPLAY_HEIGHT-1);y++)
 8006dc6:	42a3      	cmp	r3, r4
 8006dc8:	d1f5      	bne.n	8006db6 <displayScroll+0xba>
        else setFRAMEpx(x,temp);       
 8006dca:	f884 9120 	strb.w	r9, [r4, #288]	; 0x120
 8006dce:	f884 c121 	strb.w	ip, [r4, #289]	; 0x121
 8006dd2:	f884 0122 	strb.w	r0, [r4, #290]	; 0x122
 8006dd6:	e7df      	b.n	8006d98 <displayScroll+0x9c>
 8006dd8:	4c18      	ldr	r4, [pc, #96]	; (8006e3c <displayScroll+0x140>)
 8006dda:	f504 4890 	add.w	r8, r4, #18432	; 0x4800
 8006dde:	e011      	b.n	8006e04 <displayScroll+0x108>
        if(dir)temp=getFRAMEpx(line);
 8006de0:	f814 bc03 	ldrb.w	fp, [r4, #-3]
 8006de4:	f814 ac02 	ldrb.w	sl, [r4, #-2]
 8006de8:	f814 9c01 	ldrb.w	r9, [r4, #-1]
 8006dec:	f000 fb37 	bl	800745e <memmove>
        if(dir)setFRAMEpx(last_column+line,temp);
 8006df0:	f884 b11a 	strb.w	fp, [r4, #282]	; 0x11a
 8006df4:	f884 a11b 	strb.w	sl, [r4, #283]	; 0x11b
 8006df8:	f884 911c 	strb.w	r9, [r4, #284]	; 0x11c
 8006dfc:	f504 7490 	add.w	r4, r4, #288	; 0x120
   for(y=0;y<DISPLAY_HEIGHT;y++)
 8006e00:	4544      	cmp	r4, r8
 8006e02:	d091      	beq.n	8006d28 <displayScroll+0x2c>
 8006e04:	f240 121d 	movw	r2, #285	; 0x11d
 8006e08:	4621      	mov	r1, r4
 8006e0a:	1ee0      	subs	r0, r4, #3
        if(dir)temp=getFRAMEpx(line);
 8006e0c:	2e00      	cmp	r6, #0
 8006e0e:	d1e7      	bne.n	8006de0 <displayScroll+0xe4>
        else temp=getFRAMEpx(last_column+line);
 8006e10:	f894 b11a 	ldrb.w	fp, [r4, #282]	; 0x11a
 8006e14:	f894 a11b 	ldrb.w	sl, [r4, #283]	; 0x11b
 8006e18:	f894 911c 	ldrb.w	r9, [r4, #284]	; 0x11c
 8006e1c:	f240 121d 	movw	r2, #285	; 0x11d
 8006e20:	1ee1      	subs	r1, r4, #3
 8006e22:	4620      	mov	r0, r4
 8006e24:	f000 fb1b 	bl	800745e <memmove>
        else setFRAMEpx(line,temp);
 8006e28:	f804 bc03 	strb.w	fp, [r4, #-3]
 8006e2c:	f804 ac02 	strb.w	sl, [r4, #-2]
 8006e30:	f804 9c01 	strb.w	r9, [r4, #-1]
 8006e34:	e7e2      	b.n	8006dfc <displayScroll+0x100>
 8006e36:	4770      	bx	lr
 8006e38:	20003f6c 	.word	0x20003f6c
 8006e3c:	2000408f 	.word	0x2000408f
 8006e40:	2000864c 	.word	0x2000864c

08006e44 <displayGoTo>:
    x=x%DISPLAY_WIDTH;
 8006e44:	4b08      	ldr	r3, [pc, #32]	; (8006e68 <displayGoTo+0x24>)
    positionX=x;
 8006e46:	4a09      	ldr	r2, [pc, #36]	; (8006e6c <displayGoTo+0x28>)
    x=x%DISPLAY_WIDTH;
 8006e48:	fba3 c300 	umull	ip, r3, r3, r0
 8006e4c:	099b      	lsrs	r3, r3, #6
 8006e4e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
{
 8006e52:	b410      	push	{r4}
    x=x%DISPLAY_WIDTH;
 8006e54:	eba0 1343 	sub.w	r3, r0, r3, lsl #5
    positionY=y;
 8006e58:	4c05      	ldr	r4, [pc, #20]	; (8006e70 <displayGoTo+0x2c>)
    positionX=x;
 8006e5a:	7013      	strb	r3, [r2, #0]
    y=y%DISPLAY_HEIGHT;
 8006e5c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
    positionY=y;
 8006e60:	7021      	strb	r1, [r4, #0]
}
 8006e62:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006e66:	4770      	bx	lr
 8006e68:	aaaaaaab 	.word	0xaaaaaaab
 8006e6c:	20008ac4 	.word	0x20008ac4
 8006e70:	20008ac5 	.word	0x20008ac5

08006e74 <displayPutChar>:
{
 8006e74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(c<=SELECTED_FONT.last_char)
 8006e78:	4b6d      	ldr	r3, [pc, #436]	; (8007030 <displayPutChar+0x1bc>)
 8006e7a:	78da      	ldrb	r2, [r3, #3]
{
 8006e7c:	b08d      	sub	sp, #52	; 0x34
    if(c<=SELECTED_FONT.last_char)
 8006e7e:	4282      	cmp	r2, r0
{
 8006e80:	9109      	str	r1, [sp, #36]	; 0x24
    if(c<=SELECTED_FONT.last_char)
 8006e82:	d353      	bcc.n	8006f2c <displayPutChar+0xb8>
        j=SELECTED_FONT.height/8;  // bytes per char
 8006e84:	785a      	ldrb	r2, [r3, #1]
 8006e86:	9202      	str	r2, [sp, #8]
 8006e88:	08d1      	lsrs	r1, r2, #3
        if(SELECTED_FONT.height%8!=0)j++;
 8006e8a:	0752      	lsls	r2, r2, #29
        j=SELECTED_FONT.height/8;  // bytes per char
 8006e8c:	9105      	str	r1, [sp, #20]
        if(SELECTED_FONT.height%8!=0)j++;
 8006e8e:	bf1c      	itt	ne
 8006e90:	3101      	addne	r1, #1
 8006e92:	9105      	strne	r1, [sp, #20]
        char_offset=(c-SELECTED_FONT.first_char)*(j*SELECTED_FONT.width+1);
 8006e94:	789a      	ldrb	r2, [r3, #2]
        if((positionX+SELECTED_FONT.chars[char_offset]-1)>=DISPLAY_WIDTH)displayNewLine();
 8006e96:	685c      	ldr	r4, [r3, #4]
        char_offset=(c-SELECTED_FONT.first_char)*(j*SELECTED_FONT.width+1);
 8006e98:	7819      	ldrb	r1, [r3, #0]
 8006e9a:	9b05      	ldr	r3, [sp, #20]
 8006e9c:	1a80      	subs	r0, r0, r2
 8006e9e:	fb01 f103 	mul.w	r1, r1, r3
 8006ea2:	fb01 0000 	mla	r0, r1, r0, r0
        if((positionX+SELECTED_FONT.chars[char_offset]-1)>=DISPLAY_WIDTH)displayNewLine();
 8006ea6:	b281      	uxth	r1, r0
 8006ea8:	4b62      	ldr	r3, [pc, #392]	; (8007034 <displayPutChar+0x1c0>)
 8006eaa:	5c65      	ldrb	r5, [r4, r1]
 8006eac:	781a      	ldrb	r2, [r3, #0]
 8006eae:	9206      	str	r2, [sp, #24]
 8006eb0:	1953      	adds	r3, r2, r5
 8006eb2:	1860      	adds	r0, r4, r1
 8006eb4:	2b60      	cmp	r3, #96	; 0x60
 8006eb6:	9008      	str	r0, [sp, #32]
 8006eb8:	f300 809b 	bgt.w	8006ff2 <displayPutChar+0x17e>
 8006ebc:	1c53      	adds	r3, r2, #1
 8006ebe:	b2db      	uxtb	r3, r3
        for (x=1;x<=SELECTED_FONT.chars[char_offset];x++)
 8006ec0:	b395      	cbz	r5, 8006f28 <displayPutChar+0xb4>
 8006ec2:	9b05      	ldr	r3, [sp, #20]
    setFRAMEpx(x+y*DISPLAY_WIDTH,color);
 8006ec4:	f8df e17c 	ldr.w	lr, [pc, #380]	; 8007044 <displayPutChar+0x1d0>
 8006ec8:	f103 3cff 	add.w	ip, r3, #4294967295
 8006ecc:	fa5f fc8c 	uxtb.w	ip, ip
 8006ed0:	9b08      	ldr	r3, [sp, #32]
 8006ed2:	9304      	str	r3, [sp, #16]
 8006ed4:	f10c 0c01 	add.w	ip, ip, #1
 8006ed8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
        for (x=1;x<=SELECTED_FONT.chars[char_offset];x++)
 8006edc:	2301      	movs	r3, #1
 8006ede:	9303      	str	r3, [sp, #12]
    setFRAMEpx(x+y*DISPLAY_WIDTH,color);
 8006ee0:	46e0      	mov	r8, ip
            for(i=0;i<j;i++)data|=(SELECTED_FONT.chars[char_offset+j*(x-1)+i+1]&0xFF)<<(i*8); 
 8006ee2:	9b05      	ldr	r3, [sp, #20]
 8006ee4:	b32b      	cbz	r3, 8006f32 <displayPutChar+0xbe>
 8006ee6:	9c04      	ldr	r4, [sp, #16]
 8006ee8:	2300      	movs	r3, #0
            data=0;
 8006eea:	2000      	movs	r0, #0
 8006eec:	2100      	movs	r1, #0
            for(i=0;i<j;i++)data|=(SELECTED_FONT.chars[char_offset+j*(x-1)+i+1]&0xFF)<<(i*8); 
 8006eee:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8006ef2:	409a      	lsls	r2, r3
 8006ef4:	3308      	adds	r3, #8
 8006ef6:	4543      	cmp	r3, r8
 8006ef8:	ea40 0002 	orr.w	r0, r0, r2
 8006efc:	ea41 71e2 	orr.w	r1, r1, r2, asr #31
 8006f00:	d1f5      	bne.n	8006eee <displayPutChar+0x7a>
            if(x!=1||data!=0) // skip if starts with blank line
 8006f02:	9b03      	ldr	r3, [sp, #12]
 8006f04:	2b01      	cmp	r3, #1
 8006f06:	d119      	bne.n	8006f3c <displayPutChar+0xc8>
 8006f08:	ea50 0301 	orrs.w	r3, r0, r1
 8006f0c:	d116      	bne.n	8006f3c <displayPutChar+0xc8>
        for (x=1;x<=SELECTED_FONT.chars[char_offset];x++)
 8006f0e:	9b03      	ldr	r3, [sp, #12]
 8006f10:	e9dd 2104 	ldrd	r2, r1, [sp, #16]
 8006f14:	3301      	adds	r3, #1
 8006f16:	b29b      	uxth	r3, r3
 8006f18:	440a      	add	r2, r1
 8006f1a:	429d      	cmp	r5, r3
 8006f1c:	9303      	str	r3, [sp, #12]
 8006f1e:	9204      	str	r2, [sp, #16]
 8006f20:	d2df      	bcs.n	8006ee2 <displayPutChar+0x6e>
 8006f22:	9b06      	ldr	r3, [sp, #24]
 8006f24:	3301      	adds	r3, #1
 8006f26:	b2db      	uxtb	r3, r3
        positionX++; // blank line at the end of char
 8006f28:	4a42      	ldr	r2, [pc, #264]	; (8007034 <displayPutChar+0x1c0>)
 8006f2a:	7013      	strb	r3, [r2, #0]
}
 8006f2c:	b00d      	add	sp, #52	; 0x34
 8006f2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if(x!=1||data!=0) // skip if starts with blank line
 8006f32:	9b03      	ldr	r3, [sp, #12]
 8006f34:	2b01      	cmp	r3, #1
 8006f36:	d0ea      	beq.n	8006f0e <displayPutChar+0x9a>
            data=0;
 8006f38:	2000      	movs	r0, #0
 8006f3a:	2100      	movs	r1, #0
    x=x%DISPLAY_WIDTH;
 8006f3c:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 8006f40:	4b3d      	ldr	r3, [pc, #244]	; (8007038 <displayPutChar+0x1c4>)
 8006f42:	fba3 2305 	umull	r2, r3, r3, r5
 8006f46:	099b      	lsrs	r3, r3, #6
 8006f48:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8006f4c:	4a3b      	ldr	r2, [pc, #236]	; (800703c <displayPutChar+0x1c8>)
 8006f4e:	eba5 1543 	sub.w	r5, r5, r3, lsl #5
 8006f52:	7814      	ldrb	r4, [r2, #0]
 8006f54:	9407      	str	r4, [sp, #28]
 8006f56:	2200      	movs	r2, #0
 8006f58:	b2ab      	uxth	r3, r5
 8006f5a:	9301      	str	r3, [sp, #4]
                for(y=0; y<(SELECTED_FONT.height+1); y++)
 8006f5c:	4617      	mov	r7, r2
                    if((data>>y)&0x01) displaySetPixel(positionX, positionY, color);
 8006f5e:	f1c7 0620 	rsb	r6, r7, #32
 8006f62:	fa20 fa07 	lsr.w	sl, r0, r7
 8006f66:	fa01 f606 	lsl.w	r6, r1, r6
 8006f6a:	f1a7 0520 	sub.w	r5, r7, #32
 8006f6e:	ea4a 0a06 	orr.w	sl, sl, r6
    setFRAMEpx(x+y*DISPLAY_WIDTH,color);
 8006f72:	2660      	movs	r6, #96	; 0x60
 8006f74:	46b4      	mov	ip, r6
                    if((data>>y)&0x01) displaySetPixel(positionX, positionY, color);
 8006f76:	fa21 f505 	lsr.w	r5, r1, r5
    setFRAMEpx(x+y*DISPLAY_WIDTH,color);
 8006f7a:	9e01      	ldr	r6, [sp, #4]
                    if((data>>y)&0x01) displaySetPixel(positionX, positionY, color);
 8006f7c:	ea4a 0a05 	orr.w	sl, sl, r5
    setFRAMEpx(x+y*DISPLAY_WIDTH,color);
 8006f80:	f004 033f 	and.w	r3, r4, #63	; 0x3f
 8006f84:	fb1c 6303 	smlabb	r3, ip, r3, r6
                    if((data>>y)&0x01) displaySetPixel(positionX, positionY, color);
 8006f88:	2700      	movs	r7, #0
 8006f8a:	f00a 0601 	and.w	r6, sl, #1
    setFRAMEpx(x+y*DISPLAY_WIDTH,color);
 8006f8e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
                    if((data>>y)&0x01) displaySetPixel(positionX, positionY, color);
 8006f92:	433e      	orrs	r6, r7
    setFRAMEpx(x+y*DISPLAY_WIDTH,color);
 8006f94:	eb0e 0c03 	add.w	ip, lr, r3
                for(y=0; y<(SELECTED_FONT.height+1); y++)
 8006f98:	f102 0501 	add.w	r5, r2, #1
                    positionY++;
 8006f9c:	f104 0901 	add.w	r9, r4, #1
                    if((data>>y)&0x01) displaySetPixel(positionX, positionY, color);
 8006fa0:	d01f      	beq.n	8006fe2 <displayPutChar+0x16e>
 8006fa2:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8006fa4:	f8ad 402c 	strh.w	r4, [sp, #44]	; 0x2c
    setFRAMEpx(x+y*DISPLAY_WIDTH,color);
 8006fa8:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
 8006fac:	f82e 6003 	strh.w	r6, [lr, r3]
                for(y=0; y<(SELECTED_FONT.height+1); y++)
 8006fb0:	9b02      	ldr	r3, [sp, #8]
 8006fb2:	b2aa      	uxth	r2, r5
 8006fb4:	4293      	cmp	r3, r2
 8006fb6:	ea4f 4514 	mov.w	r5, r4, lsr #16
 8006fba:	f88d 502e 	strb.w	r5, [sp, #46]	; 0x2e
                    positionY++;
 8006fbe:	fa5f f489 	uxtb.w	r4, r9
                for(y=0; y<(SELECTED_FONT.height+1); y++)
 8006fc2:	4617      	mov	r7, r2
    setFRAMEpx(x+y*DISPLAY_WIDTH,color);
 8006fc4:	f88c 5002 	strb.w	r5, [ip, #2]
                for(y=0; y<(SELECTED_FONT.height+1); y++)
 8006fc8:	dac9      	bge.n	8006f5e <displayPutChar+0xea>
                positionX++;
 8006fca:	9b06      	ldr	r3, [sp, #24]
 8006fcc:	4a19      	ldr	r2, [pc, #100]	; (8007034 <displayPutChar+0x1c0>)
 8006fce:	3301      	adds	r3, #1
 8006fd0:	b2db      	uxtb	r3, r3
 8006fd2:	7013      	strb	r3, [r2, #0]
 8006fd4:	9306      	str	r3, [sp, #24]
                positionY=positionY-(SELECTED_FONT.height+1);
 8006fd6:	4b19      	ldr	r3, [pc, #100]	; (800703c <displayPutChar+0x1c8>)
 8006fd8:	9a07      	ldr	r2, [sp, #28]
 8006fda:	701a      	strb	r2, [r3, #0]
 8006fdc:	9b08      	ldr	r3, [sp, #32]
 8006fde:	781d      	ldrb	r5, [r3, #0]
 8006fe0:	e795      	b.n	8006f0e <displayPutChar+0x9a>
                for(y=0; y<(SELECTED_FONT.height+1); y++)
 8006fe2:	9b02      	ldr	r3, [sp, #8]
 8006fe4:	b2aa      	uxth	r2, r5
 8006fe6:	429a      	cmp	r2, r3
                    positionY++;
 8006fe8:	fa5f f489 	uxtb.w	r4, r9
                for(y=0; y<(SELECTED_FONT.height+1); y++)
 8006fec:	4617      	mov	r7, r2
 8006fee:	ddb6      	ble.n	8006f5e <displayPutChar+0xea>
 8006ff0:	e7eb      	b.n	8006fca <displayPutChar+0x156>
    if((positionY+SELECTED_FONT.height+1)>=DISPLAY_HEIGHT)
 8006ff2:	4812      	ldr	r0, [pc, #72]	; (800703c <displayPutChar+0x1c8>)
 8006ff4:	9d02      	ldr	r5, [sp, #8]
 8006ff6:	7803      	ldrb	r3, [r0, #0]
 8006ff8:	442b      	add	r3, r5
    positionX=0;
 8006ffa:	4d0e      	ldr	r5, [pc, #56]	; (8007034 <displayPutChar+0x1c0>)
 8006ffc:	2200      	movs	r2, #0
    if((positionY+SELECTED_FONT.height+1)>=DISPLAY_HEIGHT)
 8006ffe:	2b3e      	cmp	r3, #62	; 0x3e
    positionX=0;
 8007000:	702a      	strb	r2, [r5, #0]
    if((positionY+SELECTED_FONT.height+1)>=DISPLAY_HEIGHT)
 8007002:	dd0f      	ble.n	8007024 <displayPutChar+0x1b0>
 8007004:	4b0e      	ldr	r3, [pc, #56]	; (8007040 <displayPutChar+0x1cc>)
        positionY=0;
 8007006:	7002      	strb	r2, [r0, #0]
 8007008:	f503 4090 	add.w	r0, r3, #18432	; 0x4800
    for(i=0;i<NUM_OF_PANELS*NUM_PIXELS_PER_PANEL;i++)setFRAMEpx(i,color); 
 800700c:	f843 2c04 	str.w	r2, [r3, #-4]
 8007010:	e943 2203 	strd	r2, r2, [r3, #-12]
 8007014:	330c      	adds	r3, #12
 8007016:	4298      	cmp	r0, r3
 8007018:	d1f8      	bne.n	800700c <displayPutChar+0x198>
 800701a:	2200      	movs	r2, #0
 800701c:	5c65      	ldrb	r5, [r4, r1]
 800701e:	9206      	str	r2, [sp, #24]
 8007020:	2301      	movs	r3, #1
 8007022:	e74d      	b.n	8006ec0 <displayPutChar+0x4c>
    else positionY+=SELECTED_FONT.height+1;
 8007024:	3301      	adds	r3, #1
 8007026:	7003      	strb	r3, [r0, #0]
 8007028:	5c65      	ldrb	r5, [r4, r1]
 800702a:	9206      	str	r2, [sp, #24]
 800702c:	2301      	movs	r3, #1
 800702e:	e747      	b.n	8006ec0 <displayPutChar+0x4c>
 8007030:	2000888c 	.word	0x2000888c
 8007034:	20008ac4 	.word	0x20008ac4
 8007038:	aaaaaaab 	.word	0xaaaaaaab
 800703c:	20008ac5 	.word	0x20008ac5
 8007040:	20004098 	.word	0x20004098
 8007044:	2000408c 	.word	0x2000408c

08007048 <displayPrint>:
{
 8007048:	b510      	push	{r4, lr}
 800704a:	b082      	sub	sp, #8
 800704c:	4604      	mov	r4, r0
 800704e:	9101      	str	r1, [sp, #4]
	while(*text != 0)
 8007050:	7800      	ldrb	r0, [r0, #0]
 8007052:	b130      	cbz	r0, 8007062 <displayPrint+0x1a>
		displayPutChar(*text, color);
 8007054:	9901      	ldr	r1, [sp, #4]
 8007056:	f7ff ff0d 	bl	8006e74 <displayPutChar>
	while(*text != 0)
 800705a:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 800705e:	2800      	cmp	r0, #0
 8007060:	d1f8      	bne.n	8007054 <displayPrint+0xc>
}
 8007062:	b002      	add	sp, #8
 8007064:	bd10      	pop	{r4, pc}
 8007066:	bf00      	nop

08007068 <mountSD>:
{
 8007068:	b508      	push	{r3, lr}
   res=f_mount(&myFAT, "", 1);
 800706a:	2201      	movs	r2, #1
 800706c:	4903      	ldr	r1, [pc, #12]	; (800707c <mountSD+0x14>)
 800706e:	4804      	ldr	r0, [pc, #16]	; (8007080 <mountSD+0x18>)
 8007070:	f7fc f90e 	bl	8003290 <f_mount>
}
 8007074:	fab0 f080 	clz	r0, r0
 8007078:	0940      	lsrs	r0, r0, #5
 800707a:	bd08      	pop	{r3, pc}
 800707c:	08007e2c 	.word	0x08007e2c
 8007080:	20008894 	.word	0x20008894

08007084 <unmountSD>:
   f_mount(0, 0, 1);
 8007084:	2100      	movs	r1, #0
 8007086:	4608      	mov	r0, r1
 8007088:	2201      	movs	r2, #1
 800708a:	f7fc b901 	b.w	8003290 <f_mount>
 800708e:	bf00      	nop

08007090 <displayLoadImageSD>:
{
 8007090:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007094:	f2ad 7dd4 	subw	sp, sp, #2004	; 0x7d4
 8007098:	4604      	mov	r4, r0
 800709a:	9101      	str	r1, [sp, #4]
    uint8_t img_line[DISPLAY_WIDTH*4]={0};
 800709c:	f44f 72c0 	mov.w	r2, #384	; 0x180
 80070a0:	2100      	movs	r1, #0
 80070a2:	a808      	add	r0, sp, #32
 80070a4:	f000 f9f4 	bl	8007490 <memset>
    f_open(&myFile, file_path, FA_READ);
 80070a8:	2201      	movs	r2, #1
 80070aa:	4621      	mov	r1, r4
 80070ac:	a868      	add	r0, sp, #416	; 0x1a0
 80070ae:	f7fc f937 	bl	8003320 <f_open>
    f_lseek(&myFile, BMP_DIB); 
 80070b2:	210e      	movs	r1, #14
 80070b4:	a868      	add	r0, sp, #416	; 0x1a0
 80070b6:	f7fc fdbd 	bl	8003c34 <f_lseek>
    f_read(&myFile, &data, 4, &byteCount);
 80070ba:	ab06      	add	r3, sp, #24
 80070bc:	2204      	movs	r2, #4
 80070be:	a907      	add	r1, sp, #28
 80070c0:	a868      	add	r0, sp, #416	; 0x1a0
 80070c2:	f7fc fb21 	bl	8003708 <f_read>
    f_lseek(&myFile, BMP_WIDTH);
 80070c6:	2112      	movs	r1, #18
 80070c8:	a868      	add	r0, sp, #416	; 0x1a0
    bmp_offset=((data[3]<<24)|(data[2]<<16) |(data[1]<<8)|(data[0]))+BMP_DIB;
 80070ca:	9f07      	ldr	r7, [sp, #28]
    f_lseek(&myFile, BMP_WIDTH);
 80070cc:	f7fc fdb2 	bl	8003c34 <f_lseek>
    f_read(&myFile, &data, 4, &byteCount);
 80070d0:	ab06      	add	r3, sp, #24
 80070d2:	2204      	movs	r2, #4
 80070d4:	a907      	add	r1, sp, #28
 80070d6:	a868      	add	r0, sp, #416	; 0x1a0
 80070d8:	f7fc fb16 	bl	8003708 <f_read>
    f_lseek(&myFile, BMP_HEIGHT);
 80070dc:	2116      	movs	r1, #22
 80070de:	a868      	add	r0, sp, #416	; 0x1a0
 80070e0:	f8dd a01c 	ldr.w	sl, [sp, #28]
 80070e4:	f7fc fda6 	bl	8003c34 <f_lseek>
    f_read(&myFile, &data, 4, &byteCount);
 80070e8:	ab06      	add	r3, sp, #24
 80070ea:	2204      	movs	r2, #4
 80070ec:	a907      	add	r1, sp, #28
 80070ee:	a868      	add	r0, sp, #416	; 0x1a0
 80070f0:	f7fc fb0a 	bl	8003708 <f_read>
    f_lseek(&myFile, BMP_BPP);
 80070f4:	211c      	movs	r1, #28
 80070f6:	a868      	add	r0, sp, #416	; 0x1a0
 80070f8:	9e07      	ldr	r6, [sp, #28]
 80070fa:	f7fc fd9b 	bl	8003c34 <f_lseek>
    f_read(&myFile, &data, 4, &byteCount);
 80070fe:	ab06      	add	r3, sp, #24
 8007100:	a907      	add	r1, sp, #28
 8007102:	a868      	add	r0, sp, #416	; 0x1a0
 8007104:	2204      	movs	r2, #4
 8007106:	f7fc faff 	bl	8003708 <f_read>
 800710a:	f8bd 901c 	ldrh.w	r9, [sp, #28]
    if(BMP_bpp<=8)
 800710e:	f1b9 0f08 	cmp.w	r9, #8
    bmp_offset=((data[3]<<24)|(data[2]<<16) |(data[1]<<8)|(data[0]))+BMP_DIB;
 8007112:	f107 070e 	add.w	r7, r7, #14
    if(BMP_bpp<=8)
 8007116:	f340 80f3 	ble.w	8007300 <displayLoadImageSD+0x270>
    f_lseek(&myFile, bmp_offset); 
 800711a:	4639      	mov	r1, r7
 800711c:	a868      	add	r0, sp, #416	; 0x1a0
 800711e:	f7fc fd89 	bl	8003c34 <f_lseek>
    format=BMP_bpp>>3;
 8007122:	f3c9 05c7 	ubfx	r5, r9, #3, #8
    if(format>3)format=3;
 8007126:	2d03      	cmp	r5, #3
 8007128:	f200 80e3 	bhi.w	80072f2 <displayLoadImageSD+0x262>
    if(!bytes) // 2 pixels per 1 byte 
 800712c:	2d00      	cmp	r5, #0
 800712e:	f040 8113 	bne.w	8007358 <displayLoadImageSD+0x2c8>
 8007132:	f04f 0801 	mov.w	r8, #1
      pixels=1;  
 8007136:	f8cd 8000 	str.w	r8, [sp]
      bytes=1;
 800713a:	4644      	mov	r4, r8
    endX=img_width+positionX;
 800713c:	4b89      	ldr	r3, [pc, #548]	; (8007364 <displayLoadImageSD+0x2d4>)
    endY=img_height+positionY; 
 800713e:	f8df b230 	ldr.w	fp, [pc, #560]	; 8007370 <displayLoadImageSD+0x2e0>
    endX=img_width+positionX;
 8007142:	781a      	ldrb	r2, [r3, #0]
    endY=img_height+positionY; 
 8007144:	f89b 3000 	ldrb.w	r3, [fp]
    endX=img_width+positionX;
 8007148:	4452      	add	r2, sl
 800714a:	2a60      	cmp	r2, #96	; 0x60
    endY=img_height+positionY; 
 800714c:	441e      	add	r6, r3
 800714e:	bf28      	it	cs
 8007150:	2260      	movcs	r2, #96	; 0x60
    if((endY)>DISPLAY_HEIGHT)
 8007152:	2e40      	cmp	r6, #64	; 0x40
 8007154:	9203      	str	r2, [sp, #12]
 8007156:	f200 80ef 	bhi.w	8007338 <displayLoadImageSD+0x2a8>
 800715a:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 800715e:	0152      	lsls	r2, r2, #5
 8007160:	3a60      	subs	r2, #96	; 0x60
 8007162:	4611      	mov	r1, r2
 8007164:	9202      	str	r2, [sp, #8]
    for(y=positionY;y<endY;y++)
 8007166:	429e      	cmp	r6, r3
    line=positionY*DISPLAY_WIDTH;
 8007168:	f04f 0260 	mov.w	r2, #96	; 0x60
    last_line=(endY-1)*DISPLAY_WIDTH+line;
 800716c:	fb12 1103 	smlabb	r1, r2, r3, r1
    line=positionY*DISPLAY_WIDTH;
 8007170:	fb13 f202 	smulbb	r2, r3, r2
    for(y=positionY;y<endY;y++)
 8007174:	d96f      	bls.n	8007256 <displayLoadImageSD+0x1c6>
 8007176:	1b9b      	subs	r3, r3, r6
 8007178:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800717c:	9803      	ldr	r0, [sp, #12]
	b=gamma_curve[bCh(color)&chMask];
 800717e:	4f7a      	ldr	r7, [pc, #488]	; (8007368 <displayLoadImageSD+0x2d8>)
 8007180:	ebc2 1343 	rsb	r3, r2, r3, lsl #5
 8007184:	440b      	add	r3, r1
        f_read(&myFile, &img_line, (img_width)*bytes>>pixels, &byteCount);
 8007186:	fb04 fa0a 	mul.w	sl, r4, sl
 800718a:	1a86      	subs	r6, r0, r2
 800718c:	9304      	str	r3, [sp, #16]
 800718e:	fa2a f308 	lsr.w	r3, sl, r8
 8007192:	440e      	add	r6, r1
 8007194:	9305      	str	r3, [sp, #20]
 8007196:	4b75      	ldr	r3, [pc, #468]	; (800736c <displayLoadImageSD+0x2dc>)
 8007198:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 800719c:	441e      	add	r6, r3
 800719e:	ab06      	add	r3, sp, #24
 80071a0:	9a05      	ldr	r2, [sp, #20]
 80071a2:	a908      	add	r1, sp, #32
 80071a4:	a868      	add	r0, sp, #416	; 0x1a0
 80071a6:	f7fc faaf 	bl	8003708 <f_read>
        for(x=positionX;x<endX;x++)
 80071aa:	4b6e      	ldr	r3, [pc, #440]	; (8007364 <displayLoadImageSD+0x2d4>)
 80071ac:	9a03      	ldr	r2, [sp, #12]
 80071ae:	781b      	ldrb	r3, [r3, #0]
 80071b0:	4293      	cmp	r3, r2
 80071b2:	d248      	bcs.n	8007246 <displayLoadImageSD+0x1b6>
 80071b4:	9a02      	ldr	r2, [sp, #8]
 80071b6:	4413      	add	r3, r2
 80071b8:	4a6c      	ldr	r2, [pc, #432]	; (800736c <displayLoadImageSD+0x2dc>)
 80071ba:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80071be:	eb02 0c03 	add.w	ip, r2, r3
 80071c2:	f04f 0e00 	mov.w	lr, #0
                color=(color_palette[4*color]|(color_palette[4*color+1]<<8)|(color_palette[4*color+2]<<16));
 80071c6:	f50d 7a74 	add.w	sl, sp, #976	; 0x3d0
            for(i=0;i<bytes;i++) color|=img_line[(x_offset>>pixels)+i]<<(i<<3);
 80071ca:	fa2e f008 	lsr.w	r0, lr, r8
 80071ce:	3801      	subs	r0, #1
 80071d0:	2100      	movs	r1, #0
 80071d2:	ab08      	add	r3, sp, #32
 80071d4:	4418      	add	r0, r3
            color=0;
 80071d6:	460a      	mov	r2, r1
            for(i=0;i<bytes;i++) color|=img_line[(x_offset>>pixels)+i]<<(i<<3);
 80071d8:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80071dc:	ea4f 0bc1 	mov.w	fp, r1, lsl #3
 80071e0:	3101      	adds	r1, #1
 80071e2:	fa03 f30b 	lsl.w	r3, r3, fp
 80071e6:	fa5f fb81 	uxtb.w	fp, r1
 80071ea:	45a3      	cmp	fp, r4
 80071ec:	ea42 0203 	orr.w	r2, r2, r3
 80071f0:	d3f2      	bcc.n	80071d8 <displayLoadImageSD+0x148>
            if(pixels)color=(color>>((~x_offset&pixels)<<2))&0x0F; //get only nibble 
 80071f2:	9b00      	ldr	r3, [sp, #0]
 80071f4:	b14b      	cbz	r3, 800720a <displayLoadImageSD+0x17a>
 80071f6:	ea4f 038e 	mov.w	r3, lr, lsl #2
 80071fa:	f083 0303 	eor.w	r3, r3, #3
 80071fe:	43db      	mvns	r3, r3
 8007200:	f003 0304 	and.w	r3, r3, #4
 8007204:	40da      	lsrs	r2, r3
 8007206:	f002 020f 	and.w	r2, r2, #15
            if(BMP_bpp<=8)
 800720a:	f1b9 0f08 	cmp.w	r9, #8
 800720e:	dc40      	bgt.n	8007292 <displayLoadImageSD+0x202>
                color=(color_palette[4*color]|(color_palette[4*color+1]<<8)|(color_palette[4*color+2]<<16));
 8007210:	eb0a 0382 	add.w	r3, sl, r2, lsl #2
 8007214:	f81a 1022 	ldrb.w	r1, [sl, r2, lsl #2]
 8007218:	789a      	ldrb	r2, [r3, #2]
 800721a:	785b      	ldrb	r3, [r3, #1]
 800721c:	0412      	lsls	r2, r2, #16
 800721e:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8007222:	430a      	orrs	r2, r1
 8007224:	b2d1      	uxtb	r1, r2
                format=3;
 8007226:	2503      	movs	r5, #3
            if(gamma_corrected)px=gammaCorrected(px);
 8007228:	9801      	ldr	r0, [sp, #4]
            px=color2px(color);
 800722a:	0a13      	lsrs	r3, r2, #8
 800722c:	0c12      	lsrs	r2, r2, #16
            if(gamma_corrected)px=gammaCorrected(px);
 800722e:	b9c8      	cbnz	r0, 8007264 <displayLoadImageSD+0x1d4>
            setFRAMEpx(x+last_line-line,px);
 8007230:	f88c 1000 	strb.w	r1, [ip]
            px=color2px(color);
 8007234:	f88c 3001 	strb.w	r3, [ip, #1]
 8007238:	f88c 2002 	strb.w	r2, [ip, #2]
 800723c:	f10c 0c03 	add.w	ip, ip, #3
        for(x=positionX;x<endX;x++)
 8007240:	4566      	cmp	r6, ip
 8007242:	44a6      	add	lr, r4
 8007244:	d1c1      	bne.n	80071ca <displayLoadImageSD+0x13a>
 8007246:	9b02      	ldr	r3, [sp, #8]
    for(y=positionY;y<endY;y++)
 8007248:	9a04      	ldr	r2, [sp, #16]
 800724a:	3b60      	subs	r3, #96	; 0x60
 800724c:	4293      	cmp	r3, r2
 800724e:	9302      	str	r3, [sp, #8]
 8007250:	f5a6 7690 	sub.w	r6, r6, #288	; 0x120
 8007254:	d1a3      	bne.n	800719e <displayLoadImageSD+0x10e>
    f_close(&myFile);
 8007256:	a868      	add	r0, sp, #416	; 0x1a0
 8007258:	f7fc fc24 	bl	8003aa4 <f_close>
}
 800725c:	f20d 7dd4 	addw	sp, sp, #2004	; 0x7d4
 8007260:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	r=gamma_curve[rCh(color)&chMask];
 8007264:	b2d2      	uxtb	r2, r2
	g=gamma_curve[gCh(color)&chMask];
 8007266:	b2d8      	uxtb	r0, r3
	return color2px(mixCh(r,g,b));
 8007268:	5cbb      	ldrb	r3, [r7, r2]
 800726a:	5c38      	ldrb	r0, [r7, r0]
	b=gamma_curve[bCh(color)&chMask];
 800726c:	5c7a      	ldrb	r2, [r7, r1]
            setFRAMEpx(x+last_line-line,px);
 800726e:	f88c 2000 	strb.w	r2, [ip]
	return color2px(mixCh(r,g,b));
 8007272:	041b      	lsls	r3, r3, #16
 8007274:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8007278:	4313      	orrs	r3, r2
 800727a:	121a      	asrs	r2, r3, #8
 800727c:	141b      	asrs	r3, r3, #16
 800727e:	f88c 2001 	strb.w	r2, [ip, #1]
 8007282:	f88c 3002 	strb.w	r3, [ip, #2]
 8007286:	f10c 0c03 	add.w	ip, ip, #3
        for(x=positionX;x<endX;x++)
 800728a:	45b4      	cmp	ip, r6
 800728c:	44a6      	add	lr, r4
 800728e:	d19c      	bne.n	80071ca <displayLoadImageSD+0x13a>
 8007290:	e7d9      	b.n	8007246 <displayLoadImageSD+0x1b6>
            if(format!=DEFAULT_FORMAT) color=convertRGB(format,DEFAULT_FORMAT,color);
 8007292:	2d03      	cmp	r5, #3
 8007294:	b2d1      	uxtb	r1, r2
 8007296:	d0c7      	beq.n	8007228 <displayLoadImageSD+0x198>
    if(src==0)//RGB111
 8007298:	b965      	cbnz	r5, 80072b4 <displayLoadImageSD+0x224>
        else if(dst==3) return ((r<<23)|(g<<15)|(b<<7));
 800729a:	f3c2 0340 	ubfx	r3, r2, #1, #1
 800729e:	03db      	lsls	r3, r3, #15
 80072a0:	f3c2 0280 	ubfx	r2, r2, #2, #1
 80072a4:	f001 0101 	and.w	r1, r1, #1
 80072a8:	ea43 52c2 	orr.w	r2, r3, r2, lsl #23
 80072ac:	ea42 12c1 	orr.w	r2, r2, r1, lsl #7
 80072b0:	b2d1      	uxtb	r1, r2
 80072b2:	e7b9      	b.n	8007228 <displayLoadImageSD+0x198>
    else if(src==1)//RGB332
 80072b4:	2d01      	cmp	r5, #1
 80072b6:	f3c2 1347 	ubfx	r3, r2, #5, #8
 80072ba:	d00d      	beq.n	80072d8 <displayLoadImageSD+0x248>
        else if(dst==3) return ((r<<19)|(g<<10)|(b<<3));
 80072bc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80072c0:	029b      	lsls	r3, r3, #10
 80072c2:	f3c2 22c4 	ubfx	r2, r2, #11, #5
 80072c6:	f001 011f 	and.w	r1, r1, #31
 80072ca:	ea43 42c2 	orr.w	r2, r3, r2, lsl #19
 80072ce:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 80072d2:	b2d1      	uxtb	r1, r2
 80072d4:	2502      	movs	r5, #2
 80072d6:	e7a7      	b.n	8007228 <displayLoadImageSD+0x198>
        else if(dst==3) return ((r<<21)|(g<<13)|(b<<6));
 80072d8:	f003 0307 	and.w	r3, r3, #7
 80072dc:	055b      	lsls	r3, r3, #21
 80072de:	f3c2 0282 	ubfx	r2, r2, #2, #3
 80072e2:	f001 0103 	and.w	r1, r1, #3
 80072e6:	ea43 3242 	orr.w	r2, r3, r2, lsl #13
 80072ea:	ea42 1281 	orr.w	r2, r2, r1, lsl #6
 80072ee:	b2d1      	uxtb	r1, r2
 80072f0:	e79a      	b.n	8007228 <displayLoadImageSD+0x198>
 80072f2:	f04f 0800 	mov.w	r8, #0
 80072f6:	462c      	mov	r4, r5
    pixels=0;
 80072f8:	f8cd 8000 	str.w	r8, [sp]
    if(format>3)format=3;
 80072fc:	2503      	movs	r5, #3
 80072fe:	e71d      	b.n	800713c <displayLoadImageSD+0xac>
        f_lseek(&myFile, BMP_COLORS);
 8007300:	212e      	movs	r1, #46	; 0x2e
 8007302:	a868      	add	r0, sp, #416	; 0x1a0
 8007304:	f7fc fc96 	bl	8003c34 <f_lseek>
        f_read(&myFile, &data, 4, &byteCount);
 8007308:	a907      	add	r1, sp, #28
 800730a:	ab06      	add	r3, sp, #24
 800730c:	2204      	movs	r2, #4
 800730e:	a868      	add	r0, sp, #416	; 0x1a0
 8007310:	f7fc f9fa 	bl	8003708 <f_read>
 8007314:	9c07      	ldr	r4, [sp, #28]
    f_lseek(&myFile, bmp_offset); 
 8007316:	4639      	mov	r1, r7
 8007318:	a868      	add	r0, sp, #416	; 0x1a0
 800731a:	f7fc fc8b 	bl	8003c34 <f_lseek>
        if(n_colors==0)n_colors=(1<<BMP_bpp);
 800731e:	b914      	cbnz	r4, 8007326 <displayLoadImageSD+0x296>
 8007320:	2401      	movs	r4, #1
 8007322:	fa04 f409 	lsl.w	r4, r4, r9
        f_read(&myFile, &color_palette, 4*n_colors, &byteCount);
 8007326:	00a4      	lsls	r4, r4, #2
 8007328:	4622      	mov	r2, r4
 800732a:	ab06      	add	r3, sp, #24
 800732c:	a9f4      	add	r1, sp, #976	; 0x3d0
 800732e:	a868      	add	r0, sp, #416	; 0x1a0
 8007330:	f7fc f9ea 	bl	8003708 <f_read>
        bmp_offset+=4*n_colors;
 8007334:	4427      	add	r7, r4
 8007336:	e6f4      	b.n	8007122 <displayLoadImageSD+0x92>
        bmp_offset=bmp_offset+(img_width>>pixels)*(endY-DISPLAY_HEIGHT)*bytes;
 8007338:	fa2a f208 	lsr.w	r2, sl, r8
 800733c:	fb04 f202 	mul.w	r2, r4, r2
 8007340:	3e40      	subs	r6, #64	; 0x40
        f_lseek(&myFile, bmp_offset); 
 8007342:	fb06 7102 	mla	r1, r6, r2, r7
 8007346:	a868      	add	r0, sp, #416	; 0x1a0
 8007348:	f7fc fc74 	bl	8003c34 <f_lseek>
        endY=DISPLAY_HEIGHT;
 800734c:	2640      	movs	r6, #64	; 0x40
 800734e:	f89b 3000 	ldrb.w	r3, [fp]
        f_lseek(&myFile, bmp_offset); 
 8007352:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 8007356:	e703      	b.n	8007160 <displayLoadImageSD+0xd0>
    if(!bytes) // 2 pixels per 1 byte 
 8007358:	f04f 0800 	mov.w	r8, #0
    pixels=0;
 800735c:	f8cd 8000 	str.w	r8, [sp]
    if(!bytes) // 2 pixels per 1 byte 
 8007360:	462c      	mov	r4, r5
 8007362:	e6eb      	b.n	800713c <displayLoadImageSD+0xac>
 8007364:	20008ac4 	.word	0x20008ac4
 8007368:	0800808c 	.word	0x0800808c
 800736c:	2000408c 	.word	0x2000408c
 8007370:	20008ac5 	.word	0x20008ac5

08007374 <displayPlayImagesSD>:
{
 8007374:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007376:	b0a1      	sub	sp, #132	; 0x84
 8007378:	4604      	mov	r4, r0
 800737a:	460f      	mov	r7, r1
 800737c:	4616      	mov	r6, r2
    char path[50]={0};
 800737e:	2100      	movs	r1, #0
 8007380:	2232      	movs	r2, #50	; 0x32
 8007382:	a813      	add	r0, sp, #76	; 0x4c
 8007384:	f000 f884 	bl	8007490 <memset>
    f_opendir(&dir, file_path);
 8007388:	4621      	mov	r1, r4
 800738a:	a807      	add	r0, sp, #28
 800738c:	f7fc ff2a 	bl	80041e4 <f_opendir>
        sprintf((char*)path, "%s/%s",file_path, fno.fname);
 8007390:	4d11      	ldr	r5, [pc, #68]	; (80073d8 <displayPlayImagesSD+0x64>)
        res = f_readdir(&dir, &fno); 
 8007392:	a901      	add	r1, sp, #4
 8007394:	a807      	add	r0, sp, #28
 8007396:	f7fc ffd5 	bl	8004344 <f_readdir>
        if (res != FR_OK || fno.fname[0] == 0) break;
 800739a:	b9b8      	cbnz	r0, 80073cc <displayPlayImagesSD+0x58>
 800739c:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80073a0:	b1a3      	cbz	r3, 80073cc <displayPlayImagesSD+0x58>
        sprintf((char*)path, "%s/%s",file_path, fno.fname);
 80073a2:	4622      	mov	r2, r4
 80073a4:	f10d 030d 	add.w	r3, sp, #13
 80073a8:	4629      	mov	r1, r5
 80073aa:	a813      	add	r0, sp, #76	; 0x4c
 80073ac:	f000 f878 	bl	80074a0 <siprintf>
        displayLoadImageSD(path, gamma_corrected);
 80073b0:	4631      	mov	r1, r6
 80073b2:	a813      	add	r0, sp, #76	; 0x4c
 80073b4:	f7ff fe6c 	bl	8007090 <displayLoadImageSD>
        DELAY(time);
 80073b8:	463a      	mov	r2, r7
    while(delay--)
 80073ba:	f112 32ff 	adds.w	r2, r2, #4294967295
 80073be:	d3e8      	bcc.n	8007392 <displayPlayImagesSD+0x1e>
 80073c0:	f24a 4310 	movw	r3, #42000	; 0xa410
    while(nops--) NOP();
 80073c4:	bf00      	nop
 80073c6:	3b01      	subs	r3, #1
 80073c8:	d1fc      	bne.n	80073c4 <displayPlayImagesSD+0x50>
 80073ca:	e7f6      	b.n	80073ba <displayPlayImagesSD+0x46>
	f_closedir(&dir);  
 80073cc:	a807      	add	r0, sp, #28
 80073ce:	f7fc ff85 	bl	80042dc <f_closedir>
}
 80073d2:	b021      	add	sp, #132	; 0x84
 80073d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80073d6:	bf00      	nop
 80073d8:	08008084 	.word	0x08008084

080073dc <displayDelay>:
    while(delay--)
 80073dc:	f110 30ff 	adds.w	r0, r0, #4294967295
 80073e0:	d307      	bcc.n	80073f2 <displayDelay+0x16>
 80073e2:	f24a 4310 	movw	r3, #42000	; 0xa410
    while(nops--) NOP();
 80073e6:	bf00      	nop
 80073e8:	3b01      	subs	r3, #1
 80073ea:	d1fc      	bne.n	80073e6 <displayDelay+0xa>
    while(delay--)
 80073ec:	f110 30ff 	adds.w	r0, r0, #4294967295
 80073f0:	d2f7      	bcs.n	80073e2 <displayDelay+0x6>
    }
}
void displayDelay(uint16_t time)
{
    DELAY(time);
}
 80073f2:	4770      	bx	lr

080073f4 <__errno>:
 80073f4:	4b01      	ldr	r3, [pc, #4]	; (80073fc <__errno+0x8>)
 80073f6:	6818      	ldr	r0, [r3, #0]
 80073f8:	4770      	bx	lr
 80073fa:	bf00      	nop
 80073fc:	20000028 	.word	0x20000028

08007400 <__libc_init_array>:
 8007400:	b570      	push	{r4, r5, r6, lr}
 8007402:	4e0d      	ldr	r6, [pc, #52]	; (8007438 <__libc_init_array+0x38>)
 8007404:	4c0d      	ldr	r4, [pc, #52]	; (800743c <__libc_init_array+0x3c>)
 8007406:	1ba4      	subs	r4, r4, r6
 8007408:	10a4      	asrs	r4, r4, #2
 800740a:	2500      	movs	r5, #0
 800740c:	42a5      	cmp	r5, r4
 800740e:	d109      	bne.n	8007424 <__libc_init_array+0x24>
 8007410:	4e0b      	ldr	r6, [pc, #44]	; (8007440 <__libc_init_array+0x40>)
 8007412:	4c0c      	ldr	r4, [pc, #48]	; (8007444 <__libc_init_array+0x44>)
 8007414:	f000 fc26 	bl	8007c64 <_init>
 8007418:	1ba4      	subs	r4, r4, r6
 800741a:	10a4      	asrs	r4, r4, #2
 800741c:	2500      	movs	r5, #0
 800741e:	42a5      	cmp	r5, r4
 8007420:	d105      	bne.n	800742e <__libc_init_array+0x2e>
 8007422:	bd70      	pop	{r4, r5, r6, pc}
 8007424:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8007428:	4798      	blx	r3
 800742a:	3501      	adds	r5, #1
 800742c:	e7ee      	b.n	800740c <__libc_init_array+0xc>
 800742e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8007432:	4798      	blx	r3
 8007434:	3501      	adds	r5, #1
 8007436:	e7f2      	b.n	800741e <__libc_init_array+0x1e>
 8007438:	080081c8 	.word	0x080081c8
 800743c:	080081c8 	.word	0x080081c8
 8007440:	080081c8 	.word	0x080081c8
 8007444:	080081cc 	.word	0x080081cc

08007448 <memcpy>:
 8007448:	b510      	push	{r4, lr}
 800744a:	1e43      	subs	r3, r0, #1
 800744c:	440a      	add	r2, r1
 800744e:	4291      	cmp	r1, r2
 8007450:	d100      	bne.n	8007454 <memcpy+0xc>
 8007452:	bd10      	pop	{r4, pc}
 8007454:	f811 4b01 	ldrb.w	r4, [r1], #1
 8007458:	f803 4f01 	strb.w	r4, [r3, #1]!
 800745c:	e7f7      	b.n	800744e <memcpy+0x6>

0800745e <memmove>:
 800745e:	4288      	cmp	r0, r1
 8007460:	b510      	push	{r4, lr}
 8007462:	eb01 0302 	add.w	r3, r1, r2
 8007466:	d807      	bhi.n	8007478 <memmove+0x1a>
 8007468:	1e42      	subs	r2, r0, #1
 800746a:	4299      	cmp	r1, r3
 800746c:	d00a      	beq.n	8007484 <memmove+0x26>
 800746e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8007472:	f802 4f01 	strb.w	r4, [r2, #1]!
 8007476:	e7f8      	b.n	800746a <memmove+0xc>
 8007478:	4283      	cmp	r3, r0
 800747a:	d9f5      	bls.n	8007468 <memmove+0xa>
 800747c:	1881      	adds	r1, r0, r2
 800747e:	1ad2      	subs	r2, r2, r3
 8007480:	42d3      	cmn	r3, r2
 8007482:	d100      	bne.n	8007486 <memmove+0x28>
 8007484:	bd10      	pop	{r4, pc}
 8007486:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800748a:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800748e:	e7f7      	b.n	8007480 <memmove+0x22>

08007490 <memset>:
 8007490:	4402      	add	r2, r0
 8007492:	4603      	mov	r3, r0
 8007494:	4293      	cmp	r3, r2
 8007496:	d100      	bne.n	800749a <memset+0xa>
 8007498:	4770      	bx	lr
 800749a:	f803 1b01 	strb.w	r1, [r3], #1
 800749e:	e7f9      	b.n	8007494 <memset+0x4>

080074a0 <siprintf>:
 80074a0:	b40e      	push	{r1, r2, r3}
 80074a2:	b500      	push	{lr}
 80074a4:	b09c      	sub	sp, #112	; 0x70
 80074a6:	ab1d      	add	r3, sp, #116	; 0x74
 80074a8:	9002      	str	r0, [sp, #8]
 80074aa:	9006      	str	r0, [sp, #24]
 80074ac:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80074b0:	4809      	ldr	r0, [pc, #36]	; (80074d8 <siprintf+0x38>)
 80074b2:	9107      	str	r1, [sp, #28]
 80074b4:	9104      	str	r1, [sp, #16]
 80074b6:	4909      	ldr	r1, [pc, #36]	; (80074dc <siprintf+0x3c>)
 80074b8:	f853 2b04 	ldr.w	r2, [r3], #4
 80074bc:	9105      	str	r1, [sp, #20]
 80074be:	6800      	ldr	r0, [r0, #0]
 80074c0:	9301      	str	r3, [sp, #4]
 80074c2:	a902      	add	r1, sp, #8
 80074c4:	f000 f90e 	bl	80076e4 <_svfiprintf_r>
 80074c8:	9b02      	ldr	r3, [sp, #8]
 80074ca:	2200      	movs	r2, #0
 80074cc:	701a      	strb	r2, [r3, #0]
 80074ce:	b01c      	add	sp, #112	; 0x70
 80074d0:	f85d eb04 	ldr.w	lr, [sp], #4
 80074d4:	b003      	add	sp, #12
 80074d6:	4770      	bx	lr
 80074d8:	20000028 	.word	0x20000028
 80074dc:	ffff0208 	.word	0xffff0208

080074e0 <_free_r>:
 80074e0:	b538      	push	{r3, r4, r5, lr}
 80074e2:	4605      	mov	r5, r0
 80074e4:	2900      	cmp	r1, #0
 80074e6:	d045      	beq.n	8007574 <_free_r+0x94>
 80074e8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80074ec:	1f0c      	subs	r4, r1, #4
 80074ee:	2b00      	cmp	r3, #0
 80074f0:	bfb8      	it	lt
 80074f2:	18e4      	addlt	r4, r4, r3
 80074f4:	f000 fb86 	bl	8007c04 <__malloc_lock>
 80074f8:	4a1f      	ldr	r2, [pc, #124]	; (8007578 <_free_r+0x98>)
 80074fa:	6813      	ldr	r3, [r2, #0]
 80074fc:	4610      	mov	r0, r2
 80074fe:	b933      	cbnz	r3, 800750e <_free_r+0x2e>
 8007500:	6063      	str	r3, [r4, #4]
 8007502:	6014      	str	r4, [r2, #0]
 8007504:	4628      	mov	r0, r5
 8007506:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800750a:	f000 bb7c 	b.w	8007c06 <__malloc_unlock>
 800750e:	42a3      	cmp	r3, r4
 8007510:	d90c      	bls.n	800752c <_free_r+0x4c>
 8007512:	6821      	ldr	r1, [r4, #0]
 8007514:	1862      	adds	r2, r4, r1
 8007516:	4293      	cmp	r3, r2
 8007518:	bf04      	itt	eq
 800751a:	681a      	ldreq	r2, [r3, #0]
 800751c:	685b      	ldreq	r3, [r3, #4]
 800751e:	6063      	str	r3, [r4, #4]
 8007520:	bf04      	itt	eq
 8007522:	1852      	addeq	r2, r2, r1
 8007524:	6022      	streq	r2, [r4, #0]
 8007526:	6004      	str	r4, [r0, #0]
 8007528:	e7ec      	b.n	8007504 <_free_r+0x24>
 800752a:	4613      	mov	r3, r2
 800752c:	685a      	ldr	r2, [r3, #4]
 800752e:	b10a      	cbz	r2, 8007534 <_free_r+0x54>
 8007530:	42a2      	cmp	r2, r4
 8007532:	d9fa      	bls.n	800752a <_free_r+0x4a>
 8007534:	6819      	ldr	r1, [r3, #0]
 8007536:	1858      	adds	r0, r3, r1
 8007538:	42a0      	cmp	r0, r4
 800753a:	d10b      	bne.n	8007554 <_free_r+0x74>
 800753c:	6820      	ldr	r0, [r4, #0]
 800753e:	4401      	add	r1, r0
 8007540:	1858      	adds	r0, r3, r1
 8007542:	4282      	cmp	r2, r0
 8007544:	6019      	str	r1, [r3, #0]
 8007546:	d1dd      	bne.n	8007504 <_free_r+0x24>
 8007548:	6810      	ldr	r0, [r2, #0]
 800754a:	6852      	ldr	r2, [r2, #4]
 800754c:	605a      	str	r2, [r3, #4]
 800754e:	4401      	add	r1, r0
 8007550:	6019      	str	r1, [r3, #0]
 8007552:	e7d7      	b.n	8007504 <_free_r+0x24>
 8007554:	d902      	bls.n	800755c <_free_r+0x7c>
 8007556:	230c      	movs	r3, #12
 8007558:	602b      	str	r3, [r5, #0]
 800755a:	e7d3      	b.n	8007504 <_free_r+0x24>
 800755c:	6820      	ldr	r0, [r4, #0]
 800755e:	1821      	adds	r1, r4, r0
 8007560:	428a      	cmp	r2, r1
 8007562:	bf04      	itt	eq
 8007564:	6811      	ldreq	r1, [r2, #0]
 8007566:	6852      	ldreq	r2, [r2, #4]
 8007568:	6062      	str	r2, [r4, #4]
 800756a:	bf04      	itt	eq
 800756c:	1809      	addeq	r1, r1, r0
 800756e:	6021      	streq	r1, [r4, #0]
 8007570:	605c      	str	r4, [r3, #4]
 8007572:	e7c7      	b.n	8007504 <_free_r+0x24>
 8007574:	bd38      	pop	{r3, r4, r5, pc}
 8007576:	bf00      	nop
 8007578:	20008ac8 	.word	0x20008ac8

0800757c <_malloc_r>:
 800757c:	b570      	push	{r4, r5, r6, lr}
 800757e:	1ccd      	adds	r5, r1, #3
 8007580:	f025 0503 	bic.w	r5, r5, #3
 8007584:	3508      	adds	r5, #8
 8007586:	2d0c      	cmp	r5, #12
 8007588:	bf38      	it	cc
 800758a:	250c      	movcc	r5, #12
 800758c:	2d00      	cmp	r5, #0
 800758e:	4606      	mov	r6, r0
 8007590:	db01      	blt.n	8007596 <_malloc_r+0x1a>
 8007592:	42a9      	cmp	r1, r5
 8007594:	d903      	bls.n	800759e <_malloc_r+0x22>
 8007596:	230c      	movs	r3, #12
 8007598:	6033      	str	r3, [r6, #0]
 800759a:	2000      	movs	r0, #0
 800759c:	bd70      	pop	{r4, r5, r6, pc}
 800759e:	f000 fb31 	bl	8007c04 <__malloc_lock>
 80075a2:	4a21      	ldr	r2, [pc, #132]	; (8007628 <_malloc_r+0xac>)
 80075a4:	6814      	ldr	r4, [r2, #0]
 80075a6:	4621      	mov	r1, r4
 80075a8:	b991      	cbnz	r1, 80075d0 <_malloc_r+0x54>
 80075aa:	4c20      	ldr	r4, [pc, #128]	; (800762c <_malloc_r+0xb0>)
 80075ac:	6823      	ldr	r3, [r4, #0]
 80075ae:	b91b      	cbnz	r3, 80075b8 <_malloc_r+0x3c>
 80075b0:	4630      	mov	r0, r6
 80075b2:	f000 fb17 	bl	8007be4 <_sbrk_r>
 80075b6:	6020      	str	r0, [r4, #0]
 80075b8:	4629      	mov	r1, r5
 80075ba:	4630      	mov	r0, r6
 80075bc:	f000 fb12 	bl	8007be4 <_sbrk_r>
 80075c0:	1c43      	adds	r3, r0, #1
 80075c2:	d124      	bne.n	800760e <_malloc_r+0x92>
 80075c4:	230c      	movs	r3, #12
 80075c6:	6033      	str	r3, [r6, #0]
 80075c8:	4630      	mov	r0, r6
 80075ca:	f000 fb1c 	bl	8007c06 <__malloc_unlock>
 80075ce:	e7e4      	b.n	800759a <_malloc_r+0x1e>
 80075d0:	680b      	ldr	r3, [r1, #0]
 80075d2:	1b5b      	subs	r3, r3, r5
 80075d4:	d418      	bmi.n	8007608 <_malloc_r+0x8c>
 80075d6:	2b0b      	cmp	r3, #11
 80075d8:	d90f      	bls.n	80075fa <_malloc_r+0x7e>
 80075da:	600b      	str	r3, [r1, #0]
 80075dc:	50cd      	str	r5, [r1, r3]
 80075de:	18cc      	adds	r4, r1, r3
 80075e0:	4630      	mov	r0, r6
 80075e2:	f000 fb10 	bl	8007c06 <__malloc_unlock>
 80075e6:	f104 000b 	add.w	r0, r4, #11
 80075ea:	1d23      	adds	r3, r4, #4
 80075ec:	f020 0007 	bic.w	r0, r0, #7
 80075f0:	1ac3      	subs	r3, r0, r3
 80075f2:	d0d3      	beq.n	800759c <_malloc_r+0x20>
 80075f4:	425a      	negs	r2, r3
 80075f6:	50e2      	str	r2, [r4, r3]
 80075f8:	e7d0      	b.n	800759c <_malloc_r+0x20>
 80075fa:	428c      	cmp	r4, r1
 80075fc:	684b      	ldr	r3, [r1, #4]
 80075fe:	bf16      	itet	ne
 8007600:	6063      	strne	r3, [r4, #4]
 8007602:	6013      	streq	r3, [r2, #0]
 8007604:	460c      	movne	r4, r1
 8007606:	e7eb      	b.n	80075e0 <_malloc_r+0x64>
 8007608:	460c      	mov	r4, r1
 800760a:	6849      	ldr	r1, [r1, #4]
 800760c:	e7cc      	b.n	80075a8 <_malloc_r+0x2c>
 800760e:	1cc4      	adds	r4, r0, #3
 8007610:	f024 0403 	bic.w	r4, r4, #3
 8007614:	42a0      	cmp	r0, r4
 8007616:	d005      	beq.n	8007624 <_malloc_r+0xa8>
 8007618:	1a21      	subs	r1, r4, r0
 800761a:	4630      	mov	r0, r6
 800761c:	f000 fae2 	bl	8007be4 <_sbrk_r>
 8007620:	3001      	adds	r0, #1
 8007622:	d0cf      	beq.n	80075c4 <_malloc_r+0x48>
 8007624:	6025      	str	r5, [r4, #0]
 8007626:	e7db      	b.n	80075e0 <_malloc_r+0x64>
 8007628:	20008ac8 	.word	0x20008ac8
 800762c:	20008acc 	.word	0x20008acc

08007630 <__ssputs_r>:
 8007630:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007634:	688e      	ldr	r6, [r1, #8]
 8007636:	429e      	cmp	r6, r3
 8007638:	4682      	mov	sl, r0
 800763a:	460c      	mov	r4, r1
 800763c:	4690      	mov	r8, r2
 800763e:	4699      	mov	r9, r3
 8007640:	d837      	bhi.n	80076b2 <__ssputs_r+0x82>
 8007642:	898a      	ldrh	r2, [r1, #12]
 8007644:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8007648:	d031      	beq.n	80076ae <__ssputs_r+0x7e>
 800764a:	6825      	ldr	r5, [r4, #0]
 800764c:	6909      	ldr	r1, [r1, #16]
 800764e:	1a6f      	subs	r7, r5, r1
 8007650:	6965      	ldr	r5, [r4, #20]
 8007652:	2302      	movs	r3, #2
 8007654:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8007658:	fb95 f5f3 	sdiv	r5, r5, r3
 800765c:	f109 0301 	add.w	r3, r9, #1
 8007660:	443b      	add	r3, r7
 8007662:	429d      	cmp	r5, r3
 8007664:	bf38      	it	cc
 8007666:	461d      	movcc	r5, r3
 8007668:	0553      	lsls	r3, r2, #21
 800766a:	d530      	bpl.n	80076ce <__ssputs_r+0x9e>
 800766c:	4629      	mov	r1, r5
 800766e:	f7ff ff85 	bl	800757c <_malloc_r>
 8007672:	4606      	mov	r6, r0
 8007674:	b950      	cbnz	r0, 800768c <__ssputs_r+0x5c>
 8007676:	230c      	movs	r3, #12
 8007678:	f8ca 3000 	str.w	r3, [sl]
 800767c:	89a3      	ldrh	r3, [r4, #12]
 800767e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007682:	81a3      	strh	r3, [r4, #12]
 8007684:	f04f 30ff 	mov.w	r0, #4294967295
 8007688:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800768c:	463a      	mov	r2, r7
 800768e:	6921      	ldr	r1, [r4, #16]
 8007690:	f7ff feda 	bl	8007448 <memcpy>
 8007694:	89a3      	ldrh	r3, [r4, #12]
 8007696:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800769a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800769e:	81a3      	strh	r3, [r4, #12]
 80076a0:	6126      	str	r6, [r4, #16]
 80076a2:	6165      	str	r5, [r4, #20]
 80076a4:	443e      	add	r6, r7
 80076a6:	1bed      	subs	r5, r5, r7
 80076a8:	6026      	str	r6, [r4, #0]
 80076aa:	60a5      	str	r5, [r4, #8]
 80076ac:	464e      	mov	r6, r9
 80076ae:	454e      	cmp	r6, r9
 80076b0:	d900      	bls.n	80076b4 <__ssputs_r+0x84>
 80076b2:	464e      	mov	r6, r9
 80076b4:	4632      	mov	r2, r6
 80076b6:	4641      	mov	r1, r8
 80076b8:	6820      	ldr	r0, [r4, #0]
 80076ba:	f7ff fed0 	bl	800745e <memmove>
 80076be:	68a3      	ldr	r3, [r4, #8]
 80076c0:	1b9b      	subs	r3, r3, r6
 80076c2:	60a3      	str	r3, [r4, #8]
 80076c4:	6823      	ldr	r3, [r4, #0]
 80076c6:	441e      	add	r6, r3
 80076c8:	6026      	str	r6, [r4, #0]
 80076ca:	2000      	movs	r0, #0
 80076cc:	e7dc      	b.n	8007688 <__ssputs_r+0x58>
 80076ce:	462a      	mov	r2, r5
 80076d0:	f000 fa9a 	bl	8007c08 <_realloc_r>
 80076d4:	4606      	mov	r6, r0
 80076d6:	2800      	cmp	r0, #0
 80076d8:	d1e2      	bne.n	80076a0 <__ssputs_r+0x70>
 80076da:	6921      	ldr	r1, [r4, #16]
 80076dc:	4650      	mov	r0, sl
 80076de:	f7ff feff 	bl	80074e0 <_free_r>
 80076e2:	e7c8      	b.n	8007676 <__ssputs_r+0x46>

080076e4 <_svfiprintf_r>:
 80076e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80076e8:	461d      	mov	r5, r3
 80076ea:	898b      	ldrh	r3, [r1, #12]
 80076ec:	061f      	lsls	r7, r3, #24
 80076ee:	b09d      	sub	sp, #116	; 0x74
 80076f0:	4680      	mov	r8, r0
 80076f2:	460c      	mov	r4, r1
 80076f4:	4616      	mov	r6, r2
 80076f6:	d50f      	bpl.n	8007718 <_svfiprintf_r+0x34>
 80076f8:	690b      	ldr	r3, [r1, #16]
 80076fa:	b96b      	cbnz	r3, 8007718 <_svfiprintf_r+0x34>
 80076fc:	2140      	movs	r1, #64	; 0x40
 80076fe:	f7ff ff3d 	bl	800757c <_malloc_r>
 8007702:	6020      	str	r0, [r4, #0]
 8007704:	6120      	str	r0, [r4, #16]
 8007706:	b928      	cbnz	r0, 8007714 <_svfiprintf_r+0x30>
 8007708:	230c      	movs	r3, #12
 800770a:	f8c8 3000 	str.w	r3, [r8]
 800770e:	f04f 30ff 	mov.w	r0, #4294967295
 8007712:	e0c8      	b.n	80078a6 <_svfiprintf_r+0x1c2>
 8007714:	2340      	movs	r3, #64	; 0x40
 8007716:	6163      	str	r3, [r4, #20]
 8007718:	2300      	movs	r3, #0
 800771a:	9309      	str	r3, [sp, #36]	; 0x24
 800771c:	2320      	movs	r3, #32
 800771e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8007722:	2330      	movs	r3, #48	; 0x30
 8007724:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8007728:	9503      	str	r5, [sp, #12]
 800772a:	f04f 0b01 	mov.w	fp, #1
 800772e:	4637      	mov	r7, r6
 8007730:	463d      	mov	r5, r7
 8007732:	f815 3b01 	ldrb.w	r3, [r5], #1
 8007736:	b10b      	cbz	r3, 800773c <_svfiprintf_r+0x58>
 8007738:	2b25      	cmp	r3, #37	; 0x25
 800773a:	d13e      	bne.n	80077ba <_svfiprintf_r+0xd6>
 800773c:	ebb7 0a06 	subs.w	sl, r7, r6
 8007740:	d00b      	beq.n	800775a <_svfiprintf_r+0x76>
 8007742:	4653      	mov	r3, sl
 8007744:	4632      	mov	r2, r6
 8007746:	4621      	mov	r1, r4
 8007748:	4640      	mov	r0, r8
 800774a:	f7ff ff71 	bl	8007630 <__ssputs_r>
 800774e:	3001      	adds	r0, #1
 8007750:	f000 80a4 	beq.w	800789c <_svfiprintf_r+0x1b8>
 8007754:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007756:	4453      	add	r3, sl
 8007758:	9309      	str	r3, [sp, #36]	; 0x24
 800775a:	783b      	ldrb	r3, [r7, #0]
 800775c:	2b00      	cmp	r3, #0
 800775e:	f000 809d 	beq.w	800789c <_svfiprintf_r+0x1b8>
 8007762:	2300      	movs	r3, #0
 8007764:	f04f 32ff 	mov.w	r2, #4294967295
 8007768:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800776c:	9304      	str	r3, [sp, #16]
 800776e:	9307      	str	r3, [sp, #28]
 8007770:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8007774:	931a      	str	r3, [sp, #104]	; 0x68
 8007776:	462f      	mov	r7, r5
 8007778:	2205      	movs	r2, #5
 800777a:	f817 1b01 	ldrb.w	r1, [r7], #1
 800777e:	4850      	ldr	r0, [pc, #320]	; (80078c0 <_svfiprintf_r+0x1dc>)
 8007780:	f7f8 fd26 	bl	80001d0 <memchr>
 8007784:	9b04      	ldr	r3, [sp, #16]
 8007786:	b9d0      	cbnz	r0, 80077be <_svfiprintf_r+0xda>
 8007788:	06d9      	lsls	r1, r3, #27
 800778a:	bf44      	itt	mi
 800778c:	2220      	movmi	r2, #32
 800778e:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8007792:	071a      	lsls	r2, r3, #28
 8007794:	bf44      	itt	mi
 8007796:	222b      	movmi	r2, #43	; 0x2b
 8007798:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800779c:	782a      	ldrb	r2, [r5, #0]
 800779e:	2a2a      	cmp	r2, #42	; 0x2a
 80077a0:	d015      	beq.n	80077ce <_svfiprintf_r+0xea>
 80077a2:	9a07      	ldr	r2, [sp, #28]
 80077a4:	462f      	mov	r7, r5
 80077a6:	2000      	movs	r0, #0
 80077a8:	250a      	movs	r5, #10
 80077aa:	4639      	mov	r1, r7
 80077ac:	f811 3b01 	ldrb.w	r3, [r1], #1
 80077b0:	3b30      	subs	r3, #48	; 0x30
 80077b2:	2b09      	cmp	r3, #9
 80077b4:	d94d      	bls.n	8007852 <_svfiprintf_r+0x16e>
 80077b6:	b1b8      	cbz	r0, 80077e8 <_svfiprintf_r+0x104>
 80077b8:	e00f      	b.n	80077da <_svfiprintf_r+0xf6>
 80077ba:	462f      	mov	r7, r5
 80077bc:	e7b8      	b.n	8007730 <_svfiprintf_r+0x4c>
 80077be:	4a40      	ldr	r2, [pc, #256]	; (80078c0 <_svfiprintf_r+0x1dc>)
 80077c0:	1a80      	subs	r0, r0, r2
 80077c2:	fa0b f000 	lsl.w	r0, fp, r0
 80077c6:	4318      	orrs	r0, r3
 80077c8:	9004      	str	r0, [sp, #16]
 80077ca:	463d      	mov	r5, r7
 80077cc:	e7d3      	b.n	8007776 <_svfiprintf_r+0x92>
 80077ce:	9a03      	ldr	r2, [sp, #12]
 80077d0:	1d11      	adds	r1, r2, #4
 80077d2:	6812      	ldr	r2, [r2, #0]
 80077d4:	9103      	str	r1, [sp, #12]
 80077d6:	2a00      	cmp	r2, #0
 80077d8:	db01      	blt.n	80077de <_svfiprintf_r+0xfa>
 80077da:	9207      	str	r2, [sp, #28]
 80077dc:	e004      	b.n	80077e8 <_svfiprintf_r+0x104>
 80077de:	4252      	negs	r2, r2
 80077e0:	f043 0302 	orr.w	r3, r3, #2
 80077e4:	9207      	str	r2, [sp, #28]
 80077e6:	9304      	str	r3, [sp, #16]
 80077e8:	783b      	ldrb	r3, [r7, #0]
 80077ea:	2b2e      	cmp	r3, #46	; 0x2e
 80077ec:	d10c      	bne.n	8007808 <_svfiprintf_r+0x124>
 80077ee:	787b      	ldrb	r3, [r7, #1]
 80077f0:	2b2a      	cmp	r3, #42	; 0x2a
 80077f2:	d133      	bne.n	800785c <_svfiprintf_r+0x178>
 80077f4:	9b03      	ldr	r3, [sp, #12]
 80077f6:	1d1a      	adds	r2, r3, #4
 80077f8:	681b      	ldr	r3, [r3, #0]
 80077fa:	9203      	str	r2, [sp, #12]
 80077fc:	2b00      	cmp	r3, #0
 80077fe:	bfb8      	it	lt
 8007800:	f04f 33ff 	movlt.w	r3, #4294967295
 8007804:	3702      	adds	r7, #2
 8007806:	9305      	str	r3, [sp, #20]
 8007808:	4d2e      	ldr	r5, [pc, #184]	; (80078c4 <_svfiprintf_r+0x1e0>)
 800780a:	7839      	ldrb	r1, [r7, #0]
 800780c:	2203      	movs	r2, #3
 800780e:	4628      	mov	r0, r5
 8007810:	f7f8 fcde 	bl	80001d0 <memchr>
 8007814:	b138      	cbz	r0, 8007826 <_svfiprintf_r+0x142>
 8007816:	2340      	movs	r3, #64	; 0x40
 8007818:	1b40      	subs	r0, r0, r5
 800781a:	fa03 f000 	lsl.w	r0, r3, r0
 800781e:	9b04      	ldr	r3, [sp, #16]
 8007820:	4303      	orrs	r3, r0
 8007822:	3701      	adds	r7, #1
 8007824:	9304      	str	r3, [sp, #16]
 8007826:	7839      	ldrb	r1, [r7, #0]
 8007828:	4827      	ldr	r0, [pc, #156]	; (80078c8 <_svfiprintf_r+0x1e4>)
 800782a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800782e:	2206      	movs	r2, #6
 8007830:	1c7e      	adds	r6, r7, #1
 8007832:	f7f8 fccd 	bl	80001d0 <memchr>
 8007836:	2800      	cmp	r0, #0
 8007838:	d038      	beq.n	80078ac <_svfiprintf_r+0x1c8>
 800783a:	4b24      	ldr	r3, [pc, #144]	; (80078cc <_svfiprintf_r+0x1e8>)
 800783c:	bb13      	cbnz	r3, 8007884 <_svfiprintf_r+0x1a0>
 800783e:	9b03      	ldr	r3, [sp, #12]
 8007840:	3307      	adds	r3, #7
 8007842:	f023 0307 	bic.w	r3, r3, #7
 8007846:	3308      	adds	r3, #8
 8007848:	9303      	str	r3, [sp, #12]
 800784a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800784c:	444b      	add	r3, r9
 800784e:	9309      	str	r3, [sp, #36]	; 0x24
 8007850:	e76d      	b.n	800772e <_svfiprintf_r+0x4a>
 8007852:	fb05 3202 	mla	r2, r5, r2, r3
 8007856:	2001      	movs	r0, #1
 8007858:	460f      	mov	r7, r1
 800785a:	e7a6      	b.n	80077aa <_svfiprintf_r+0xc6>
 800785c:	2300      	movs	r3, #0
 800785e:	3701      	adds	r7, #1
 8007860:	9305      	str	r3, [sp, #20]
 8007862:	4619      	mov	r1, r3
 8007864:	250a      	movs	r5, #10
 8007866:	4638      	mov	r0, r7
 8007868:	f810 2b01 	ldrb.w	r2, [r0], #1
 800786c:	3a30      	subs	r2, #48	; 0x30
 800786e:	2a09      	cmp	r2, #9
 8007870:	d903      	bls.n	800787a <_svfiprintf_r+0x196>
 8007872:	2b00      	cmp	r3, #0
 8007874:	d0c8      	beq.n	8007808 <_svfiprintf_r+0x124>
 8007876:	9105      	str	r1, [sp, #20]
 8007878:	e7c6      	b.n	8007808 <_svfiprintf_r+0x124>
 800787a:	fb05 2101 	mla	r1, r5, r1, r2
 800787e:	2301      	movs	r3, #1
 8007880:	4607      	mov	r7, r0
 8007882:	e7f0      	b.n	8007866 <_svfiprintf_r+0x182>
 8007884:	ab03      	add	r3, sp, #12
 8007886:	9300      	str	r3, [sp, #0]
 8007888:	4622      	mov	r2, r4
 800788a:	4b11      	ldr	r3, [pc, #68]	; (80078d0 <_svfiprintf_r+0x1ec>)
 800788c:	a904      	add	r1, sp, #16
 800788e:	4640      	mov	r0, r8
 8007890:	f3af 8000 	nop.w
 8007894:	f1b0 3fff 	cmp.w	r0, #4294967295
 8007898:	4681      	mov	r9, r0
 800789a:	d1d6      	bne.n	800784a <_svfiprintf_r+0x166>
 800789c:	89a3      	ldrh	r3, [r4, #12]
 800789e:	065b      	lsls	r3, r3, #25
 80078a0:	f53f af35 	bmi.w	800770e <_svfiprintf_r+0x2a>
 80078a4:	9809      	ldr	r0, [sp, #36]	; 0x24
 80078a6:	b01d      	add	sp, #116	; 0x74
 80078a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80078ac:	ab03      	add	r3, sp, #12
 80078ae:	9300      	str	r3, [sp, #0]
 80078b0:	4622      	mov	r2, r4
 80078b2:	4b07      	ldr	r3, [pc, #28]	; (80078d0 <_svfiprintf_r+0x1ec>)
 80078b4:	a904      	add	r1, sp, #16
 80078b6:	4640      	mov	r0, r8
 80078b8:	f000 f882 	bl	80079c0 <_printf_i>
 80078bc:	e7ea      	b.n	8007894 <_svfiprintf_r+0x1b0>
 80078be:	bf00      	nop
 80078c0:	0800818c 	.word	0x0800818c
 80078c4:	08008192 	.word	0x08008192
 80078c8:	08008196 	.word	0x08008196
 80078cc:	00000000 	.word	0x00000000
 80078d0:	08007631 	.word	0x08007631

080078d4 <_printf_common>:
 80078d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80078d8:	4691      	mov	r9, r2
 80078da:	461f      	mov	r7, r3
 80078dc:	688a      	ldr	r2, [r1, #8]
 80078de:	690b      	ldr	r3, [r1, #16]
 80078e0:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80078e4:	4293      	cmp	r3, r2
 80078e6:	bfb8      	it	lt
 80078e8:	4613      	movlt	r3, r2
 80078ea:	f8c9 3000 	str.w	r3, [r9]
 80078ee:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 80078f2:	4606      	mov	r6, r0
 80078f4:	460c      	mov	r4, r1
 80078f6:	b112      	cbz	r2, 80078fe <_printf_common+0x2a>
 80078f8:	3301      	adds	r3, #1
 80078fa:	f8c9 3000 	str.w	r3, [r9]
 80078fe:	6823      	ldr	r3, [r4, #0]
 8007900:	0699      	lsls	r1, r3, #26
 8007902:	bf42      	ittt	mi
 8007904:	f8d9 3000 	ldrmi.w	r3, [r9]
 8007908:	3302      	addmi	r3, #2
 800790a:	f8c9 3000 	strmi.w	r3, [r9]
 800790e:	6825      	ldr	r5, [r4, #0]
 8007910:	f015 0506 	ands.w	r5, r5, #6
 8007914:	d107      	bne.n	8007926 <_printf_common+0x52>
 8007916:	f104 0a19 	add.w	sl, r4, #25
 800791a:	68e3      	ldr	r3, [r4, #12]
 800791c:	f8d9 2000 	ldr.w	r2, [r9]
 8007920:	1a9b      	subs	r3, r3, r2
 8007922:	42ab      	cmp	r3, r5
 8007924:	dc28      	bgt.n	8007978 <_printf_common+0xa4>
 8007926:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 800792a:	6822      	ldr	r2, [r4, #0]
 800792c:	3300      	adds	r3, #0
 800792e:	bf18      	it	ne
 8007930:	2301      	movne	r3, #1
 8007932:	0692      	lsls	r2, r2, #26
 8007934:	d42d      	bmi.n	8007992 <_printf_common+0xbe>
 8007936:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800793a:	4639      	mov	r1, r7
 800793c:	4630      	mov	r0, r6
 800793e:	47c0      	blx	r8
 8007940:	3001      	adds	r0, #1
 8007942:	d020      	beq.n	8007986 <_printf_common+0xb2>
 8007944:	6823      	ldr	r3, [r4, #0]
 8007946:	68e5      	ldr	r5, [r4, #12]
 8007948:	f8d9 2000 	ldr.w	r2, [r9]
 800794c:	f003 0306 	and.w	r3, r3, #6
 8007950:	2b04      	cmp	r3, #4
 8007952:	bf08      	it	eq
 8007954:	1aad      	subeq	r5, r5, r2
 8007956:	68a3      	ldr	r3, [r4, #8]
 8007958:	6922      	ldr	r2, [r4, #16]
 800795a:	bf0c      	ite	eq
 800795c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8007960:	2500      	movne	r5, #0
 8007962:	4293      	cmp	r3, r2
 8007964:	bfc4      	itt	gt
 8007966:	1a9b      	subgt	r3, r3, r2
 8007968:	18ed      	addgt	r5, r5, r3
 800796a:	f04f 0900 	mov.w	r9, #0
 800796e:	341a      	adds	r4, #26
 8007970:	454d      	cmp	r5, r9
 8007972:	d11a      	bne.n	80079aa <_printf_common+0xd6>
 8007974:	2000      	movs	r0, #0
 8007976:	e008      	b.n	800798a <_printf_common+0xb6>
 8007978:	2301      	movs	r3, #1
 800797a:	4652      	mov	r2, sl
 800797c:	4639      	mov	r1, r7
 800797e:	4630      	mov	r0, r6
 8007980:	47c0      	blx	r8
 8007982:	3001      	adds	r0, #1
 8007984:	d103      	bne.n	800798e <_printf_common+0xba>
 8007986:	f04f 30ff 	mov.w	r0, #4294967295
 800798a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800798e:	3501      	adds	r5, #1
 8007990:	e7c3      	b.n	800791a <_printf_common+0x46>
 8007992:	18e1      	adds	r1, r4, r3
 8007994:	1c5a      	adds	r2, r3, #1
 8007996:	2030      	movs	r0, #48	; 0x30
 8007998:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 800799c:	4422      	add	r2, r4
 800799e:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80079a2:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 80079a6:	3302      	adds	r3, #2
 80079a8:	e7c5      	b.n	8007936 <_printf_common+0x62>
 80079aa:	2301      	movs	r3, #1
 80079ac:	4622      	mov	r2, r4
 80079ae:	4639      	mov	r1, r7
 80079b0:	4630      	mov	r0, r6
 80079b2:	47c0      	blx	r8
 80079b4:	3001      	adds	r0, #1
 80079b6:	d0e6      	beq.n	8007986 <_printf_common+0xb2>
 80079b8:	f109 0901 	add.w	r9, r9, #1
 80079bc:	e7d8      	b.n	8007970 <_printf_common+0x9c>
	...

080079c0 <_printf_i>:
 80079c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80079c4:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 80079c8:	460c      	mov	r4, r1
 80079ca:	7e09      	ldrb	r1, [r1, #24]
 80079cc:	b085      	sub	sp, #20
 80079ce:	296e      	cmp	r1, #110	; 0x6e
 80079d0:	4617      	mov	r7, r2
 80079d2:	4606      	mov	r6, r0
 80079d4:	4698      	mov	r8, r3
 80079d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80079d8:	f000 80b3 	beq.w	8007b42 <_printf_i+0x182>
 80079dc:	d822      	bhi.n	8007a24 <_printf_i+0x64>
 80079de:	2963      	cmp	r1, #99	; 0x63
 80079e0:	d036      	beq.n	8007a50 <_printf_i+0x90>
 80079e2:	d80a      	bhi.n	80079fa <_printf_i+0x3a>
 80079e4:	2900      	cmp	r1, #0
 80079e6:	f000 80b9 	beq.w	8007b5c <_printf_i+0x19c>
 80079ea:	2958      	cmp	r1, #88	; 0x58
 80079ec:	f000 8083 	beq.w	8007af6 <_printf_i+0x136>
 80079f0:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80079f4:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 80079f8:	e032      	b.n	8007a60 <_printf_i+0xa0>
 80079fa:	2964      	cmp	r1, #100	; 0x64
 80079fc:	d001      	beq.n	8007a02 <_printf_i+0x42>
 80079fe:	2969      	cmp	r1, #105	; 0x69
 8007a00:	d1f6      	bne.n	80079f0 <_printf_i+0x30>
 8007a02:	6820      	ldr	r0, [r4, #0]
 8007a04:	6813      	ldr	r3, [r2, #0]
 8007a06:	0605      	lsls	r5, r0, #24
 8007a08:	f103 0104 	add.w	r1, r3, #4
 8007a0c:	d52a      	bpl.n	8007a64 <_printf_i+0xa4>
 8007a0e:	681b      	ldr	r3, [r3, #0]
 8007a10:	6011      	str	r1, [r2, #0]
 8007a12:	2b00      	cmp	r3, #0
 8007a14:	da03      	bge.n	8007a1e <_printf_i+0x5e>
 8007a16:	222d      	movs	r2, #45	; 0x2d
 8007a18:	425b      	negs	r3, r3
 8007a1a:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8007a1e:	486f      	ldr	r0, [pc, #444]	; (8007bdc <_printf_i+0x21c>)
 8007a20:	220a      	movs	r2, #10
 8007a22:	e039      	b.n	8007a98 <_printf_i+0xd8>
 8007a24:	2973      	cmp	r1, #115	; 0x73
 8007a26:	f000 809d 	beq.w	8007b64 <_printf_i+0x1a4>
 8007a2a:	d808      	bhi.n	8007a3e <_printf_i+0x7e>
 8007a2c:	296f      	cmp	r1, #111	; 0x6f
 8007a2e:	d020      	beq.n	8007a72 <_printf_i+0xb2>
 8007a30:	2970      	cmp	r1, #112	; 0x70
 8007a32:	d1dd      	bne.n	80079f0 <_printf_i+0x30>
 8007a34:	6823      	ldr	r3, [r4, #0]
 8007a36:	f043 0320 	orr.w	r3, r3, #32
 8007a3a:	6023      	str	r3, [r4, #0]
 8007a3c:	e003      	b.n	8007a46 <_printf_i+0x86>
 8007a3e:	2975      	cmp	r1, #117	; 0x75
 8007a40:	d017      	beq.n	8007a72 <_printf_i+0xb2>
 8007a42:	2978      	cmp	r1, #120	; 0x78
 8007a44:	d1d4      	bne.n	80079f0 <_printf_i+0x30>
 8007a46:	2378      	movs	r3, #120	; 0x78
 8007a48:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8007a4c:	4864      	ldr	r0, [pc, #400]	; (8007be0 <_printf_i+0x220>)
 8007a4e:	e055      	b.n	8007afc <_printf_i+0x13c>
 8007a50:	6813      	ldr	r3, [r2, #0]
 8007a52:	1d19      	adds	r1, r3, #4
 8007a54:	681b      	ldr	r3, [r3, #0]
 8007a56:	6011      	str	r1, [r2, #0]
 8007a58:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8007a5c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8007a60:	2301      	movs	r3, #1
 8007a62:	e08c      	b.n	8007b7e <_printf_i+0x1be>
 8007a64:	681b      	ldr	r3, [r3, #0]
 8007a66:	6011      	str	r1, [r2, #0]
 8007a68:	f010 0f40 	tst.w	r0, #64	; 0x40
 8007a6c:	bf18      	it	ne
 8007a6e:	b21b      	sxthne	r3, r3
 8007a70:	e7cf      	b.n	8007a12 <_printf_i+0x52>
 8007a72:	6813      	ldr	r3, [r2, #0]
 8007a74:	6825      	ldr	r5, [r4, #0]
 8007a76:	1d18      	adds	r0, r3, #4
 8007a78:	6010      	str	r0, [r2, #0]
 8007a7a:	0628      	lsls	r0, r5, #24
 8007a7c:	d501      	bpl.n	8007a82 <_printf_i+0xc2>
 8007a7e:	681b      	ldr	r3, [r3, #0]
 8007a80:	e002      	b.n	8007a88 <_printf_i+0xc8>
 8007a82:	0668      	lsls	r0, r5, #25
 8007a84:	d5fb      	bpl.n	8007a7e <_printf_i+0xbe>
 8007a86:	881b      	ldrh	r3, [r3, #0]
 8007a88:	4854      	ldr	r0, [pc, #336]	; (8007bdc <_printf_i+0x21c>)
 8007a8a:	296f      	cmp	r1, #111	; 0x6f
 8007a8c:	bf14      	ite	ne
 8007a8e:	220a      	movne	r2, #10
 8007a90:	2208      	moveq	r2, #8
 8007a92:	2100      	movs	r1, #0
 8007a94:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8007a98:	6865      	ldr	r5, [r4, #4]
 8007a9a:	60a5      	str	r5, [r4, #8]
 8007a9c:	2d00      	cmp	r5, #0
 8007a9e:	f2c0 8095 	blt.w	8007bcc <_printf_i+0x20c>
 8007aa2:	6821      	ldr	r1, [r4, #0]
 8007aa4:	f021 0104 	bic.w	r1, r1, #4
 8007aa8:	6021      	str	r1, [r4, #0]
 8007aaa:	2b00      	cmp	r3, #0
 8007aac:	d13d      	bne.n	8007b2a <_printf_i+0x16a>
 8007aae:	2d00      	cmp	r5, #0
 8007ab0:	f040 808e 	bne.w	8007bd0 <_printf_i+0x210>
 8007ab4:	4665      	mov	r5, ip
 8007ab6:	2a08      	cmp	r2, #8
 8007ab8:	d10b      	bne.n	8007ad2 <_printf_i+0x112>
 8007aba:	6823      	ldr	r3, [r4, #0]
 8007abc:	07db      	lsls	r3, r3, #31
 8007abe:	d508      	bpl.n	8007ad2 <_printf_i+0x112>
 8007ac0:	6923      	ldr	r3, [r4, #16]
 8007ac2:	6862      	ldr	r2, [r4, #4]
 8007ac4:	429a      	cmp	r2, r3
 8007ac6:	bfde      	ittt	le
 8007ac8:	2330      	movle	r3, #48	; 0x30
 8007aca:	f805 3c01 	strble.w	r3, [r5, #-1]
 8007ace:	f105 35ff 	addle.w	r5, r5, #4294967295
 8007ad2:	ebac 0305 	sub.w	r3, ip, r5
 8007ad6:	6123      	str	r3, [r4, #16]
 8007ad8:	f8cd 8000 	str.w	r8, [sp]
 8007adc:	463b      	mov	r3, r7
 8007ade:	aa03      	add	r2, sp, #12
 8007ae0:	4621      	mov	r1, r4
 8007ae2:	4630      	mov	r0, r6
 8007ae4:	f7ff fef6 	bl	80078d4 <_printf_common>
 8007ae8:	3001      	adds	r0, #1
 8007aea:	d14d      	bne.n	8007b88 <_printf_i+0x1c8>
 8007aec:	f04f 30ff 	mov.w	r0, #4294967295
 8007af0:	b005      	add	sp, #20
 8007af2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8007af6:	4839      	ldr	r0, [pc, #228]	; (8007bdc <_printf_i+0x21c>)
 8007af8:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 8007afc:	6813      	ldr	r3, [r2, #0]
 8007afe:	6821      	ldr	r1, [r4, #0]
 8007b00:	1d1d      	adds	r5, r3, #4
 8007b02:	681b      	ldr	r3, [r3, #0]
 8007b04:	6015      	str	r5, [r2, #0]
 8007b06:	060a      	lsls	r2, r1, #24
 8007b08:	d50b      	bpl.n	8007b22 <_printf_i+0x162>
 8007b0a:	07ca      	lsls	r2, r1, #31
 8007b0c:	bf44      	itt	mi
 8007b0e:	f041 0120 	orrmi.w	r1, r1, #32
 8007b12:	6021      	strmi	r1, [r4, #0]
 8007b14:	b91b      	cbnz	r3, 8007b1e <_printf_i+0x15e>
 8007b16:	6822      	ldr	r2, [r4, #0]
 8007b18:	f022 0220 	bic.w	r2, r2, #32
 8007b1c:	6022      	str	r2, [r4, #0]
 8007b1e:	2210      	movs	r2, #16
 8007b20:	e7b7      	b.n	8007a92 <_printf_i+0xd2>
 8007b22:	064d      	lsls	r5, r1, #25
 8007b24:	bf48      	it	mi
 8007b26:	b29b      	uxthmi	r3, r3
 8007b28:	e7ef      	b.n	8007b0a <_printf_i+0x14a>
 8007b2a:	4665      	mov	r5, ip
 8007b2c:	fbb3 f1f2 	udiv	r1, r3, r2
 8007b30:	fb02 3311 	mls	r3, r2, r1, r3
 8007b34:	5cc3      	ldrb	r3, [r0, r3]
 8007b36:	f805 3d01 	strb.w	r3, [r5, #-1]!
 8007b3a:	460b      	mov	r3, r1
 8007b3c:	2900      	cmp	r1, #0
 8007b3e:	d1f5      	bne.n	8007b2c <_printf_i+0x16c>
 8007b40:	e7b9      	b.n	8007ab6 <_printf_i+0xf6>
 8007b42:	6813      	ldr	r3, [r2, #0]
 8007b44:	6825      	ldr	r5, [r4, #0]
 8007b46:	6961      	ldr	r1, [r4, #20]
 8007b48:	1d18      	adds	r0, r3, #4
 8007b4a:	6010      	str	r0, [r2, #0]
 8007b4c:	0628      	lsls	r0, r5, #24
 8007b4e:	681b      	ldr	r3, [r3, #0]
 8007b50:	d501      	bpl.n	8007b56 <_printf_i+0x196>
 8007b52:	6019      	str	r1, [r3, #0]
 8007b54:	e002      	b.n	8007b5c <_printf_i+0x19c>
 8007b56:	066a      	lsls	r2, r5, #25
 8007b58:	d5fb      	bpl.n	8007b52 <_printf_i+0x192>
 8007b5a:	8019      	strh	r1, [r3, #0]
 8007b5c:	2300      	movs	r3, #0
 8007b5e:	6123      	str	r3, [r4, #16]
 8007b60:	4665      	mov	r5, ip
 8007b62:	e7b9      	b.n	8007ad8 <_printf_i+0x118>
 8007b64:	6813      	ldr	r3, [r2, #0]
 8007b66:	1d19      	adds	r1, r3, #4
 8007b68:	6011      	str	r1, [r2, #0]
 8007b6a:	681d      	ldr	r5, [r3, #0]
 8007b6c:	6862      	ldr	r2, [r4, #4]
 8007b6e:	2100      	movs	r1, #0
 8007b70:	4628      	mov	r0, r5
 8007b72:	f7f8 fb2d 	bl	80001d0 <memchr>
 8007b76:	b108      	cbz	r0, 8007b7c <_printf_i+0x1bc>
 8007b78:	1b40      	subs	r0, r0, r5
 8007b7a:	6060      	str	r0, [r4, #4]
 8007b7c:	6863      	ldr	r3, [r4, #4]
 8007b7e:	6123      	str	r3, [r4, #16]
 8007b80:	2300      	movs	r3, #0
 8007b82:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8007b86:	e7a7      	b.n	8007ad8 <_printf_i+0x118>
 8007b88:	6923      	ldr	r3, [r4, #16]
 8007b8a:	462a      	mov	r2, r5
 8007b8c:	4639      	mov	r1, r7
 8007b8e:	4630      	mov	r0, r6
 8007b90:	47c0      	blx	r8
 8007b92:	3001      	adds	r0, #1
 8007b94:	d0aa      	beq.n	8007aec <_printf_i+0x12c>
 8007b96:	6823      	ldr	r3, [r4, #0]
 8007b98:	079b      	lsls	r3, r3, #30
 8007b9a:	d413      	bmi.n	8007bc4 <_printf_i+0x204>
 8007b9c:	68e0      	ldr	r0, [r4, #12]
 8007b9e:	9b03      	ldr	r3, [sp, #12]
 8007ba0:	4298      	cmp	r0, r3
 8007ba2:	bfb8      	it	lt
 8007ba4:	4618      	movlt	r0, r3
 8007ba6:	e7a3      	b.n	8007af0 <_printf_i+0x130>
 8007ba8:	2301      	movs	r3, #1
 8007baa:	464a      	mov	r2, r9
 8007bac:	4639      	mov	r1, r7
 8007bae:	4630      	mov	r0, r6
 8007bb0:	47c0      	blx	r8
 8007bb2:	3001      	adds	r0, #1
 8007bb4:	d09a      	beq.n	8007aec <_printf_i+0x12c>
 8007bb6:	3501      	adds	r5, #1
 8007bb8:	68e3      	ldr	r3, [r4, #12]
 8007bba:	9a03      	ldr	r2, [sp, #12]
 8007bbc:	1a9b      	subs	r3, r3, r2
 8007bbe:	42ab      	cmp	r3, r5
 8007bc0:	dcf2      	bgt.n	8007ba8 <_printf_i+0x1e8>
 8007bc2:	e7eb      	b.n	8007b9c <_printf_i+0x1dc>
 8007bc4:	2500      	movs	r5, #0
 8007bc6:	f104 0919 	add.w	r9, r4, #25
 8007bca:	e7f5      	b.n	8007bb8 <_printf_i+0x1f8>
 8007bcc:	2b00      	cmp	r3, #0
 8007bce:	d1ac      	bne.n	8007b2a <_printf_i+0x16a>
 8007bd0:	7803      	ldrb	r3, [r0, #0]
 8007bd2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8007bd6:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8007bda:	e76c      	b.n	8007ab6 <_printf_i+0xf6>
 8007bdc:	0800819d 	.word	0x0800819d
 8007be0:	080081ae 	.word	0x080081ae

08007be4 <_sbrk_r>:
 8007be4:	b538      	push	{r3, r4, r5, lr}
 8007be6:	4c06      	ldr	r4, [pc, #24]	; (8007c00 <_sbrk_r+0x1c>)
 8007be8:	2300      	movs	r3, #0
 8007bea:	4605      	mov	r5, r0
 8007bec:	4608      	mov	r0, r1
 8007bee:	6023      	str	r3, [r4, #0]
 8007bf0:	f7fd fe8e 	bl	8005910 <_sbrk>
 8007bf4:	1c43      	adds	r3, r0, #1
 8007bf6:	d102      	bne.n	8007bfe <_sbrk_r+0x1a>
 8007bf8:	6823      	ldr	r3, [r4, #0]
 8007bfa:	b103      	cbz	r3, 8007bfe <_sbrk_r+0x1a>
 8007bfc:	602b      	str	r3, [r5, #0]
 8007bfe:	bd38      	pop	{r3, r4, r5, pc}
 8007c00:	20008fc8 	.word	0x20008fc8

08007c04 <__malloc_lock>:
 8007c04:	4770      	bx	lr

08007c06 <__malloc_unlock>:
 8007c06:	4770      	bx	lr

08007c08 <_realloc_r>:
 8007c08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007c0a:	4607      	mov	r7, r0
 8007c0c:	4614      	mov	r4, r2
 8007c0e:	460e      	mov	r6, r1
 8007c10:	b921      	cbnz	r1, 8007c1c <_realloc_r+0x14>
 8007c12:	4611      	mov	r1, r2
 8007c14:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8007c18:	f7ff bcb0 	b.w	800757c <_malloc_r>
 8007c1c:	b922      	cbnz	r2, 8007c28 <_realloc_r+0x20>
 8007c1e:	f7ff fc5f 	bl	80074e0 <_free_r>
 8007c22:	4625      	mov	r5, r4
 8007c24:	4628      	mov	r0, r5
 8007c26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007c28:	f000 f814 	bl	8007c54 <_malloc_usable_size_r>
 8007c2c:	42a0      	cmp	r0, r4
 8007c2e:	d20f      	bcs.n	8007c50 <_realloc_r+0x48>
 8007c30:	4621      	mov	r1, r4
 8007c32:	4638      	mov	r0, r7
 8007c34:	f7ff fca2 	bl	800757c <_malloc_r>
 8007c38:	4605      	mov	r5, r0
 8007c3a:	2800      	cmp	r0, #0
 8007c3c:	d0f2      	beq.n	8007c24 <_realloc_r+0x1c>
 8007c3e:	4631      	mov	r1, r6
 8007c40:	4622      	mov	r2, r4
 8007c42:	f7ff fc01 	bl	8007448 <memcpy>
 8007c46:	4631      	mov	r1, r6
 8007c48:	4638      	mov	r0, r7
 8007c4a:	f7ff fc49 	bl	80074e0 <_free_r>
 8007c4e:	e7e9      	b.n	8007c24 <_realloc_r+0x1c>
 8007c50:	4635      	mov	r5, r6
 8007c52:	e7e7      	b.n	8007c24 <_realloc_r+0x1c>

08007c54 <_malloc_usable_size_r>:
 8007c54:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8007c58:	1f18      	subs	r0, r3, #4
 8007c5a:	2b00      	cmp	r3, #0
 8007c5c:	bfbc      	itt	lt
 8007c5e:	580b      	ldrlt	r3, [r1, r0]
 8007c60:	18c0      	addlt	r0, r0, r3
 8007c62:	4770      	bx	lr

08007c64 <_init>:
 8007c64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007c66:	bf00      	nop
 8007c68:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8007c6a:	bc08      	pop	{r3}
 8007c6c:	469e      	mov	lr, r3
 8007c6e:	4770      	bx	lr

08007c70 <_fini>:
 8007c70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007c72:	bf00      	nop
 8007c74:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8007c76:	bc08      	pop	{r3}
 8007c78:	469e      	mov	lr, r3
 8007c7a:	4770      	bx	lr
